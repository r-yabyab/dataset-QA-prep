=== Chunk 1 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0001.two-sum\TwoSum.java

class TwoSum {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++)
            for (int j = i + 1; j < nums.length; j++)
                if (nums[i] + nums[j] == target)
                    return new int[]{i, j};
        return new int[]{};
    }
}

=== Chunk 2 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0001.two-sum\TwoSum2.java

import java.util.HashMap;
import java.util.Map;

class TwoSum2 {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (hashtable.containsKey(target - nums[i]))
                return new int[]{hashtable.get(target - nums[i]), i};
            hashtable.put(nums[i], i);
        }
        return new int[]{};
    }
}

=== Chunk 3 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0001.two-sum\TwoSumTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 4 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0001.two-sum\TwoSumTest.java

public class TwoSumTest {
    TwoSum twoSum = new TwoSum();
    TwoSum2 twoSum2 = new TwoSum2();

    @Test
    void Example1() {
        int[] nums = {2, 7, 11, 15};
        int target = 9;
        int[] expectedResults = {0, 1};

        int[] results;

        results = twoSum.twoSum(nums, target);
        Assertions.assertArrayEquals(expectedResults, results);

        results = twoSum2.twoSum(nums, target);
        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {3, 2, 4};
        int target = 6;
        int[] expectedResults = {1, 2};

        int[] results;

        results = twoSum.twoSum(nums, target);
        Assertions.assertArrayEquals(expectedResults, results);

=== Chunk 5 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0001.two-sum\TwoSumTest.java

results = twoSum2.twoSum(nums, target);
        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {3, 3};
        int target = 6;
        int[] expectedResults = {0, 1};

        int[] results;

        results = twoSum.twoSum(nums, target);
        Assertions.assertArrayEquals(expectedResults, results);

        results = twoSum2.twoSum(nums, target);
        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 6 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0002.add-two-numbers\AddTwoNumbers.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

=== Chunk 7 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0002.add-two-numbers\AddTwoNumbers.java

class AddTwoNumbers {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode curr = dummyHead;
        int carry = 0;
        while(l1 != null || l2 != null || carry != 0) {
            int val = 0;
            if (l1 != null && l2 != null) {
                val = l1.val + l2.val;
            } else if (l1 != null) {
                val = l1.val;
            } else if (l2 != null ){
                val = l2.val;
            }
            val += carry;
            curr.next = new ListNode((val % 10));
            curr = curr.next;
            carry = val / 10;
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        return dummyHead.next;
    }
}

=== Chunk 8 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0002.add-two-numbers\AddTwoNumbersTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 9 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0002.add-two-numbers\AddTwoNumbersTest.java

public class AddTwoNumbersTest {
    AddTwoNumbers AddTwoNumbers = new AddTwoNumbers();

    @Test
    void Example1() {
        ListNode l1 = new ListNode(2);
        l1.next = new ListNode(4);
        l1.next.next = new ListNode(3);
        ListNode l2 = new ListNode(5);
        l2.next = new ListNode(6);
        l2.next.next = new ListNode(4);

        ListNode results = AddTwoNumbers.addTwoNumbers(l1, l2);
        Assertions.assertEquals(7, results.val);
        Assertions.assertEquals(0, results.next.val);
        Assertions.assertEquals(8, results.next.next.val);
    }

    @Test
    void Example2() {
        ListNode l1 = new ListNode(0);
        ListNode l2 = new ListNode(0);

        ListNode results = AddTwoNumbers.addTwoNumbers(l1, l2);

=== Chunk 10 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0002.add-two-numbers\AddTwoNumbersTest.java

Assertions.assertEquals(0, results.val);
    }

    @Test
    void Example3() {
        ListNode l1 = new ListNode(9);
        l1.next = new ListNode(9);
        l1.next.next = new ListNode(9);
        l1.next.next.next = new ListNode(9);
        l1.next.next.next.next = new ListNode(9);
        l1.next.next.next.next.next = new ListNode(9);
        l1.next.next.next.next.next.next = new ListNode(9);
        ListNode l2 = new ListNode(9);
        l2.next = new ListNode(9);
        l2.next.next = new ListNode(9);
        l2.next.next.next = new ListNode(9);

        ListNode results = AddTwoNumbers.addTwoNumbers(l1, l2);
        Assertions.assertEquals(8, results.val);
        Assertions.assertEquals(9, results.next.val);

=== Chunk 11 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0002.add-two-numbers\AddTwoNumbersTest.java

Assertions.assertEquals(9, results.next.next.val);
        Assertions.assertEquals(9, results.next.next.next.val);
        Assertions.assertEquals(0, results.next.next.next.next.val);
        Assertions.assertEquals(0, results.next.next.next.next.next.val);
        Assertions.assertEquals(0, results.next.next.next.next.next.next.val);
        Assertions.assertEquals(1, results.next.next.next.next.next.next.next.val);
    }
}

=== Chunk 12 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0003.longest-substring-without-repeating-characters\LongestSubstringWithoutRepeatingCharacters.java

class LongestSubstringWithoutRepeatingCharacters {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length(), longest = 0;
        int[] nextIndex = new int[128];

        for (int r = 0, l = 0; r < n; r++) {
            l = Math.max(nextIndex[s.charAt(r)], l);
            longest = Math.max(longest, r - l + 1);
            nextIndex[s.charAt(r)] = r + 1;
        }

        return longest;
    }
}

=== Chunk 13 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0003.longest-substring-without-repeating-characters\LongestSubstringWithoutRepeatingCharactersTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 14 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0003.longest-substring-without-repeating-characters\LongestSubstringWithoutRepeatingCharactersTest.java

public class LongestSubstringWithoutRepeatingCharactersTest {
    LongestSubstringWithoutRepeatingCharacters LongestSubstringWithoutRepeatingCharacters = new LongestSubstringWithoutRepeatingCharacters();

    @Test
    void Example1() {
        String s = "abcabcbb";
        int results = LongestSubstringWithoutRepeatingCharacters.lengthOfLongestSubstring(s);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "bbbbb";
        int results = LongestSubstringWithoutRepeatingCharacters.lengthOfLongestSubstring(s);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 15 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0003.longest-substring-without-repeating-characters\LongestSubstringWithoutRepeatingCharactersTest.java

}

    @Test
    void Example3() {
        String s = "pwwkew";
        int results = LongestSubstringWithoutRepeatingCharacters.lengthOfLongestSubstring(s);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 16 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0005.longest-palindromic-substring\LongestPalindromicSubstring.java

class LongestPalindromicSubstring {
    public String longestPalindrome(String s) {
        if (s == null || s.length() == 0) return "";
        int len = s.length();
        boolean[][] dp = new boolean[len][len];
        int start = 0, end = 0, max = 0;
        for (int i = 0; i < len; i++) {
            for (int j = 0; j <= i; j++) {
                if (s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j + 1][i - 1])) {
                    dp[j][i] = true;
                }
                if (dp[j][i] && max < i - j + 1) {
                    max = i - j + 1;
                    start = j;
                    end = i;
                }
            }
        }
        return s.substring(start, end + 1);
    }
}

=== Chunk 17 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0005.longest-palindromic-substring\LongestPalindromicSubstringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class LongestPalindromicSubstringTest {
    LongestPalindromicSubstring LongestPalindromicSubstring = new LongestPalindromicSubstring();

    @Test
    void Example1() {
        String s = "babad";
        String results = LongestPalindromicSubstring.longestPalindrome(s);
        String expectedResults = "bab";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "cbbd";
        String results = LongestPalindromicSubstring.longestPalindrome(s);
        String expectedResults = "bb";

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 18 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0006.zigzag-conversion\ZigzagConversion.java

import java.util.ArrayList;
import java.util.List;

class ZigzagConversion {
    public String convert(String s, int numRows) {
        if (numRows < 2) return s;
        List<StringBuilder> rows = new ArrayList<>();
        for (int i = 0; i < numRows; i++)
            rows.add(new StringBuilder());
        int i = 0, flag = -1;
        for (char c : s.toCharArray()) {
            rows.get(i).append(c);
            if (i == 0 || i == numRows - 1) flag = -flag;
            i += flag;
        }
        StringBuilder res = new StringBuilder();
        for (StringBuilder row : rows)
            res.append(row);
        return res.toString();
    }
}

=== Chunk 19 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0006.zigzag-conversion\ZigzagConversionTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ZigzagConversionTest {
    ZigzagConversion zigzagConversion = new ZigzagConversion();

    @Test
    void Example1() {
        String s = "PAYPALISHIRING";
        int numRows = 3;

        Assertions.assertEquals("PAHNAPLSIIGYIR", zigzagConversion.convert(s, numRows));
    }

    @Test
    void Example2() {
        String s = "PAYPALISHIRING";
        int numRows = 4;

        Assertions.assertEquals("PINALSIGYAHRPI", zigzagConversion.convert(s, numRows));
    }

    @Test
    void Example3() {
        String s = "A";
        int numRows = 1;

        Assertions.assertEquals("A", zigzagConversion.convert(s, numRows));
    }
}

=== Chunk 20 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0009.palindrome-number\PalindromeNumber.java

class PalindromeNumber {
    public boolean isPalindrome(int x) {
        if (x == 0) {
            return true;
        }
        if (x < 0 || x % 10 == 0) {
            return false;
        }
        int right = 0;
        while (x > right) {
            right = right * 10 + x % 10;
            x /= 10;
        }
        return x == right || x == right / 10;
    }
}

=== Chunk 21 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0009.palindrome-number\PalindromeNumberTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 22 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0009.palindrome-number\PalindromeNumberTest.java

public class PalindromeNumberTest {
    PalindromeNumber PalindromeNumber = new PalindromeNumber();

    @Test
    void Example1() {
        int x = 121;

        boolean results = PalindromeNumber.isPalindrome(x);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int x = -121;

        boolean results = PalindromeNumber.isPalindrome(x);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int x = 10;

        boolean results = PalindromeNumber.isPalindrome(x);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 23 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0009.palindrome-number\PalindromeNumberTest.java

}
}

=== Chunk 24 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0011.container-with-most-water\ContainerWithMostWater.java

class ContainerWithMostWater {
    public int maxArea(int[] height) {
        if (height.length == 0) return 0;
        if (height.length == 1) return height[0];
        int maxArea = 0, left = 0, right = height.length - 1;
        while (left < right) {
            int area = Math.min(height[left], height[right]) * (right - left);
            maxArea = Math.max(maxArea, area);
            if (height[left] > height[right]) right--;
            else left++;
        }

        return maxArea;
    }
}

=== Chunk 25 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0011.container-with-most-water\ContainerWithMostWaterTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ContainerWithMostWaterTest {
    ContainerWithMostWater ContainerWithMostWater = new ContainerWithMostWater();

    @Test
    void Example1() {
        int[] height = {1, 8, 6, 2, 5, 4, 8, 3, 7};
        int results = ContainerWithMostWater.maxArea(height);
        int expectedResults = 49;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] height = {1, 1};
        int results = ContainerWithMostWater.maxArea(height);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 26 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0012.integer-to-roman\IntegerToRoman.java

class IntegerToRoman {
    private final static int[] val = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    private final static String[] rom = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

    public String intToRoman(int num) {
        StringBuilder res = new StringBuilder();
        for (int i = 0; num > 0; i++) {
            while (num >= val[i]) {
                res.append(rom[i]);
                num -= val[i];
            }
        }
        return res.toString();
    }
}

=== Chunk 27 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0012.integer-to-roman\IntegerToRomanTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 28 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0012.integer-to-roman\IntegerToRomanTest.java

public class IntegerToRomanTest {
    IntegerToRoman IntegerToRoman = new IntegerToRoman();

    @Test
    void Example1() {
        int num = 3;
        String results = IntegerToRoman.intToRoman(num);
        String expectedResults = "III";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int num = 58;
        String results = IntegerToRoman.intToRoman(num);
        String expectedResults = "LVIII";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int num = 1994;
        String results = IntegerToRoman.intToRoman(num);
        String expectedResults = "MCMXCIV";

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 29 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0013.roman-to-integer\RomanToInteger.java

class RomanToInteger {
    private int getNum(char c) {
        switch (c) {
            case 'I': return 1;
            case 'V': return 5;
            case 'X': return 10;
            case 'L': return 50;
            case 'C': return 100;
            case 'D': return 500;
            case 'M': return 1000;
        }
        return 0;
    }

    public int romanToInt(String s) {
        int res = 0;
        char[] stringArray = s.toCharArray();
        for (int i = 0; i < s.length(); i++) {
            if (i + 1 < s.length() && getNum(stringArray[i]) < getNum(stringArray[i + 1])) {
                res -= getNum(stringArray[i]);
            } else {
                res += getNum(stringArray[i]);
            }
        }

        return res;
    }
}

=== Chunk 30 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0013.roman-to-integer\RomanToIntegerTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 31 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0013.roman-to-integer\RomanToIntegerTest.java

public class RomanToIntegerTest {
    RomanToInteger RomanToInteger = new RomanToInteger();

    @Test
    void Example1() {
        String s = "III";
        int results = RomanToInteger.romanToInt(s);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "LVIII";
        int results = RomanToInteger.romanToInt(s);
        int expectedResults = 58;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "MCMXCIV";
        int results = RomanToInteger.romanToInt(s);
        int expectedResults = 1994;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 32 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0014.longest-common-prefix\LongestCommonPrefix.java

class LongestCommonPrefix {
    public String longestCommonPrefix(String[] strs) {
        if (strs.length == 0) return "";
        String prefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            while (strs[i].indexOf(prefix) != 0) {
                prefix = prefix.substring(0, prefix.length() - 1);
                if (prefix.isEmpty()) return "";
            }
        }
        return prefix;
    }
}

=== Chunk 33 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0014.longest-common-prefix\LongestCommonPrefixTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class LongestCommonPrefixTest {
    LongestCommonPrefix LongestCommonPrefix = new LongestCommonPrefix();

    @Test
    void Example1() {
        String[] strs = {"flower", "flow", "flight"};
        String results = LongestCommonPrefix.longestCommonPrefix(strs);
        String expectedResults = "fl";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String[] strs = {"dog", "racecar", "car"};
        String results = LongestCommonPrefix.longestCommonPrefix(strs);
        String expectedResults = "";

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 34 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0015.3sum\ThreeSum.java

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 35 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0015.3sum\ThreeSum.java

class ThreeSum {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        int n = nums.length;

        // we only want to find three numbers, so we just need to find length - 2 numbers.
        for (int first = 0; first < n - 2; first++) {
            // remove duplicates
            if (first > 0 && nums[first] == nums[first - 1])
                continue;

            int second = first + 1;
            int third = n - 1;
            while (second < third) {
                int threeSum = nums[first] + nums[second] + nums[third];
                if (threeSum < 0)
                    second++;
                else if (threeSum > 0)
                    third--;
                else {

=== Chunk 36 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0015.3sum\ThreeSum.java

else {
                    ans.add(Arrays.asList(nums[first], nums[second], nums[third]));
                    // remove duplicates in two pointers
                    while (second < third && nums[second] == nums[second + 1])
                        second++;
                    while (second < third && nums[third] == nums[third - 1])
                        third--;
                    second++;
                    third--;
                }
            }
        }
        return ans;
    }
}

=== Chunk 37 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0015.3sum\ThreeSumTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 38 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0015.3sum\ThreeSumTest.java

public class ThreeSumTest {
    ThreeSum threeSum = new ThreeSum();

    @Test
    void Example1() {
        int[] nums = {-1, 0, 1, 2, -1, -4};
        List<List<Integer>> results = threeSum.threeSum(nums);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(-1, -1, 2));
        expectedResults.add(Arrays.asList(-1, 0, 1));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {};
        List<List<Integer>> results = threeSum.threeSum(nums);
        List<List<Integer>> expectedResults = new ArrayList<>();

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {0};

=== Chunk 39 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0015.3sum\ThreeSumTest.java

void Example3() {
        int[] nums = {0};
        List<List<Integer>> results = threeSum.threeSum(nums);
        List<List<Integer>> expectedResults = new ArrayList<>();

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 40 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0016.3sum-closest\ThreeSumClosestClass.java

import java.util.Arrays;

class ThreeSumClosestClass {
    public int threeSumClosest(int[] nums, int target) {
        int result = nums[0] + nums[1] + nums[nums.length - 1];
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            int start = i + 1, end = nums.length - 1;
            while (start < end) {
                int sum = nums[i] + nums[start] + nums[end];
                if (sum > target) end--;
                else start++;
                if (Math.abs(sum - target) < Math.abs(result - target)) {
                    result = sum;
                }
            }
        }
        return result;
    }
}

=== Chunk 41 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0016.3sum-closest\ThreeSumClosestClassTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ThreeSumClosestClassTest {
    ThreeSumClosestClass ThreeSumClosest = new ThreeSumClosestClass();

    @Test
    void Example1() {
        int[] nums = {-1, 2, 1, -4};
        int target = 1;
        int results = ThreeSumClosest.threeSumClosest(nums, target);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {0, 0, 0};
        int target = 1;
        int results = ThreeSumClosest.threeSumClosest(nums, target);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 42 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0017.letter-combinations-of-a-phone-number\LetterCombinationsOfAPhoneNumber.java

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

=== Chunk 43 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0017.letter-combinations-of-a-phone-number\LetterCombinationsOfAPhoneNumber.java

class LetterCombinationsOfAPhoneNumber {
    private void backtrack(List<String> res, char[] digits, String s, String[] dict) {
        if (s.length() == digits.length) {
            res.add(s);
            return;
        }
        int digit = digits[s.length()] - '0';
        for (char letter : dict[digit].toCharArray()) {
            backtrack(res, digits, s + Character.toString(letter), dict);
        }
    }

    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<>();
        if (digits.length() == 0) return res;
        String[] dict = new String[]{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        backtrack(res, digits.toCharArray(), "", dict);
        return res;
    }
}

=== Chunk 44 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0017.letter-combinations-of-a-phone-number\LetterCombinationsOfAPhoneNumberTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

=== Chunk 45 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0017.letter-combinations-of-a-phone-number\LetterCombinationsOfAPhoneNumberTest.java

public class LetterCombinationsOfAPhoneNumberTest {
    LetterCombinationsOfAPhoneNumber LetterCombinationsOfAPhoneNumber = new LetterCombinationsOfAPhoneNumber();

    @Test
    void Example1() {
        String digits = "23";
        List<String> results = LetterCombinationsOfAPhoneNumber.letterCombinations(digits);
        List<String> expectedResults = new ArrayList<>();
        expectedResults.add("ad");
        expectedResults.add("ae");
        expectedResults.add("af");
        expectedResults.add("bd");
        expectedResults.add("be");
        expectedResults.add("bf");
        expectedResults.add("cd");
        expectedResults.add("ce");
        expectedResults.add("cf");

        Assertions.assertEquals(expectedResults, results);
    }

    @Test

=== Chunk 46 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0017.letter-combinations-of-a-phone-number\LetterCombinationsOfAPhoneNumberTest.java

}

    @Test
    void Example2() {
        String digits = "";
        List<String> results = LetterCombinationsOfAPhoneNumber.letterCombinations(digits);
        List<String> expectedResults = new ArrayList<>();

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String digits = "2";
        List<String> results = LetterCombinationsOfAPhoneNumber.letterCombinations(digits);
        List<String> expectedResults = new ArrayList<>();
        expectedResults.add("a");
        expectedResults.add("b");
        expectedResults.add("c");

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 47 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0018.4sum\FourSum.java

import java.util.*;

=== Chunk 48 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0018.4sum\FourSum.java

class FourSum {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        HashSet<List<Integer>> hashSet = new HashSet<>();

        if (nums == null || nums.length < 4) {
            return res;
        }

        int len = nums.length;
        Arrays.sort(nums);

        for (int i = 0; i <= len - 4; i++) {
            for (int j = i + 1; j <= len - 3; j++) {
                int l = j + 1;
                int r = len - 1;
                while (l < r) {
                    int sum = nums[i] + nums[j] + nums[l] + nums[r];
                    if (sum < target) {
                        l++;
                    } else if (sum > target) {
                        r--;
                    } else {

=== Chunk 49 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0018.4sum\FourSum.java

} else {
                        List<Integer> list = new ArrayList<>();
                        list.add(nums[i]);
                        list.add(nums[j]);
                        list.add(nums[l]);
                        list.add(nums[r]);
                        // Remove duplicates
                        if (!hashSet.contains(list)) {
                            hashSet.add(list);
                            res.add(list);
                        }
                        l++;
                        r--;
                    }
                }
            }
        }

        return res;
    }
}

=== Chunk 50 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0018.4sum\FourSumTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

=== Chunk 51 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0018.4sum\FourSumTest.java

public class FourSumTest {
    FourSum fourSum = new FourSum();

    @Test
    void Example1() {
        int[] nums = {1, 0, -1, 0, -2, 2};
        int target = 0;

        List<List<Integer>> expectedResults = new LinkedList<>();
        expectedResults.add(Arrays.asList(-2, -1, 1, 2));
        expectedResults.add(Arrays.asList(-2, 0, 0, 2));
        expectedResults.add(Arrays.asList(-1, 0, 0, 1));

        List<List<Integer>> results;
        results = fourSum.fourSum(nums, target);

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {2, 2, 2, 2, 2};
        int target = 8;

        List<List<Integer>> expectedResults = new LinkedList<>();
        expectedResults.add(Arrays.asList(2, 2, 2, 2));

=== Chunk 52 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0018.4sum\FourSumTest.java

List<List<Integer>> results;
        results = fourSum.fourSum(nums, target);

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 53 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0019.remove-nth-node-from-end-of-list\RemoveNthNodeFromEndOfList.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class RemoveNthNodeFromEndOfList {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if (head == null) return null;
        ListNode fast = head;
        while (n-- > 0) {
            fast = fast.next;
        }
        if (fast == null) return head.next;
        ListNode slow = head;
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return head;
    }
}

=== Chunk 54 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0019.remove-nth-node-from-end-of-list\RemoveNthNodeFromEndOfListTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 55 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0019.remove-nth-node-from-end-of-list\RemoveNthNodeFromEndOfListTest.java

public class RemoveNthNodeFromEndOfListTest {
    RemoveNthNodeFromEndOfList RemoveNthNodeFromEndOfList = new RemoveNthNodeFromEndOfList();

    @Test
    void Example1() {
        ListNode firstNode = new ListNode(1);
        ListNode secondNode = new ListNode(2);
        ListNode thirdNode = new ListNode(3);
        ListNode forthNode = new ListNode(4);
        ListNode fifthNode = new ListNode(5);

        int n = 2;

        firstNode.next = secondNode;
        secondNode.next = thirdNode;
        thirdNode.next = forthNode;
        forthNode.next = fifthNode;

        ListNode results = RemoveNthNodeFromEndOfList.removeNthFromEnd(firstNode, n);

        firstNode.next = secondNode;
        secondNode.next = thirdNode;
        thirdNode.next = fifthNode;

=== Chunk 56 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0019.remove-nth-node-from-end-of-list\RemoveNthNodeFromEndOfListTest.java

thirdNode.next = fifthNode;

        Assertions.assertEquals(firstNode, results);
    }

    @Test
    void Example2() {
        ListNode firstNode = new ListNode(1);

        int n = 1;

        ListNode results = RemoveNthNodeFromEndOfList.removeNthFromEnd(firstNode, n);

        Assertions.assertNull(results);
    }

    @Test
    void Example3() {
        ListNode firstNode = new ListNode(1);
        ListNode secondNode = new ListNode(2);

        int n = 1;

        firstNode.next = secondNode;

        ListNode results = RemoveNthNodeFromEndOfList.removeNthFromEnd(firstNode, n);

        firstNode.next = null;

        Assertions.assertEquals(firstNode, results);
    }
}

=== Chunk 57 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0020.valid-parentheses\ValidParentheses.java

import java.util.HashMap;
import java.util.Map;
import java.util.Stack;

class ValidParentheses {
    public boolean isValid(String s) {
        if (s.length() % 2 == 1) return false;

        Map<Character, Character> pairs = new HashMap<>(){{
            put(')', '(');
            put(']', '[');
            put('}', '{');
        }};
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (pairs.containsKey(c)) {
                if (stack.isEmpty() || stack.peek() != pairs.get(c))
                    return false;
                stack.pop();
            } else {
                stack.push(c);
            }
        }
        return stack.isEmpty();
    }
}

=== Chunk 58 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0020.valid-parentheses\ValidParenthesesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 59 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0020.valid-parentheses\ValidParenthesesTest.java

public class ValidParenthesesTest {
    ValidParentheses validParentheses = new ValidParentheses();

    @Test
    void Example1() {
        String s = "()";
        boolean results = validParentheses.isValid(s);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "()[]{}";
        boolean results = validParentheses.isValid(s);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "(]";
        boolean results = validParentheses.isValid(s);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 60 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0021.merge-two-sorted-lists\MergeTwoSortedLists.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class MergeTwoSortedLists {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null) return list2;
        if (list2 == null) return list1;

        if (list1.val < list2.val) {
            list1.next = mergeTwoLists(list1.next, list2);
            return list1;
        }
        list2.next = mergeTwoLists(list1, list2.next);
        return list2;
    }
}

=== Chunk 61 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0021.merge-two-sorted-lists\MergeTwoSortedListsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 62 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0021.merge-two-sorted-lists\MergeTwoSortedListsTest.java

public class MergeTwoSortedListsTest {
    MergeTwoSortedLists MergeTwoSortedLists = new MergeTwoSortedLists();

    @Test
    void Example1() {
        ListNode list1FirstNode = new ListNode(1);
        ListNode list1SecondNode = new ListNode(2);
        ListNode list1ThirdNode = new ListNode(4);

        ListNode list2FirstNode = new ListNode(1);
        ListNode list2SecondNode = new ListNode(3);
        ListNode list2ThirdNode = new ListNode(4);

        list1FirstNode.next = list1SecondNode;
        list1SecondNode.next = list1ThirdNode;

        list2FirstNode.next = list2SecondNode;
        list2SecondNode.next = list2ThirdNode;

        ListNode results = MergeTwoSortedLists.mergeTwoLists(list1FirstNode, list2FirstNode);

=== Chunk 63 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0021.merge-two-sorted-lists\MergeTwoSortedListsTest.java

list2FirstNode.next = list1FirstNode;
        list1FirstNode.next = list1SecondNode;
        list1SecondNode.next = list2SecondNode;
        list2SecondNode.next = list1ThirdNode;
        list1ThirdNode.next = list2ThirdNode;
        list2ThirdNode.next = null;

        Assertions.assertEquals(list2FirstNode, results);
    }

    @Test
    void Example2() {
        ListNode list1FirstNode = null;
        ListNode list2FirstNode = null;

        ListNode results = MergeTwoSortedLists.mergeTwoLists(list1FirstNode, list2FirstNode);

        Assertions.assertNull(results);
    }

    @Test
    void Example3() {
        ListNode list1FirstNode = null;
        ListNode list2FirstNode = new ListNode(0);

=== Chunk 64 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0021.merge-two-sorted-lists\MergeTwoSortedListsTest.java

ListNode results = MergeTwoSortedLists.mergeTwoLists(list1FirstNode, list2FirstNode);

        Assertions.assertEquals(list2FirstNode, results);
    }
}

=== Chunk 65 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0022.generate-parentheses\GenerateParentheses.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 66 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0022.generate-parentheses\GenerateParentheses.java

class GenerateParentheses {
    private void backtrack(List<String> res, StringBuilder cur, int open, int close, int max) {
        if (cur.length() == max * 2) {
            res.add(cur.toString());
            return;
        }
        if (open < max) {
            cur.append("(");
            backtrack(res, cur, open + 1, close, max);
            cur.deleteCharAt(cur.length() - 1);
        }
        if (close < open) {
            cur.append(")");
            backtrack(res, cur, open, close + 1, max);
            cur.deleteCharAt(cur.length() - 1);
        }
    }

    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        backtrack(res, new StringBuilder(), 0, 0, n);
        return res;
    }
}

=== Chunk 67 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0022.generate-parentheses\GenerateParenthesesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

=== Chunk 68 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0022.generate-parentheses\GenerateParenthesesTest.java

public class GenerateParenthesesTest {
    GenerateParentheses GenerateParentheses = new GenerateParentheses();

    @Test
    void Example1() {
        int n = 3;
        List<String> results = GenerateParentheses.generateParenthesis(n);
        List<String> expectedResults = new ArrayList<>();
        expectedResults.add("((()))");
        expectedResults.add("(()())");
        expectedResults.add("(())()");
        expectedResults.add("()(())");
        expectedResults.add("()()()");

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 1;
        List<String> results = GenerateParentheses.generateParenthesis(n);
        List<String> expectedResults = new ArrayList<>();

=== Chunk 69 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0022.generate-parentheses\GenerateParenthesesTest.java

expectedResults.add("()");

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 70 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0024.swap-nodes-in-pairs\SwapNodesInPairs.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class SwapNodesInPairs {
    public ListNode swapPairs(ListNode head) {
        ListNode node = new ListNode(-1);
        node.next = head;
        ListNode pre = node;
        while (pre.next != null && pre.next.next != null) {
            ListNode l1 = pre.next, l2 = pre.next.next;
            l1.next = l2.next;
            l2.next = l1;
            pre.next = l2;

            pre = l1;
        }
        return node.next;
    }
}

=== Chunk 71 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0024.swap-nodes-in-pairs\SwapNodesInPairsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 72 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0024.swap-nodes-in-pairs\SwapNodesInPairsTest.java

public class SwapNodesInPairsTest {
    SwapNodesInPairs SwapNodesInPairs = new SwapNodesInPairs();

    @Test
    void Example1() {
        ListNode firstNode = new ListNode(1);
        ListNode secondNode = new ListNode(2);
        ListNode thirdNode = new ListNode(3);
        ListNode forthNode = new ListNode(4);

        firstNode.next = secondNode;
        secondNode.next = thirdNode;
        thirdNode.next = forthNode;

        ListNode results = SwapNodesInPairs.swapPairs(firstNode);

        secondNode.next = firstNode;
        firstNode.next = forthNode;
        forthNode.next = thirdNode;
        thirdNode.next = null;

        Assertions.assertEquals(secondNode, results);
    }

    @Test
    void Example2() {
        ListNode firstNode = null;

=== Chunk 73 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0024.swap-nodes-in-pairs\SwapNodesInPairsTest.java

ListNode firstNode = null;

        ListNode results = SwapNodesInPairs.swapPairs(firstNode);

        Assertions.assertNull(results);
    }

    @Test
    void Example3() {
        ListNode firstNode = new ListNode(1);

        ListNode results = SwapNodesInPairs.swapPairs(firstNode);

        Assertions.assertEquals(firstNode, results);
    }
}

=== Chunk 74 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0026.remove-duplicates-from-sorted-array\RemoveDuplicatesFromSortedArray.java

class RemoveDuplicatesFromSortedArray {
    public int removeDuplicates(int[] nums) {
        int insertIndex = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] != nums[i - 1]) {
                nums[insertIndex] = nums[i];
                insertIndex++;
            }
        }
        return insertIndex;
    }
}

=== Chunk 75 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0026.remove-duplicates-from-sorted-array\RemoveDuplicatesFromSortedArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 76 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0026.remove-duplicates-from-sorted-array\RemoveDuplicatesFromSortedArrayTest.java

public class RemoveDuplicatesFromSortedArrayTest {
    RemoveDuplicatesFromSortedArray RemoveDuplicatesFromSortedArray = new RemoveDuplicatesFromSortedArray();

    @Test
    void Example1() {
        int[] nums = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4};
        int[] expectedNums = {0, 1, 2, 3, 4, 0, 0, 0, 0, 0};

        int k = RemoveDuplicatesFromSortedArray.removeDuplicates(nums);
        for (int i = 0; i < k; i++) {
            Assertions.assertEquals(expectedNums[i], nums[i]);
        }
    }

    @Test
    void Example2() {
        int[] nums = {1, 1, 2};
        int results = RemoveDuplicatesFromSortedArray.removeDuplicates(nums);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 77 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0026.remove-duplicates-from-sorted-array\RemoveDuplicatesFromSortedArrayTest.java

}

    @Test
    void Example3() {
        int[] nums = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4};
        int results = RemoveDuplicatesFromSortedArray.removeDuplicates(nums);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 78 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0028.find-the-index-of-the-first-occurrence-in-a-string\FindTheIndexOfTheFirstOccurrenceInAString.java

class FindTheIndexOfTheFirstOccurrenceInAString {
    public int strStr(String haystack, String needle) {
        int n = haystack.length(), m = needle.length();
        if (m == 0)
            return 0;

        int[] pi = new int[m];
        for (int i = 1, j = 0; i < m; i++) {
            while (j > 0 && needle.charAt(i) != needle.charAt(j)) {
                j = pi[j - 1];
            }
            if (needle.charAt(i) == needle.charAt(j)) {
                j++;
            }
            pi[i] = j;
        }
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && haystack.charAt(i) != needle.charAt(j)) {
                j = pi[j - 1];
            }
            if (haystack.charAt(i) == needle.charAt(j)) {
                j++;
            }

=== Chunk 79 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0028.find-the-index-of-the-first-occurrence-in-a-string\FindTheIndexOfTheFirstOccurrenceInAString.java

j++;
            }
            if (j == m) {
                return i - m + 1;
            }
        }
        return -1;
    }
}

=== Chunk 80 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0028.find-the-index-of-the-first-occurrence-in-a-string\FindTheIndexOfTheFirstOccurrenceInAStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class FindTheIndexOfTheFirstOccurrenceInAStringTest {
    FindTheIndexOfTheFirstOccurrenceInAString findTheIndexOfTheFirstOccurrenceInAString = new FindTheIndexOfTheFirstOccurrenceInAString();

    @Test
    void Example1() {
        String haystack = "sadbutsad", needle = "sad";

        Assertions.assertEquals(0, findTheIndexOfTheFirstOccurrenceInAString.strStr(haystack, needle));
    }

    @Test
    void Example2() {
        String haystack = "leetcode", needle = "leeto";

        Assertions.assertEquals(-1, findTheIndexOfTheFirstOccurrenceInAString.strStr(haystack, needle));
    }
}

=== Chunk 81 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0030.substring-with-concatenation-of-all-words\SubstringWithConcatenationOfAllWords.java

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

=== Chunk 82 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0030.substring-with-concatenation-of-all-words\SubstringWithConcatenationOfAllWords.java

class SubstringWithConcatenationOfAllWords {
    private final HashMap<String, Integer> wordCount = new HashMap<>();
    private int wordLength, substringSize, k;

    private boolean check(int i, String s) {
        HashMap<String, Integer> remaining = new HashMap<>(wordCount);
        int wordsUsed = 0;

        for (int j = i; j < i + substringSize; j+= wordLength) {
            String sub = s.substring(j, j + wordLength);
            if (remaining.getOrDefault(sub, 0) != 0) {
                remaining.put(sub, remaining.get(sub) - 1);
                wordsUsed++;
            } else {
                break;
            }
        }

        return wordsUsed == k;
    }

    public List<Integer> findSubstring(String s, String[] words) {
        int n = s.length();

=== Chunk 83 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0030.substring-with-concatenation-of-all-words\SubstringWithConcatenationOfAllWords.java

int n = s.length();
        k = words.length;
        wordLength = words[0].length();
        substringSize = wordLength * k;

        for (String word : words) {
            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
        }

        List<Integer> answer = new ArrayList<>();
        for (int i = 0; i < n - substringSize + 1; i++) {
            if (check(i, s)) {
                answer.add(i);
            }
        }

        return answer;
    }
}

=== Chunk 84 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0030.substring-with-concatenation-of-all-words\SubstringWithConcatenationOfAllWordsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 85 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0030.substring-with-concatenation-of-all-words\SubstringWithConcatenationOfAllWordsTest.java

public class SubstringWithConcatenationOfAllWordsTest {
    SubstringWithConcatenationOfAllWords SubstringWithConcatenationOfAllWords = new SubstringWithConcatenationOfAllWords();

    @Test
    void Example1() {
        String s = "barfoothefoobarman";
        String[] words = {"foo", "bar"};
        List<Integer> results = SubstringWithConcatenationOfAllWords.findSubstring(s, words);
        List<Integer> expectedResults = Arrays.asList(0, 9);

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "wordgoodgoodgoodbestword";
        String[] words = {"word", "good", "best", "word"};
        List<Integer> results = SubstringWithConcatenationOfAllWords.findSubstring(s, words);

=== Chunk 86 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0030.substring-with-concatenation-of-all-words\SubstringWithConcatenationOfAllWordsTest.java

List<Integer> expectedResults = new ArrayList<>();

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "barfoofoobarthefoobarman";
        String[] words = {"bar", "foo", "the"};
        List<Integer> results = SubstringWithConcatenationOfAllWords.findSubstring(s, words);
        List<Integer> expectedResults = Arrays.asList(6, 9, 12);

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 87 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0033.search-in-rotated-sorted-array\SearchInRotatedSortedArray.java

class SearchInRotatedSortedArray {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            if (nums[mid] < nums[right]) {
                if (nums[mid] < target && nums[right] >= target) left = mid + 1;
                else right = mid - 1;
            } else {
                if (nums[left] <= target && nums[mid] > target) right = mid - 1;
                else left = mid + 1;
            }
        }
        return -1;
    }
}

=== Chunk 88 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0033.search-in-rotated-sorted-array\SearchInRotatedSortedArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 89 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0033.search-in-rotated-sorted-array\SearchInRotatedSortedArrayTest.java

public class SearchInRotatedSortedArrayTest {
    SearchInRotatedSortedArray SearchInRotatedSortedArray = new SearchInRotatedSortedArray();

    @Test
    void Example1() {
        int[] nums = {4, 5, 6, 7, 0, 1, 2};
        int target = 0;
        int results = SearchInRotatedSortedArray.search(nums, target);
        int expectedResult = 4;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        int[] nums = {4, 5, 6, 7, 0, 1, 2};
        int target = 3;
        int results = SearchInRotatedSortedArray.search(nums, target);
        int expectedResult = -1;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example3() {
        int[] nums = {1};
        int target = 0;

=== Chunk 90 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0033.search-in-rotated-sorted-array\SearchInRotatedSortedArrayTest.java

int target = 0;
        int results = SearchInRotatedSortedArray.search(nums, target);
        int expectedResult = -1;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 91 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0034.find-first-and-last-position-of-element-in-sorted-array\FindFirstAndLastPositionOfElementInSortedArray.java

class FindFirstAndLastPositionOfElementInSortedArray {
    private int findFirst(int[] nums, int target) {
        int l = 0, h = nums.length;
        while (l < h) {
            int m = l + (h - l) / 2;
            if (nums[m] >= target) {
                h = m;
            } else {
                l = m + 1;
            }
        }
        return l;
    }

    public int[] searchRange(int[] nums, int target) {
        int first = findFirst(nums, target);
        int last = findFirst(nums, target + 1) - 1;
        if (first == nums.length || nums[first] != target) {
            return new int[]{-1, -1};
        } else {
            return new int[]{first, Math.max(first, last)};
        }
    }
}

=== Chunk 92 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0034.find-first-and-last-position-of-element-in-sorted-array\FindFirstAndLastPositionOfElementInSortedArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 93 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0034.find-first-and-last-position-of-element-in-sorted-array\FindFirstAndLastPositionOfElementInSortedArrayTest.java

public class FindFirstAndLastPositionOfElementInSortedArrayTest {
    FindFirstAndLastPositionOfElementInSortedArray FindFirstAndLastPositionOfElementInSortedArray = new FindFirstAndLastPositionOfElementInSortedArray();

    @Test
    void Example1() {
        int[] nums = {5, 7, 7, 8, 8, 10};
        int target = 8;
        int[] results = FindFirstAndLastPositionOfElementInSortedArray.searchRange(nums, target);
        int[] expectedResults = {3, 4};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {5, 7, 7, 8, 8, 10};
        int target = 6;
        int[] results = FindFirstAndLastPositionOfElementInSortedArray.searchRange(nums, target);
        int[] expectedResults = {-1, -1};

=== Chunk 94 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0034.find-first-and-last-position-of-element-in-sorted-array\FindFirstAndLastPositionOfElementInSortedArrayTest.java

int[] expectedResults = {-1, -1};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {};
        int target = 0;
        int[] results = FindFirstAndLastPositionOfElementInSortedArray.searchRange(nums, target);
        int[] expectedResults = {-1, -1};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 95 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0035.search-insert-position\SearchInsertPosition.java

class SearchInsertPosition {
    public int searchInsert(int[] nums, int target) {
        int l = 0, h = nums.length;
        while (l < h) {
            int m = l + (h - l) / 2;
            if (nums[m] >= target) h = m;
            else l = m + 1;
        }
        return l;
    }
}

=== Chunk 96 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0035.search-insert-position\SearchInsertPositionTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 97 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0035.search-insert-position\SearchInsertPositionTest.java

public class SearchInsertPositionTest {
    SearchInsertPosition SearchInsertPosition = new SearchInsertPosition();

    @Test
    void Example1() {
        int[] nums = {1, 3, 5, 6};
        int target = 5;
        int results = SearchInsertPosition.searchInsert(nums, target);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 3, 5, 6};
        int target = 2;
        int results = SearchInsertPosition.searchInsert(nums, target);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {1, 3, 5, 6};
        int target = 7;

=== Chunk 98 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0035.search-insert-position\SearchInsertPositionTest.java

int target = 7;
        int results = SearchInsertPosition.searchInsert(nums, target);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        int[] nums = {1, 3, 5, 6};
        int target = 0;
        int results = SearchInsertPosition.searchInsert(nums, target);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 99 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0036.valid-sudoku\ValidSudoku.java

class ValidSudoku {
    public boolean isValidSudoku(char[][] board) {
        int[][] rows = new int[9][9];
        int[][] cols = new int[9][9];
        int[][][] subBoxes = new int[3][3][9];
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c != '.') {
                    int index = c - '0' - 1;
                    rows[i][index]++;
                    cols[j][index]++;
                    subBoxes[i / 3][j / 3][index]++;
                    if (rows[i][index] > 1 || cols[j][index] > 1 || subBoxes[i / 3][j / 3][index] > 1) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
}

=== Chunk 100 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0036.valid-sudoku\ValidSudokuTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 101 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0036.valid-sudoku\ValidSudokuTest.java

public class ValidSudokuTest {
    ValidSudoku ValidSudoku = new ValidSudoku();

    @Test
    void Example1() {
        char[][] board = {{'5', '3', '.', '.', '7', '.', '.', '.', '.'}, {'6', '.', '.', '1', '9', '5', '.', '.', '.'}, {'.', '9', '8', '.', '.', '.', '.', '6', '.'}, {'8', '.', '.', '.', '6', '.', '.', '.', '3'}, {'4', '.', '.', '8', '.', '3', '.', '.', '1'}, {'7', '.', '.', '.', '2', '.', '.', '.', '6'}, {'.', '6', '.', '.', '.', '.', '2', '8', '.'}, {'.', '.', '.', '4', '1', '9', '.', '.', '5'}, {'.', '.', '.', '.', '8', '.', '.', '7', '9'}};
        boolean results = ValidSudoku.isValidSudoku(board);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {

=== Chunk 102 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0036.valid-sudoku\ValidSudokuTest.java

}

    @Test
    void Example2() {
        char[][] board = {{'8', '3', '.', '.', '7', '.', '.', '.', '.'}, {'6', '.', '.', '1', '9', '5', '.', '.', '.'}, {'.', '9', '8', '.', '.', '.', '.', '6', '.'}, {'8', '.', '.', '.', '6', '.', '.', '.', '3'}, {'4', '.', '.', '8', '.', '3', '.', '.', '1'}, {'7', '.', '.', '.', '2', '.', '.', '.', '6'}, {'.', '6', '.', '.', '.', '.', '2', '8', '.'}, {'.', '.', '.', '4', '1', '9', '.', '.', '5'}, {'.', '.', '.', '.', '8', '.', '.', '7', '9'}};
        boolean results = ValidSudoku.isValidSudoku(board);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 103 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0038.count-and-say\CountAndSay.java

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 104 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0038.count-and-say\CountAndSay.java

class CountAndSay {
    private String freqToString(List<List<Integer>> freq) {
        StringBuilder s = new StringBuilder();
        for (List<Integer> ints : freq) {
            for (Integer integer : ints) {
                s.append(Character.getNumericValue(integer + 48));
            }
        }
        return s.toString();
    }

    private String countFrequency(int n, List<List<Integer>> freq) {
        String freqString = freqToString(freq);
        if (n == 1) return freqString;
        List<List<Integer>> newFreq = new ArrayList<>();
        int freqCount = 0;
        char prevChar = freqString.charAt(0);
        for (char c : freqString.toCharArray()) {
            if (prevChar != c) {
                newFreq.add(Arrays.asList(freqCount, prevChar - 48));

=== Chunk 105 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0038.count-and-say\CountAndSay.java

freqCount = 0;
                prevChar = c;
            }
            freqCount++;
        }
        newFreq.add(Arrays.asList(freqCount, prevChar - 48));
        n -= 1;
        return countFrequency(n, newFreq);
    }

    public String countAndSay(int n) {
        if (n <= 0) return "";
        if (n == 1) return "1";
        List<List<Integer>> frequency = new ArrayList<>();
        frequency.add(Arrays.asList(1, 1));
        return countFrequency(n - 1, frequency);
    }
}

=== Chunk 106 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0038.count-and-say\CountAndSayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class CountAndSayTest {
    CountAndSay CountAndSay = new CountAndSay();

    @Test
    void Example1() {
        int n = 1;
        String results = CountAndSay.countAndSay(n);
        String expectedResults = "1";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 4;
        String results = CountAndSay.countAndSay(n);
        String expectedResults = "1211";

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 107 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0039.combination-sum\CombinationSum.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 108 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0039.combination-sum\CombinationSum.java

class CombinationSum {
    private void dfs(int[] candidates, int target, List<List<Integer>> ans, List<Integer> combine, int idx) {
        if (candidates.length == idx)
            return;
        if (target == 0) {
            ans.add(new ArrayList<>(combine));
            return;
        }
        dfs(candidates, target, ans, combine, idx + 1);
        // choose current number
        if (target - candidates[idx] >= 0) {
            combine.add(candidates[idx]);
            dfs(candidates, target - candidates[idx], ans, combine, idx);
            combine.remove(combine.size() - 1);
        }
    }

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<>();

=== Chunk 109 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0039.combination-sum\CombinationSum.java

List<Integer> combine = new ArrayList<>();
        dfs(candidates, target, ans, combine, 0);
        return ans;
    }
}

=== Chunk 110 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0039.combination-sum\CombinationSumTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 111 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0039.combination-sum\CombinationSumTest.java

public class CombinationSumTest {
    CombinationSum CombinationSum = new CombinationSum();

    @Test
    void Example1() {
        int[] candidates = {2, 3, 6, 7};
        int target = 7;
        List<List<Integer>> results = CombinationSum.combinationSum(candidates, target);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(2, 2, 3));
        expectedResults.add(List.of(7));

        results.sort(new ListComparator<>());
        expectedResults.sort(new ListComparator<>());

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] candidates = {2, 3, 5};
        int target = 8;

=== Chunk 112 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0039.combination-sum\CombinationSumTest.java

int target = 8;
        List<List<Integer>> results = CombinationSum.combinationSum(candidates, target);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(2, 2, 2, 2));
        expectedResults.add(Arrays.asList(2, 3, 3));
        expectedResults.add(Arrays.asList(3, 5));

        results.sort(new ListComparator<>());
        expectedResults.sort(new ListComparator<>());

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] candidates = {2};
        int target = 1;
        List<List<Integer>> results = CombinationSum.combinationSum(candidates, target);
        List<List<Integer>> expectedResults = new ArrayList<>();

=== Chunk 113 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0039.combination-sum\CombinationSumTest.java

results.sort(new ListComparator<>());

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 114 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0040.combination-sum-ii\CombinationSumIi.java

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

=== Chunk 115 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0040.combination-sum-ii\CombinationSumIi.java

class CombinationSumIi {
    private void backtrack(LinkedList<Integer> comb, int remain, int curr, List<int[]> counter, List<List<Integer>> res) {
        if (remain <= 0) {
            if (remain == 0) res.add(new ArrayList<>(comb));
            return;
        }
        for (int nextCurr = curr; nextCurr < counter.size(); nextCurr++) {
            int[] entry = counter.get(nextCurr);
            int candidate = entry[0], freq = entry[1];
            if (freq <= 0) continue;
            comb.addLast(candidate);
            counter.set(nextCurr, new int[]{candidate, freq - 1});
            backtrack(comb, remain - candidate, nextCurr, counter, res);
            counter.set(nextCurr, new int[]{candidate, freq});
            comb.removeLast();
        }
    }

=== Chunk 116 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0040.combination-sum-ii\CombinationSumIi.java

}
    }

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        LinkedList<Integer> comb = new LinkedList<>();

        HashMap<Integer, Integer> counter = new HashMap<>();
        for (int num : candidates) {
            counter.put(num, counter.getOrDefault(num, 0) + 1);
        }

        List<int[]> counterList = new ArrayList<>();
        counter.forEach((key, value) -> counterList.add(new int[]{key, value}));
        backtrack(comb, target, 0, counterList, res);
        return res;
    }
}

=== Chunk 117 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0040.combination-sum-ii\CombinationSumIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 118 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0040.combination-sum-ii\CombinationSumIiTest.java

public class CombinationSumIiTest {
    CombinationSumIi CombinationSumIi = new CombinationSumIi();

    @Test
    void Example1() {
        int[] candidates = {10, 1, 2, 7, 6, 1, 5};
        int target = 8;
        List<List<Integer>> results = CombinationSumIi.combinationSum2(candidates, target);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(1, 1, 6));
        expectedResults.add(Arrays.asList(1, 2, 5));
        expectedResults.add(Arrays.asList(1, 7));
        expectedResults.add(Arrays.asList(2, 6));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] candidates = {2, 5, 2, 1, 2};
        int target = 5;

=== Chunk 119 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0040.combination-sum-ii\CombinationSumIiTest.java

int target = 5;
        List<List<Integer>> results = CombinationSumIi.combinationSum2(candidates, target);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(1, 2, 2));
        expectedResults.add(List.of(5));

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 120 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0042.trapping-rain-water\TrappingRainWater.java

class TrappingRainWater {
    public int trap(int[] height) {
        int left = 0, right = height.length - 1;
        int res = 0;
        int left_max = 0, right_max = 0;
        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] >= left_max) {
                    left_max = height[left];
                } else {
                    res += (left_max - height[left]);
                }
                left++;
            } else {
                if (height[right] >= right_max) {
                    right_max = height[right];
                } else {
                    res += (right_max - height[right]);
                }
                right--;
            }
        }
        return res;
    }
}

=== Chunk 121 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0042.trapping-rain-water\TrappingRainWaterTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class TrappingRainWaterTest {
    TrappingRainWater TrappingRainWater = new TrappingRainWater();

    @Test
    void Example1() {
        int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
        int results = TrappingRainWater.trap(height);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] height = {4, 2, 0, 3, 2, 5};
        int results = TrappingRainWater.trap(height);
        int expectedResults = 9;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 122 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0043.multiply-strings\MultiplyStrings.java

import java.util.ArrayList;

=== Chunk 123 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0043.multiply-strings\MultiplyStrings.java

class MultiplyStrings {
    private ArrayList<Integer> addStrings(ArrayList<Integer> num1, ArrayList<Integer> num2) {
        ArrayList<Integer> res = new ArrayList<>();
        int carry = 0;

        for (int i = 0; i < num1.size() || i < num2.size(); i++) {
            int digit1 = i < num1.size() ? num1.get(i) : 0;
            int digit2 = i < num2.size() ? num2.get(i) : 0;

            int sum = digit1 + digit2 + carry;
            carry = sum / 10;
            res.add(sum % 10);
        }

        if (carry != 0) {
            res.add(carry);
        }
        return res;
    }

    private ArrayList<Integer> multiplyOneDigit(StringBuilder firstNumber, char secondNumberDigit, int numZeros) {
        ArrayList<Integer> currentResult = new ArrayList<>();

=== Chunk 124 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0043.multiply-strings\MultiplyStrings.java

for (int i = 0; i < numZeros; i++) currentResult.add(0);

        int carry = 0;
        for (int i = 0; i < firstNumber.length(); i++) {
            char firstNumberDigit = firstNumber.charAt(i);
            int multiplication =  (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;
            carry = multiplication / 10;
            currentResult.add(multiplication % 10);
        }

        if (carry != 0) {
            currentResult.add(carry);
        }
        return currentResult;
    }

    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) return "0";

        StringBuilder firstNumber = new StringBuilder(num1);
        StringBuilder secondNumber = new StringBuilder(num2);

=== Chunk 125 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0043.multiply-strings\MultiplyStrings.java

firstNumber.reverse();
        secondNumber.reverse();

        int n = firstNumber.length() + secondNumber.length();
        ArrayList<Integer> res = new ArrayList<>();
        for (int i = 0; i < n; i++) res.add(0);

        for (int i = 0; i < secondNumber.length(); i++) {
            res = addStrings(multiplyOneDigit(firstNumber, secondNumber.charAt(i), i), res);
        }

        if (res.get(res.size() - 1) == 0) {
            res.remove(res.size() - 1);
        }

        StringBuilder result = new StringBuilder();
        for (int i = res.size() - 1; i >= 0; i--) {
            result.append(res.get(i));
        }

        return result.toString();
    }
}

=== Chunk 126 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0043.multiply-strings\MultiplyStringsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MultiplyStringsTest {
    MultiplyStrings MultiplyStrings = new MultiplyStrings();

    @Test
    void Example1() {
        String num1 = "2", num2 = "3";
        String results = MultiplyStrings.multiply(num1, num2);
        String expectedResults = "6";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String num1 = "123", num2 = "456";
        String results = MultiplyStrings.multiply(num1, num2);
        String expectedResults = "56088";

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 127 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0045.jump-game-ii\JumpGameIi.java

class JumpGameIi {
    public int jump(int[] nums) {
        int n = nums.length;
        int maxPosition = 0, end = 0, steps = 0;
        for (int i = 0; i < n - 1; i++) {
            maxPosition = Math.max(maxPosition, i + nums[i]);
            if (i == end) {
                end = maxPosition;
                steps++;
            }
        }
        return steps;
    }
}

=== Chunk 128 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0045.jump-game-ii\JumpGameIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class JumpGameIiTest {
    JumpGameIi jumpGameIi = new JumpGameIi();

    @Test
    void Example1() {
        int[] nums = {2, 3, 1, 1, 4};

        Assertions.assertEquals(2, jumpGameIi.jump(nums));
    }

    @Test
    void Example2() {
        int[] nums = {2, 3, 0, 1, 4};

        Assertions.assertEquals(2, jumpGameIi.jump(nums));
    }
}

=== Chunk 129 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0046.permutations\Permutations.java

import java.util.ArrayList;
import java.util.List;

class Permutations {
    private void backtrack(List<List<Integer>> lists, List<Integer> list, int[] nums) {
        if (list.size() == nums.length) {
            lists.add(new ArrayList<>(list));
        } else {
            for (int num : nums) {
                if (list.contains(num)) continue;
                list.add(num);
                backtrack(lists, list, nums);
                list.remove(list.size() - 1);
            }
        }
    }

    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        backtrack(res, new ArrayList<>(), nums);
        return res;
    }
}

=== Chunk 130 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0046.permutations\PermutationsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 131 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0046.permutations\PermutationsTest.java

public class PermutationsTest {
    Permutations Permutations = new Permutations();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3};
        List<List<Integer>> results = Permutations.permute(nums);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(1, 2, 3));
        expectedResults.add(Arrays.asList(1, 3, 2));
        expectedResults.add(Arrays.asList(2, 1, 3));
        expectedResults.add(Arrays.asList(2, 3, 1));
        expectedResults.add(Arrays.asList(3, 1, 2));
        expectedResults.add(Arrays.asList(3, 2, 1));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {0, 1};

=== Chunk 132 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0046.permutations\PermutationsTest.java

int[] nums = {0, 1};
        List<List<Integer>> results = Permutations.permute(nums);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(0, 1));
        expectedResults.add(Arrays.asList(1, 0));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {1};
        List<List<Integer>> results = Permutations.permute(nums);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(List.of(1));

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 133 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0047.permutations-ii\PermutationsIi.java

import java.util.*;

=== Chunk 134 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0047.permutations-ii\PermutationsIi.java

class PermutationsIi {
    private void backtrack(LinkedList<Integer> comb, int n, HashMap<Integer, Integer> counter, List<List<Integer>> res) {
        if (comb.size() == n) {
            res.add(new ArrayList<>(comb));
            return;
        }
        for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {
            int num = entry.getKey();
            int count = entry.getValue();
            if (count == 0) continue;
            comb.addLast(num);
            counter.put(num, count - 1);
            backtrack(comb, n, counter, res);
            comb.removeLast();
            counter.put(num, count);
        }
    }

    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();

=== Chunk 135 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0047.permutations-ii\PermutationsIi.java

HashMap<Integer, Integer> counter = new HashMap<>();
        for (int num : nums) {
            counter.put(num, counter.getOrDefault(num, 0) + 1);
        }

        LinkedList<Integer> comb = new LinkedList<>();
        this.backtrack(comb, nums.length, counter, res);
        return res;
    }
}

=== Chunk 136 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0047.permutations-ii\PermutationsIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 137 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0047.permutations-ii\PermutationsIiTest.java

public class PermutationsIiTest {
    PermutationsIi PermutationsIi = new PermutationsIi();

    @Test
    void Example1() {
        int[] nums = {1, 1, 2};
        List<List<Integer>> results = PermutationsIi.permuteUnique(nums);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(1, 1, 2));
        expectedResults.add(Arrays.asList(1, 2, 1));
        expectedResults.add(Arrays.asList(2, 1, 1));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 2, 3};
        List<List<Integer>> results = PermutationsIi.permuteUnique(nums);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(1, 2, 3));

=== Chunk 138 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0047.permutations-ii\PermutationsIiTest.java

expectedResults.add(Arrays.asList(1, 3, 2));
        expectedResults.add(Arrays.asList(2, 1, 3));
        expectedResults.add(Arrays.asList(2, 3, 1));
        expectedResults.add(Arrays.asList(3, 1, 2));
        expectedResults.add(Arrays.asList(3, 2, 1));

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 139 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0048.rotate-image\RotateImage.java

class RotateImage {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < (n + 1) / 2; i++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];
                matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];
                matrix[j][n - 1 -i] = matrix[i][j];
                matrix[i][j] = temp;
            }
        }
    }
}

=== Chunk 140 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0048.rotate-image\RotateImageTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class RotateImageTest {
    RotateImage RotateImage = new RotateImage();

    @Test
    void Example1() {
        int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        RotateImage.rotate(matrix);
        int[][] expectedResults = {{7, 4, 1}, {8, 5, 2}, {9, 6, 3}};

        Assertions.assertArrayEquals(expectedResults, matrix);
    }

    @Test
    void Example2() {
        int[][] matrix = {{5, 1, 9, 11}, {2, 4, 8, 10}, {13, 3, 6, 7}, {15, 14, 12, 16}};
        RotateImage.rotate(matrix);
        int[][] expectedResults = {{15, 13, 2, 5}, {14, 3, 4, 1}, {12, 6, 8, 9}, {16, 7, 10, 11}};

        Assertions.assertArrayEquals(expectedResults, matrix);
    }
}

=== Chunk 141 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0049.group-anagrams\GroupAnagrams.java

import java.util.*;

class GroupAnagrams {
    public List<List<String>> groupAnagrams(String[] strs) {
        if (strs == null || strs.length == 0) return new ArrayList<>();
        Map<String, List<String>> map = new HashMap<>();
        for (String s : strs) {
            char[] chars = s.toCharArray();
            Arrays.sort(chars);
            String keyString = String.valueOf(chars);
            if (!map.containsKey(keyString)) map.put(keyString, new ArrayList<>());
            map.get(keyString).add(s);
        }
        return new ArrayList<>(map.values());
    }
}

=== Chunk 142 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0049.group-anagrams\GroupAnagramsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 143 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0049.group-anagrams\GroupAnagramsTest.java

public class GroupAnagramsTest {
    GroupAnagrams GroupAnagrams = new GroupAnagrams();

    @Test
    void Example1() {
        String[] strs = {"eat", "tea", "tan", "ate", "nat", "bat"};
        List<List<String>> results = GroupAnagrams.groupAnagrams(strs);
        List<List<String>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList("eat", "tea", "ate"));
        expectedResults.add(List.of("bat"));
        expectedResults.add(Arrays.asList("tan", "nat"));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String[] strs = {""};
        List<List<String>> results = GroupAnagrams.groupAnagrams(strs);
        List<List<String>> expectedResults = new ArrayList<>();

=== Chunk 144 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0049.group-anagrams\GroupAnagramsTest.java

expectedResults.add(List.of(""));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String[] strs = {"a"};
        List<List<String>> results = GroupAnagrams.groupAnagrams(strs);
        List<List<String>> expectedResults = new ArrayList<>();
        expectedResults.add(List.of("a"));

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 145 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0053.maximum-subarray\MaximumSubarray.java

class MaximumSubarray {
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        int preSum = nums[0];
        int maxSum = preSum;
        for (int i = 1; i < nums.length; i++) {
            preSum = preSum > 0 ? preSum + nums[i] : nums[i];
            maxSum = Math.max(preSum, maxSum);
        }
        return maxSum;
    }
}

=== Chunk 146 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0053.maximum-subarray\MaximumSubarrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 147 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0053.maximum-subarray\MaximumSubarrayTest.java

public class MaximumSubarrayTest {
    MaximumSubarray MaximumSubarray = new MaximumSubarray();

    @Test
    void Example1() {
        int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        int results = MaximumSubarray.maxSubArray(nums);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1};
        int results = MaximumSubarray.maxSubArray(nums);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {5, 4, -1, 7, 8};
        int results = MaximumSubarray.maxSubArray(nums);
        int expectedResults = 23;

=== Chunk 148 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0053.maximum-subarray\MaximumSubarrayTest.java

int expectedResults = 23;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 149 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0054.spiral-matrix\SpiralMatrix.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 150 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0054.spiral-matrix\SpiralMatrix.java

class SpiralMatrix {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        if (matrix.length == 0) return res;

        int rowBegin = 0;
        int rowEnd = matrix.length - 1;
        int colBegin = 0;
        int colEnd = matrix[0].length - 1;

        while (rowBegin <= rowEnd && colBegin <= colEnd) {
            // right
            for (int j = colBegin; j <= colEnd; j++) {
                res.add(matrix[rowBegin][j]);
            }
            rowBegin++;

            // down
            for (int j = rowBegin; j <= rowEnd; j++) {
                res.add(matrix[j][colEnd]);
            }
            colEnd--;

            // left
            if (rowBegin <= rowEnd) {

=== Chunk 151 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0054.spiral-matrix\SpiralMatrix.java

if (rowBegin <= rowEnd) {
                for (int j = colEnd; j >= colBegin; j--) {
                    res.add(matrix[rowEnd][j]);
                }
            }
            rowEnd--;

            // top
            if (colBegin <= colEnd) {
                for (int j = rowEnd; j >= rowBegin; j--) {
                    res.add(matrix[j][colBegin]);
                }
            }
            colBegin++;
        }
        return res;
    }
}

=== Chunk 152 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0054.spiral-matrix\SpiralMatrixTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

=== Chunk 153 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0054.spiral-matrix\SpiralMatrixTest.java

public class SpiralMatrixTest {
    SpiralMatrix SpiralMatrix = new SpiralMatrix();

    @Test
    void Example1() {
        int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        List<Integer> results = SpiralMatrix.spiralOrder(matrix);
        List<Integer> expectedResults = Arrays.asList(1, 2, 3, 6, 9, 8, 7, 4, 5);

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] matrix = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
        List<Integer> results = SpiralMatrix.spiralOrder(matrix);
        List<Integer> expectedResults = Arrays.asList(1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7);

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 154 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0055.jump-game\JumpGame.java

class JumpGame {
    public boolean canJump(int[] nums) {
        int n = nums.length, rightMost = 0;
        for (int i = 0; i < n; i++) {
            if (i <= rightMost) {
                rightMost = Math.max(rightMost, i + nums[i]);
                if (rightMost >= n - 1) return true;
            }
        }
        return false;
    }
}

=== Chunk 155 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0055.jump-game\JumpGameTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class JumpGameTest {
    JumpGame jumpGame = new JumpGame();

    @Test
    void Example1() {
        int[] nums = {2, 3, 1, 1, 4};

        Assertions.assertTrue(jumpGame.canJump(nums));
    }

    @Test
    void Example2() {
        int[] nums = {3, 2, 1, 0, 4};

        Assertions.assertFalse(jumpGame.canJump(nums));
    }
}

=== Chunk 156 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0056.merge-intervals\MergeIntervals.java

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

=== Chunk 157 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0056.merge-intervals\MergeIntervals.java

class MergeIntervals {
    public int[][] merge(int[][] intervals) {
        if (intervals.length <= 1) return intervals;
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
        int start = intervals[0][0];
        int end = intervals[0][1];
        List<int[]> res = new ArrayList<>();
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] > end) {
                res.add(new int[]{start, end});
                start = intervals[i][0];
            }
            end = Math.max(end, intervals[i][1]);
            if (i == intervals.length - 1) {
                res.add(new int[]{start, end});
            }
        }
        return res.toArray(new int[0][]);
    }
}

=== Chunk 158 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0056.merge-intervals\MergeIntervalsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 159 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0056.merge-intervals\MergeIntervalsTest.java

public class MergeIntervalsTest {
    MergeIntervals MergeIntervals = new MergeIntervals();

    @Test
    void Example1() {
        int[][] intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};
        int[][] results = MergeIntervals.merge(intervals);
        int[][] expectedResults = {{1, 6}, {8, 10}, {15, 18}};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] intervals = {{1, 4}, {4, 5}};
        int[][] results = MergeIntervals.merge(intervals);
        int[][] expectedResults = {{1, 5}};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[][] intervals = {{1, 3}};
        int[][] results = MergeIntervals.merge(intervals);

=== Chunk 160 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0056.merge-intervals\MergeIntervalsTest.java

int[][] expectedResults = {{1, 3}};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        int[][] intervals = {{1, 4}, {0, 4}};
        int[][] results = MergeIntervals.merge(intervals);
        int[][] expectedResults = {{0, 4}};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example5() {
        int[][] intervals = {{1, 4}, {2, 3}};
        int[][] results = MergeIntervals.merge(intervals);
        int[][] expectedResults = {{1, 4}};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 161 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0057.insert-interval\InsertInterval.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 162 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0057.insert-interval\InsertInterval.java

class InsertInterval {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> ansList = new ArrayList<>();
        int i = 0;

        // add all the intervals before newInterval starts
        while (i < intervals.length && intervals[i][1] < newInterval[0]) {
            ansList.add(intervals[i]);
            i++;
        }

        // merge intervals with the insert interval
        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
            i++;
        }
        ansList.add(newInterval);

        // add the rest of intervals
        while (i < intervals.length) {

=== Chunk 163 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0057.insert-interval\InsertInterval.java

while (i < intervals.length) {
            ansList.add(intervals[i]);
            i++;
        }

        int[][] ans = new int[ansList.size()][2];
        for (int j = 0; j < ansList.size(); j++)
            ans[j] = ansList.get(j);

        return ans;
    }
}

=== Chunk 164 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0057.insert-interval\InsertIntervalTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 165 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0057.insert-interval\InsertIntervalTest.java

public class InsertIntervalTest {
    InsertInterval insertInterval = new InsertInterval();

    @Test
    void Example1() {
        int[][] intervals = {{1, 3}, {6, 9}};
        int[] newInterval = {2, 5};
        int[][] results = insertInterval.insert(intervals, newInterval);
        int[][] expectResults = {{1, 5}, {6, 9}};

        Assertions.assertArrayEquals(expectResults, results);
    }

    @Test
    void Example2() {
        int[][] intervals = {{1, 2}, {3, 5}, {6, 7}, {8, 10}, {12, 16}};
        int[] newInterval = {4, 8};
        int[][] results = insertInterval.insert(intervals, newInterval);
        int[][] expectResults = {{1, 2}, {3, 10}, {12, 16}};

        Assertions.assertArrayEquals(expectResults, results);
    }
}

=== Chunk 166 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0059.spiral-matrix-ii\SpiralMatrixIi.java

class SpiralMatrixIi {
    public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        int l = 0, r = n - 1, t = 0, b = n - 1;
        int num = 1, target = n * n;
        while (num <= target) {
            for (int i = l; i <= r; i++) {
                res[t][i] = num++;
            }
            t++;
            for (int i = t; i <= b; i++) {
                res[i][r] = num++;
            }
            r--;
            for (int i = r; i >= l; i--) {
                res[b][i] = num++;
            }
            b--;
            for (int i = b; i >= t; i--) {
                res[i][l] = num++;
            }
            l++;
        }
        return res;
    }
}

=== Chunk 167 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0059.spiral-matrix-ii\SpiralMatrixIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SpiralMatrixIiTest {
    SpiralMatrixIi spiralMatrixIi = new SpiralMatrixIi();

    @Test
    void Example1() {
        int n = 3;

        Assertions.assertArrayEquals(new int[][]{{1, 2, 3}, {8, 9, 4}, {7, 6, 5}}, spiralMatrixIi.generateMatrix(n));
    }

    @Test
    void Example2() {
        int n = 1;

        Assertions.assertArrayEquals(new int[][]{{1}}, spiralMatrixIi.generateMatrix(n));
    }
}

=== Chunk 168 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0062.unique-paths\UniquePaths.java

import java.util.Arrays;

class UniquePaths {
    public int uniquePaths(int m, int n) {
        int[][] cached = new int[m][n];
        for (int i = 0; i < m; i++) {
            cached[i][n - 1] = 1;
        }
        Arrays.fill(cached[m-1], 1);

        for (int i = m - 2; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                if (cached[i][j] == 0) {
                    cached[i][j] = cached[i + 1][j] + cached[i][j + 1];
                }
            }
        }

        return cached[0][0];
    }
}

=== Chunk 169 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0062.unique-paths\UniquePathsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class UniquePathsTest {
    UniquePaths UniquePaths = new UniquePaths();

    @Test
    void Example1() {
        int m = 3, n = 7;
        int result = UniquePaths.uniquePaths(m, n);
        int expectedResults = 28;

        Assertions.assertEquals(expectedResults, result);
    }

    @Test
    void Example2() {
        int m = 3, n = 2;
        int result = UniquePaths.uniquePaths(m , n);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, result);
    }
}

=== Chunk 170 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0067.add-binary\AddBinary.java

class AddBinary {
    public String addBinary(String a, String b) {
        StringBuilder res = new StringBuilder();
        int n = Math.max(a.length(), b.length()), carry = 0;
        for (int i = 0; i < n; i++) {
            carry += i < a.length() ? a.charAt(a.length() - 1 - i) - '0' : 0;
            carry += i < b.length() ? b.charAt(b.length() - 1 - i) - '0' : 0;
            res.append((char) (carry % 2 + '0'));
            carry /= 2;
        }
        if (carry > 0)
            res.append('1');

        return res.reverse().toString();
    }
}

=== Chunk 171 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0067.add-binary\AddBinaryTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class AddBinaryTest {
    AddBinary addBinary = new AddBinary();

    @Test
    void Example1() {
        String a = "11", b = "1";

        Assertions.assertEquals("100", addBinary.addBinary(a, b));
    }

    @Test
    void Example2() {
        String a = "1010", b = "1011";

        Assertions.assertEquals("10101", addBinary.addBinary(a, b));
    }
}

=== Chunk 172 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0069.sqrtx\Sqrtx.java

class Sqrtx {
    public int mySqrt(int x) {
        if (x <= 1) {
            return x;
        }
        int l = 1, h = x;
        while (l <= h) {
            int mid = l + (h - l) / 2;
            int sqrt = x / mid;
            if (sqrt == mid) {
                return mid;
            } else if (mid > sqrt) {
                h = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return h;
    }
}

=== Chunk 173 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0069.sqrtx\SqrtxTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SqrtxTest {
    Sqrtx Sqrtx = new Sqrtx();

    @Test
    void Example1() {
        int x = 4;
        int results = Sqrtx.mySqrt(x);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int x = 8;
        int results = Sqrtx.mySqrt(x);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 174 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0070.climbing-stairs\ClimbingStairs.java

class ClimbingStairs {
    public int climbStairs(int n) {
        if (n == 1) return 1;
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++)
            dp[i] = dp[i - 1] + dp[i - 2];
        return dp[n];
    }
}

=== Chunk 175 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0070.climbing-stairs\ClimbingStairs2.java

class ClimbingStairs2 {
    public int climbStairs(int n) {
        int p, q = 0, r = 1;
        for (int i = 1; i <= n; i++) {
            p = q;
            q = r;
            r = p + q;
        }
        return r;
    }
}

=== Chunk 176 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0070.climbing-stairs\ClimbingStairs3.java

class ClimbingStairs3 {
    public int climbStairs(int n) {
        int[][] q = {{1, 1}, {1, 0}};
        int[][] res = pow(q, n);
        return res[0][0];
    }

    private int[][] pow(int[][] a, int n) {
        int[][] ret = {{1, 0}, {0, 1}};
        while (n > 0) {
            if ((n & 1) == 1) {
                ret = multiply(ret, a);
            }
            n >>= 1;
            a = multiply(a, a);
        }
        return ret;
    }

    private int[][] multiply(int[][] a, int[][] b) {
        int[][] c = new int[2][2];
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];
            }
        }
        return c;
    }
}

=== Chunk 177 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0070.climbing-stairs\ClimbingStairs4.java

class ClimbingStairs4 {
    public int climbStairs(int n) {
        double sqrt5 = Math.sqrt(5);
        double fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);
        return (int) Math.round(fibn / sqrt5);
    }
}

=== Chunk 178 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0070.climbing-stairs\ClimbingStairsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 179 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0070.climbing-stairs\ClimbingStairsTest.java

public class ClimbingStairsTest {
    ClimbingStairs climbingStairs = new ClimbingStairs();
    ClimbingStairs2 climbingStairs2 = new ClimbingStairs2();
    ClimbingStairs3 climbingStairs3 = new ClimbingStairs3();
    ClimbingStairs4 climbingStairs4 = new ClimbingStairs4();

    @Test
    void Example1() {
        int n = 2;

        Assertions.assertEquals(2, climbingStairs.climbStairs(n));
        Assertions.assertEquals(2, climbingStairs2.climbStairs(n));
        Assertions.assertEquals(2, climbingStairs3.climbStairs(n));
        Assertions.assertEquals(2, climbingStairs4.climbStairs(n));
    }

    @Test
    void Example2() {
        int n = 3;

        Assertions.assertEquals(3, climbingStairs.climbStairs(n));

=== Chunk 180 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0070.climbing-stairs\ClimbingStairsTest.java

Assertions.assertEquals(3, climbingStairs2.climbStairs(n));
        Assertions.assertEquals(3, climbingStairs3.climbStairs(n));
        Assertions.assertEquals(3, climbingStairs4.climbStairs(n));
    }
}

=== Chunk 181 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0071.simplify-path\SimplifyPath.java

import java.util.Stack;

class SimplifyPath {
    public String simplifyPath(String path) {
        Stack<String> stack = new Stack<>();
        String[] pathArray = path.split("/");

        for (String s : pathArray) {
            if (s.equals("..")) {
                if (!stack.isEmpty()) {
                    stack.pop();
                }
            } else if (s.length() != 0 && !s.equals(".")) {
                stack.push(s);
            }
        }

        StringBuilder res = new StringBuilder();
        while (!stack.isEmpty()) {
            res.insert(0, "/" + stack.pop());
        }

        return res.toString().length() > 0 ? res.toString() : "/";
    }
}

=== Chunk 182 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0071.simplify-path\SimplifyPathTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SimplifyPathTest {
    SimplifyPath simplifyPath = new SimplifyPath();

    @Test
    void Example1() {
        String path = "/home/";

        Assertions.assertEquals("/home", simplifyPath.simplifyPath(path));
    }

    @Test
    void Example2() {
        String path = "/../";

        Assertions.assertEquals("/", simplifyPath.simplifyPath(path));
    }

    @Test
    void Example3() {
        String path = "/home//foo/";

        Assertions.assertEquals("/home/foo", simplifyPath.simplifyPath(path));
    }

    @Test
    void Example4() {
        String path = "/a/./b/../../c/";

        Assertions.assertEquals("/c", simplifyPath.simplifyPath(path));
    }
}

=== Chunk 183 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0074.search-a-2d-matrix\SearchA2dMatrix.java

class SearchA2dMatrix {
    public boolean searchMatrix(int[][] matrix, int target) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int i = 0, j = 0;
        while (i < rows || j < cols) {
            if (matrix[i][j] == target) return true;
            if (i != rows - 1 && target >= matrix[i + 1][j]) {
                i++;
            } else if (j != cols - 1 && target >= matrix[i][j + 1]) {
                j++;
            } else {
                break;
            }
        }
        return false;
    }
}

=== Chunk 184 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0074.search-a-2d-matrix\SearchA2dMatrixTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 185 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0074.search-a-2d-matrix\SearchA2dMatrixTest.java

public class SearchA2dMatrixTest {
    SearchA2dMatrix SearchA2dMatrix = new SearchA2dMatrix();

    @Test
    void Example1() {
        int[][] matrix = {{1, 3, 5, 7}, {10, 11, 16, 20}, {23, 30, 34, 60}};
        int target = 3;
        boolean results = SearchA2dMatrix.searchMatrix(matrix, target);
        boolean expectedResult = true;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        int[][] matrix = {{1, 3, 5, 7}, {10, 11, 16, 20}, {23, 30, 34, 60}};
        int target = 21;
        boolean results = SearchA2dMatrix.searchMatrix(matrix, target);
        boolean expectedResult = false;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example3() {

=== Chunk 186 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0074.search-a-2d-matrix\SearchA2dMatrixTest.java

}

    @Test
    void Example3() {
        int[][] matrix = {{1}};
        int target = 0;
        boolean results = SearchA2dMatrix.searchMatrix(matrix, target);
        boolean expectedResult = false;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example4() {
        int[][] matrix = {{1, 3}};
        int target = 3;
        boolean results = SearchA2dMatrix.searchMatrix(matrix, target);
        boolean expectedResult = true;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 187 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0075.sort-colors\SortColors.java

class SortColors {
    private void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    public void sortColors(int[] nums) {
        int zero = -1, one = 0, two = nums.length;
        while (one < two) {
            if (nums[one] == 0) {
                swap(nums, ++zero, one++);
            } else if (nums[one] == 2) {
                swap(nums, --two, one);
            } else {
                ++one;
            }
        }
    }
}

=== Chunk 188 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0075.sort-colors\SortColorsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SortColorsTest {
    SortColors SortColors = new SortColors();

    @Test
    void Example1() {
        int[] nums = {2, 0, 2, 1, 1, 0};
        SortColors.sortColors(nums);
        int[] expectedResults = {0, 0, 1, 1, 2, 2};

        Assertions.assertArrayEquals(expectedResults, nums);
    }

    @Test
    void Example2() {
        int[] nums = {2, 0, 1};
        SortColors.sortColors(nums);
        int[] expectedResults = {0, 1, 2};

        Assertions.assertArrayEquals(expectedResults, nums);
    }
}

=== Chunk 189 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0076.minimum-window-substring\MinimumWindowSubstring.java

import java.util.HashMap;
import java.util.Map;

=== Chunk 190 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0076.minimum-window-substring\MinimumWindowSubstring.java

class MinimumWindowSubstring {
    public String minWindow(String s, String t) {
        if (s.length() == 0 || t.length() == 0) return "";
        Map<Character, Integer> dict = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            int count = dict.getOrDefault(t.charAt(i), 0);
            dict.put(t.charAt(i), count + 1);
        }

        int required = dict.size();
        int l = 0, r = 0;
        int formed = 0;

        Map<Character, Integer> windowCounts = new HashMap<>();
        int[] ans = {-1, 0, 0};
        while (r < s.length()) {
            char c = s.charAt(r);
            int count = windowCounts.getOrDefault(c, 0);
            windowCounts.put(c, count + 1);

=== Chunk 191 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0076.minimum-window-substring\MinimumWindowSubstring.java

windowCounts.put(c, count + 1);

            if (dict.containsKey(c) && windowCounts.get(c).intValue() == dict.get(c).intValue()) formed++;

            while (l <= r && formed == required) {
                c = s.charAt(l);
                if (ans[0] == -1 || r - l + 1 < ans[0]) {
                    ans[0] = r - l + 1;
                    ans[1] = l;
                    ans[2] = r;
                }

                windowCounts.put(c, windowCounts.get(c) - 1);
                if (dict.containsKey(c) && windowCounts.get(c) < dict.get(c)) formed--;
                l++;
            }
            r++;
        }
        return ans[0] == -1 ? "" : s.substring(ans[1], ans[2] + 1);
    }
}

=== Chunk 192 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0076.minimum-window-substring\MinimumWindowSubstringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 193 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0076.minimum-window-substring\MinimumWindowSubstringTest.java

public class MinimumWindowSubstringTest {
    MinimumWindowSubstring MinimumWindowSubstring = new MinimumWindowSubstring();

    @Test
    void Example1() {
        String s = "ADOBECODEBANC", t = "ABC";
        String results = MinimumWindowSubstring.minWindow(s, t);
        String expectedResults = "BANC";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "a", t = "a";
        String results = MinimumWindowSubstring.minWindow(s, t);
        String expectedResults = "a";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "a", t = "aa";
        String results = MinimumWindowSubstring.minWindow(s, t);

=== Chunk 194 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0076.minimum-window-substring\MinimumWindowSubstringTest.java

String expectedResults = "";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        String s = "ab", t = "b";
        String results = MinimumWindowSubstring.minWindow(s, t);
        String expectedResults = "b";

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 195 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0077.combinations\Combinations.java

import java.util.ArrayList;
import java.util.List;

class Combinations {
    private void combine(List<List<Integer>> combines, List<Integer> combine, int start, int n, int k) {
        if (k == 0) {
            combines.add(new ArrayList<>(combine));
            return;
        }
        for (int i = start; i <= n; i++) {
            combine.add(i);
            combine(combines, combine, i + 1, n, k - 1);
            combine.remove(combine.size() - 1);
        }
    }

    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        combine(res, new ArrayList<>(), 1, n, k);
        return res;
    }
}

=== Chunk 196 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0077.combinations\CombinationsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 197 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0077.combinations\CombinationsTest.java

public class CombinationsTest {
    Combinations Combinations = new Combinations();

    @Test
    void Example1() {
        int n = 4, k = 2;
        List<List<Integer>> results = Combinations.combine(n ,k);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(1, 2));
        expectedResults.add(Arrays.asList(1, 3));
        expectedResults.add(Arrays.asList(1, 4));
        expectedResults.add(Arrays.asList(2, 3));
        expectedResults.add(Arrays.asList(2, 4));
        expectedResults.add(Arrays.asList(3, 4));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 1, k = 1;
        List<List<Integer>> results = Combinations.combine(n ,k);

=== Chunk 198 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0077.combinations\CombinationsTest.java

List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(List.of(1));

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 199 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0078.subsets\Subsets.java

import java.util.ArrayList;
import java.util.List;

class Subsets {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        res.add(new ArrayList<>());

        for (int num : nums) {
            List<List<Integer>> newSubsets = new ArrayList<>();
            for (List<Integer> curr : res) {
                newSubsets.add(new ArrayList<>(curr){{add(num);}});
            }
            res.addAll(newSubsets);
        }
        return res;
    }
}

=== Chunk 200 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0078.subsets\Subsets2.java

import java.util.ArrayList;
import java.util.List;

class Subsets2 {
    List<List<Integer>> res = new ArrayList<>();
    int n, k;

    private void backtrack(int first, ArrayList<Integer> curr, int[] nums) {
        if (curr.size() == k) {
            res.add(new ArrayList<>(curr));
            return;
        }
        for (int i = first; i < n; i++) {
            curr.add(nums[i]);
            backtrack(i + 1, curr, nums);
            curr.remove(curr.size() - 1);
        }
    }

    public List<List<Integer>> subsets(int[] nums) {
        n = nums.length;
        for (k = 0; k < n + 1; k++) {
            backtrack(0, new ArrayList<>(), nums);
        }
        return res;
    }
}

=== Chunk 201 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0078.subsets\SubsetsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 202 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0078.subsets\SubsetsTest.java

public class SubsetsTest {
    Subsets Subsets = new Subsets();
    Subsets2 Subsets2 = new Subsets2();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3};
        List<List<Integer>> results = Subsets.subsets(nums);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(new ArrayList<>());
        expectedResults.add(List.of(1));
        expectedResults.add(List.of(2));
        expectedResults.add(Arrays.asList(1, 2));
        expectedResults.add(List.of(3));
        expectedResults.add(Arrays.asList(1, 3));
        expectedResults.add(Arrays.asList(2, 3));
        expectedResults.add(Arrays.asList(1, 2, 3));

        Assertions.assertEquals(expectedResults, results);

        results = Subsets2.subsets(nums);

=== Chunk 203 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0078.subsets\SubsetsTest.java

results = Subsets2.subsets(nums);
        List<List<Integer>> expectedResults2 = new ArrayList<>();
        expectedResults2.add(new ArrayList<>());
        expectedResults2.add(List.of(1));
        expectedResults2.add(List.of(2));
        expectedResults2.add(List.of(3));
        expectedResults2.add(Arrays.asList(1, 2));
        expectedResults2.add(Arrays.asList(1, 3));
        expectedResults2.add(Arrays.asList(2, 3));
        expectedResults2.add(Arrays.asList(1, 2, 3));

        Assertions.assertEquals(expectedResults2, results);
    }

    @Test
    void Example2() {
        int[] nums = {0};
        List<List<Integer>> results = Subsets.subsets(nums);
        List<List<Integer>> expectedResults = new ArrayList<>();

=== Chunk 204 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0078.subsets\SubsetsTest.java

expectedResults.add(new ArrayList<>());
        expectedResults.add(List.of(0));

        Assertions.assertEquals(expectedResults, results);

        results = Subsets2.subsets(nums);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 205 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0079.word-search\WordSearch.java

class WordSearch {
    private boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) {
        if (board[i][j] != s.charAt(k)) {
            return false;
        } else if (k == s.length() - 1) {
            return true;
        }
        visited[i][j] = true;
        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        boolean result = false;
        for (int[] dir : directions) {
            int newI = i + dir[0], newJ = j + dir[1];
            if (newI >= 0 && newI < board.length && newJ >= 0 && newJ < board[0].length) {
                if (!visited[newI][newJ]) {
                    boolean flag = check(board, visited, newI, newJ, s, k + 1);
                    if (flag) {
                        result = true;

=== Chunk 206 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0079.word-search\WordSearch.java

result = true;
                        break;
                    }
                }
            }
        }
        visited[i][j] = false;
        return result;
    }

    public boolean exist(char[][] board, String word) {
        int row = board.length, col = board[0].length;
        boolean[][] visited = new boolean[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                boolean flag = check(board, visited, i, j, word, 0);
                if (flag) return true;
            }
        }
        return false;
    }
}

=== Chunk 207 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0079.word-search\WordSearchTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 208 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0079.word-search\WordSearchTest.java

public class WordSearchTest {
    WordSearch wordSearch = new WordSearch();

    @Test
    void Example1() {
        char[][] board = {{'A', 'B', 'C', 'E'}, {'S', 'F', 'C', 'S'}, {'A', 'D', 'E', 'E'}};
        String word = "ABCCED";
        boolean results = wordSearch.exist(board, word);

        Assertions.assertTrue(results);
    }

    @Test
    void Example2() {
        char[][] board = {{'A', 'B', 'C', 'E'}, {'S', 'F', 'C', 'S'}, {'A', 'D', 'E', 'E'}};
        String word = "SEE";
        boolean results = wordSearch.exist(board, word);

        Assertions.assertTrue(results);
    }

    @Test
    void Example3() {
        char[][] board = {{'A', 'B', 'C', 'E'}, {'S', 'F', 'C', 'S'}, {'A', 'D', 'E', 'E'}};
        String word = "ABCB";

=== Chunk 209 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0079.word-search\WordSearchTest.java

String word = "ABCB";
        boolean results = wordSearch.exist(board, word);

        Assertions.assertFalse(results);
    }
}

=== Chunk 210 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0082.remove-duplicates-from-sorted-list-ii\RemoveDuplicatesFromSortedListIi.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

=== Chunk 211 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0082.remove-duplicates-from-sorted-list-ii\RemoveDuplicatesFromSortedListIi.java

class RemoveDuplicatesFromSortedListIi {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode sentinel = new ListNode(0, head);
        ListNode pred = sentinel;

        while (head != null) {
            if (head.next != null && head.val == head.next.val) {
                while (head.next != null && head.val == head.next.val) {
                    head = head.next;
                }
                pred.next = head.next;
            } else {
                pred = pred.next;
            }

            head = head.next;
        }
        return sentinel.next;
    }
}

=== Chunk 212 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0082.remove-duplicates-from-sorted-list-ii\RemoveDuplicatesFromSortedListIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 213 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0082.remove-duplicates-from-sorted-list-ii\RemoveDuplicatesFromSortedListIiTest.java

public class RemoveDuplicatesFromSortedListIiTest {
    RemoveDuplicatesFromSortedListIi RemoveDuplicatesFromSortedListIi = new RemoveDuplicatesFromSortedListIi();

    @Test
    void Example1() {
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(3);
        head.next.next.next.next = new ListNode(4);
        head.next.next.next.next.next = new ListNode(4);
        head.next.next.next.next.next.next = new ListNode(5);

        ListNode results = RemoveDuplicatesFromSortedListIi.deleteDuplicates(head);

        Assertions.assertEquals(1, results.val);
        Assertions.assertEquals(2, results.next.val);

=== Chunk 214 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0082.remove-duplicates-from-sorted-list-ii\RemoveDuplicatesFromSortedListIiTest.java

Assertions.assertEquals(5, results.next.next.val);
    }

    @Test
    void Example2() {
        ListNode head = new ListNode(1);
        head.next = new ListNode(1);
        head.next.next = new ListNode(1);
        head.next.next.next = new ListNode(2);
        head.next.next.next.next = new ListNode(3);

        ListNode results = RemoveDuplicatesFromSortedListIi.deleteDuplicates(head);

        Assertions.assertEquals(2, results.val);
        Assertions.assertEquals(3, results.next.val);
    }
}

=== Chunk 215 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0083.remove-duplicates-from-sorted-list\RemoveDuplicatesFromSortedList.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class RemoveDuplicatesFromSortedList {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) return head;
        head.next = deleteDuplicates(head.next);
        return head.val == head.next.val ? head.next : head;
    }
}

=== Chunk 216 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0083.remove-duplicates-from-sorted-list\RemoveDuplicatesFromSortedListTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 217 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0083.remove-duplicates-from-sorted-list\RemoveDuplicatesFromSortedListTest.java

public class RemoveDuplicatesFromSortedListTest {
    RemoveDuplicatesFromSortedList RemoveDuplicatesFromSortedList = new RemoveDuplicatesFromSortedList();

    @Test
    void Example1() {
        ListNode firstNode = new ListNode(1);
        ListNode secondNode = new ListNode(1);
        ListNode thirdNode = new ListNode(2);

        firstNode.next = secondNode;
        secondNode.next = thirdNode;

        ListNode results = RemoveDuplicatesFromSortedList.deleteDuplicates(firstNode);

        secondNode.next = thirdNode;

        Assertions.assertEquals(secondNode, results);
    }

    @Test
    void Example2() {
        ListNode firstNode = new ListNode(1);
        ListNode secondNode = new ListNode(1);
        ListNode thirdNode = new ListNode(2);

=== Chunk 218 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0083.remove-duplicates-from-sorted-list\RemoveDuplicatesFromSortedListTest.java

ListNode thirdNode = new ListNode(2);
        ListNode forthNode = new ListNode(3);
        ListNode fifthNode = new ListNode(3);

        firstNode.next = secondNode;
        secondNode.next = thirdNode;
        thirdNode.next = forthNode;
        forthNode.next = fifthNode;

        ListNode results = RemoveDuplicatesFromSortedList.deleteDuplicates(firstNode);

        secondNode.next = thirdNode;
        thirdNode.next = fifthNode;

        Assertions.assertEquals(secondNode, results);
    }
}

=== Chunk 219 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0086.partition-list\PartitionList.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

=== Chunk 220 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0086.partition-list\PartitionList.java

class PartitionList {
    public ListNode partition(ListNode head, int x) {
        ListNode lessStart = new ListNode(0);
        ListNode greaterStart = new ListNode(0);
        ListNode lessEnd = lessStart;
        ListNode greaterEnd = greaterStart;
        while (head != null) {
            if (head.val < x) {
                lessEnd.next = head;
                lessEnd = lessEnd.next;
            } else {
                greaterEnd.next = head;
                greaterEnd = greaterEnd.next;
            }
            head = head.next;
        }
        greaterEnd.next = null;
        lessEnd.next = greaterStart.next;
        return lessStart.next;
    }
}

=== Chunk 221 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0086.partition-list\PartitionListTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 222 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0086.partition-list\PartitionListTest.java

public class PartitionListTest {
    PartitionList PartitionList = new PartitionList();

    @Test
    void Example1() {
        int x = 3;
        ListNode head = new ListNode(1);
        head.next = new ListNode(4);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(2);
        head.next.next.next.next = new ListNode(5);
        head.next.next.next.next.next = new ListNode(2);
        ListNode result = PartitionList.partition(head, x);

        Assertions.assertEquals(1, result.val);
        Assertions.assertEquals(2, result.next.val);
        Assertions.assertEquals(2, result.next.next.val);
        Assertions.assertEquals(4, result.next.next.next.val);
        Assertions.assertEquals(3, result.next.next.next.next.val);

=== Chunk 223 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0086.partition-list\PartitionListTest.java

Assertions.assertEquals(5, result.next.next.next.next.next.val);
    }

    @Test
    void Example2() {
        int x = 2;
        ListNode head = new ListNode(2);
        head.next = new ListNode(1);
        ListNode result = PartitionList.partition(head, x);

        Assertions.assertEquals(1, result.val);
        Assertions.assertEquals(2, result.next.val);
    }
}

=== Chunk 224 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0087.scramble-string\ScrambleString.java

class ScrambleString {
    public boolean isScramble(String s1, String s2) {
        char[] ch1 = s1.toCharArray();
        char[] ch2 = s2.toCharArray();
        int n = s1.length();
        int m = s2.length();
        if (n != m) {
            return false;
        }

        boolean[][][] dp = new boolean[n][n][n + 1];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j][1] = ch1[i] == ch2[j];
            }
        }

        for (int len = 2; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                for (int j = 0; j <= n - len; j++) {
                    for (int k = 1; k <= len - 1; k++) {
                        if (dp[i][j][k] && dp[i + k][j + k][len - k]) {

=== Chunk 225 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0087.scramble-string\ScrambleString.java

dp[i][j][len] = true;
                            break;
                        }
                        if (dp[i][j + len - k][k] && dp[i + k][j][len - k]) {
                            dp[i][j][len] = true;
                            break;
                        }
                    }
                }
            }
        }
        return dp[0][0][n];
    }
}

=== Chunk 226 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0087.scramble-string\ScrambleStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ScrambleStringTest {
    ScrambleString scrambleString = new ScrambleString();

    @Test
    void Example1() {
        String s1 = "great", s2 = "rgeat";

        Assertions.assertTrue(scrambleString.isScramble(s1, s2));
    }

    @Test
    void Example2() {
        String s1 = "abcde", s2 = "caebd";

        Assertions.assertFalse(scrambleString.isScramble(s1, s2));
    }

    @Test
    void Example3() {
        String s1 = "a", s2 = "a";

        Assertions.assertTrue(scrambleString.isScramble(s1, s2));
    }
}

=== Chunk 227 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0088.merge-sorted-array\MergeSortedArray.java

class MergeSortedArray {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index1 = m - 1, index2 = n - 1, mergedIndex = m + n -1;
        while (index2 >= 0) {
            if (index1 < 0) {
                nums1[mergedIndex--] = nums2[index2--];
            } else if (nums1[index1] > nums2[index2]) {
                nums1[mergedIndex--] = nums1[index1--];
            } else {
                nums1[mergedIndex--] = nums2[index2--];
            }
        }
    }
}

=== Chunk 228 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0088.merge-sorted-array\MergeSortedArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 229 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0088.merge-sorted-array\MergeSortedArrayTest.java

public class MergeSortedArrayTest {
    MergeSortedArray MergeSortedArray = new MergeSortedArray();

    @Test
    void Example1() {
        int[] nums1 = {1, 2, 3, 0, 0, 0};
        int m = 3;
        int[] nums2 = {2, 5, 6};
        int n = 3;
        int [] expectedResults = {1, 2, 2, 3, 5, 6};

        MergeSortedArray.merge(nums1, m, nums2, n);
        Assertions.assertArrayEquals(expectedResults, nums1);
    }

    @Test
    void Example2() {
        int[] nums1 = {1};
        int m = 1;
        int[] nums2 = {};
        int n = 0;
        int [] expectedResults = {1};

        MergeSortedArray.merge(nums1, m, nums2, n);
        Assertions.assertArrayEquals(expectedResults, nums1);
    }

    @Test
    void Example3() {
        int[] nums1 = {0};

=== Chunk 230 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0088.merge-sorted-array\MergeSortedArrayTest.java

int[] nums1 = {0};
        int m = 0;
        int[] nums2 = {1};
        int n = 1;
        int [] expectedResults = {1};

        MergeSortedArray.merge(nums1, m, nums2, n);
        Assertions.assertArrayEquals(expectedResults, nums1);
    }
}

=== Chunk 231 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0090.subsets-ii\SubsetsIi.java

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class SubsetsIi {
    List<List<Integer>> res = new ArrayList<>();
    int n, k;

    private void backtrack(int first, List<Integer> curr, int[] nums) {
        if (curr.size() == k && !res.contains(curr)) {
            res.add(new ArrayList<>(curr));
        }
        for (int i = first; i < n; i++) {
            curr.add(nums[i]);
            backtrack(i + 1, curr, nums);
            curr.remove(curr.size() - 1);
        }
    }

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        n = nums.length;
        for (k = 0; k < n + 1; k++) {
            backtrack(0, new ArrayList<>(), nums);
        }
        return res;
    }
}

=== Chunk 232 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0090.subsets-ii\SubsetsIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 233 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0090.subsets-ii\SubsetsIiTest.java

public class SubsetsIiTest {
    SubsetsIi SubsetsIi = new SubsetsIi();

    @Test
    void Example1() {
        int[] nums = {1, 2, 2};
        List<List<Integer>> results = SubsetsIi.subsetsWithDup(nums);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(new ArrayList<>());
        expectedResults.add(List.of(1));
        expectedResults.add(List.of(2));
        expectedResults.add(Arrays.asList(1, 2));
        expectedResults.add(Arrays.asList(2, 2));
        expectedResults.add(Arrays.asList(1, 2, 2));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {0};
        List<List<Integer>> results = SubsetsIi.subsetsWithDup(nums);

=== Chunk 234 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0090.subsets-ii\SubsetsIiTest.java

List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(new ArrayList<>());
        expectedResults.add(List.of(0));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {4, 4, 4, 1, 4};
        List<List<Integer>> results = SubsetsIi.subsetsWithDup(nums);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(new ArrayList<>());
        expectedResults.add(List.of(1));
        expectedResults.add(List.of(4));
        expectedResults.add(Arrays.asList(1, 4));
        expectedResults.add(Arrays.asList(4, 4));
        expectedResults.add(Arrays.asList(1, 4, 4));
        expectedResults.add(Arrays.asList(4, 4, 4));

=== Chunk 235 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0090.subsets-ii\SubsetsIiTest.java

expectedResults.add(Arrays.asList(1, 4, 4, 4));
        expectedResults.add(Arrays.asList(4, 4, 4, 4));
        expectedResults.add(Arrays.asList(1, 4, 4, 4, 4));

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 236 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0091.decode-ways\DecodeWays.java

class DecodeWays {
    public int numDecodings(String s) {
        if (s == null || s.length() == 0) return 0;
        int n = s.length();
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = s.charAt(0) != '0' ? 1 : 0;
        for (int i = 2; i <= n; i++) {
            int first = Integer.parseInt(s.substring(i - 1, i));
            int second = Integer.parseInt(s.substring(i - 2, i));
            if (first >= 1 && first <= 9) dp[i] += dp[i - 1];
            if (second >= 10 && second <= 26) dp[i] += dp[i - 2];
        }
        return dp[n];
    }
}

=== Chunk 237 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0091.decode-ways\DecodeWaysTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 238 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0091.decode-ways\DecodeWaysTest.java

public class DecodeWaysTest {
    DecodeWays DecodeWays = new DecodeWays();

    @Test
    void Example1() {
        String s = "12";
        int results = DecodeWays.numDecodings(s);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "226";
        int results = DecodeWays.numDecodings(s);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "06";
        int results = DecodeWays.numDecodings(s);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        String s = "10";

=== Chunk 239 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0091.decode-ways\DecodeWaysTest.java

void Example4() {
        String s = "10";
        int results = DecodeWays.numDecodings(s);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 240 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0092.reverse-linked-list-ii\ReverseLinkedListIi.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

=== Chunk 241 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0092.reverse-linked-list-ii\ReverseLinkedListIi.java

class ReverseLinkedListIi {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(0);
        ListNode leftPrev = dummy;
        leftPrev.next = head;
        ListNode cur = head;
        for (int i = 1; i < left; i++) {
            leftPrev = leftPrev.next;
            cur = cur.next;
        }

        ListNode prev = null;
        for (int i = left; i <= right; i++) {
            ListNode temp = cur.next;
            cur.next = prev;
            prev = cur;
            cur = temp;
        }

        leftPrev.next.next = cur;
        leftPrev.next = prev;

        return dummy.next;
    }
}

=== Chunk 242 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0092.reverse-linked-list-ii\ReverseLinkedListIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 243 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0092.reverse-linked-list-ii\ReverseLinkedListIiTest.java

public class ReverseLinkedListIiTest {
    ReverseLinkedListIi ReverseLinkedListIi = new ReverseLinkedListIi();

    @Test
    void Example1() {
        int left = 2, right = 4;
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);
        ListNode result = ReverseLinkedListIi.reverseBetween(head, left, right);

        Assertions.assertEquals(1, result.val);
        Assertions.assertEquals(4, result.next.val);
        Assertions.assertEquals(3, result.next.next.val);
        Assertions.assertEquals(2, result.next.next.next.val);
        Assertions.assertEquals(5, result.next.next.next.next.val);
    }

=== Chunk 244 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0092.reverse-linked-list-ii\ReverseLinkedListIiTest.java

}

    @Test
    void Example2() {
        int left = 1, right = 1;
        ListNode head = new ListNode(5);
        ListNode result = ReverseLinkedListIi.reverseBetween(head, left, right);

        Assertions.assertEquals(5, result.val);
    }
}

=== Chunk 245 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0093.restore-ip-addresses\RestoreIpAddresses.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 246 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0093.restore-ip-addresses\RestoreIpAddresses.java

class RestoreIpAddresses {
    static final int segCount = 4;
    List<String> ans = new ArrayList<>();
    int[] segments = new int[segCount];

    public List<String> restoreIpAddresses(String s) {
        segments = new int[segCount];
        dfs(s, 0, 0);
        return ans;
    }

    private void dfs(String s, int segId, int segStart) {
        if (segId == segCount) {
            if (segStart == s.length()) {
                StringBuilder ipAddr = new StringBuilder();
                for (int i = 0; i < segCount; i++) {
                    ipAddr.append(segments[i]);
                    if (i != segCount - 1)
                        ipAddr.append('.');
                }
                ans.add(ipAddr.toString());
            }
            return;
        }

=== Chunk 247 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0093.restore-ip-addresses\RestoreIpAddresses.java

}
            return;
        }
        if (segStart == s.length())
            return;
        if (s.charAt(segStart) == '0') {
            segments[segId] = 0;
            dfs(s, segId + 1, segStart + 1);
        }
        int addr = 0;
        for (int segEnd = segStart; segEnd < s.length(); segEnd++) {
            addr = addr * 10 + (s.charAt(segEnd) - '0');
            if (addr > 0 && addr <= 0xFF) {
                segments[segId] = addr;
                dfs(s, segId + 1, segEnd + 1);
            } else {
                break;
            }
        }
    }
}

=== Chunk 248 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0093.restore-ip-addresses\RestoreIpAddressesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

=== Chunk 249 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0093.restore-ip-addresses\RestoreIpAddressesTest.java

public class RestoreIpAddressesTest {
    RestoreIpAddresses restoreIpAddresses = new RestoreIpAddresses();

    @Test
    void Example1() {
        String s = "25525511135";

        List<String> expectedResults = new ArrayList<>();
        expectedResults.add("255.255.11.135");
        expectedResults.add("255.255.111.35");
        Assertions.assertEquals(expectedResults, restoreIpAddresses.restoreIpAddresses(s));
    }

    @Test
    void Example2() {
        String s = "0000";

        List<String> expectedResults = new ArrayList<>();
        expectedResults.add("0.0.0.0");
        Assertions.assertEquals(expectedResults, restoreIpAddresses.restoreIpAddresses(s));
    }

    @Test
    void Example3() {
        String s = "101023";

=== Chunk 250 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0093.restore-ip-addresses\RestoreIpAddressesTest.java

String s = "101023";

        List<String> expectedResults = new ArrayList<>();
        expectedResults.add("1.0.10.23");
        expectedResults.add("1.0.102.3");
        expectedResults.add("10.1.0.23");
        expectedResults.add("10.10.2.3");
        expectedResults.add("101.0.2.3");
        Assertions.assertEquals(expectedResults, restoreIpAddresses.restoreIpAddresses(s));
    }
}

=== Chunk 251 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0094.binary-tree-inorder-traversal\BinaryTreeInorderTraversal.java

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 252 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0094.binary-tree-inorder-traversal\BinaryTreeInorderTraversal.java

class BinaryTreeInorderTraversal {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ret = new ArrayList<>();
        if (root == null) return ret;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            TreeNode node = stack.pop();
            ret.add(node.val);
            cur = node.right;
        }
        return ret;
    }
}

=== Chunk 253 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0094.binary-tree-inorder-traversal\BinaryTreeInorderTraversalTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

=== Chunk 254 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0094.binary-tree-inorder-traversal\BinaryTreeInorderTraversalTest.java

public class BinaryTreeInorderTraversalTest {
    BinaryTreeInorderTraversal BinaryTreeInorderTraversal = new BinaryTreeInorderTraversal();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(3);

        firstNode.right = secondNode;
        secondNode.left = thirdNode;

        List<Integer> results = BinaryTreeInorderTraversal.inorderTraversal(firstNode);
        List<Integer> expectedResult = new ArrayList<>();
        expectedResult.add(1);
        expectedResult.add(3);
        expectedResult.add(2);

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {

=== Chunk 255 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0094.binary-tree-inorder-traversal\BinaryTreeInorderTraversalTest.java

}

    @Test
    void Example2() {
        List<Integer> results = BinaryTreeInorderTraversal.inorderTraversal(null);
        List<Integer> expectedResult = new ArrayList<>();

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example3() {
        TreeNode firstNode = new TreeNode(1);

        List<Integer> results = BinaryTreeInorderTraversal.inorderTraversal(firstNode);
        List<Integer> expectedResult = new ArrayList<>();
        expectedResult.add(1);

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 256 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0095.unique-binary-search-trees-ii\UniqueBinarySearchTreesIi.java

import java.util.LinkedList;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 257 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0095.unique-binary-search-trees-ii\UniqueBinarySearchTreesIi.java

class UniqueBinarySearchTreesIi {
    private List<TreeNode> generateTrees(int s, int e) {
        List<TreeNode> res = new LinkedList<>();
        if (s > e) {
            res.add(null);
            return res;
        }
        for (int i = s; i <= e; i++) {
            List<TreeNode> leftSubtrees = generateTrees(s, i - 1);
            List<TreeNode> rightSubtrees = generateTrees(i + 1, e);
            for (TreeNode left : leftSubtrees) {
                for (TreeNode right : rightSubtrees) {
                    TreeNode root = new TreeNode(i);
                    root.left = left;
                    root.right = right;
                    res.add(root);
                }
            }
        }
        return res;
    }

=== Chunk 258 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0095.unique-binary-search-trees-ii\UniqueBinarySearchTreesIi.java

}
        return res;
    }

    public List<TreeNode> generateTrees(int n) {
        if (n < 1) return new LinkedList<>();
        return generateTrees(1, n);
    }
}

=== Chunk 259 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0095.unique-binary-search-trees-ii\UniqueBinarySearchTreesIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

=== Chunk 260 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0095.unique-binary-search-trees-ii\UniqueBinarySearchTreesIiTest.java

public class UniqueBinarySearchTreesIiTest {
    UniqueBinarySearchTreesIi UniqueBinarySearchTreesIi = new UniqueBinarySearchTreesIi();

    @Test
    void Example1() {
        int n = 3;
        List<TreeNode> results = UniqueBinarySearchTreesIi.generateTrees(n);

        Assertions.assertEquals(1, results.get(0).val);
        Assertions.assertEquals(2, results.get(0).right.val);
        Assertions.assertEquals(3, results.get(0).right.right.val);

        Assertions.assertEquals(1, results.get(1).val);
        Assertions.assertEquals(3, results.get(1).right.val);
        Assertions.assertEquals(2, results.get(1).right.left.val);

        Assertions.assertEquals(2, results.get(2).val);
        Assertions.assertEquals(1, results.get(2).left.val);

=== Chunk 261 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0095.unique-binary-search-trees-ii\UniqueBinarySearchTreesIiTest.java

Assertions.assertEquals(3, results.get(2).right.val);

        Assertions.assertEquals(3, results.get(3).val);
        Assertions.assertEquals(1, results.get(3).left.val);
        Assertions.assertEquals(2, results.get(3).left.right.val);

        Assertions.assertEquals(3, results.get(4).val);
        Assertions.assertEquals(2, results.get(4).left.val);
        Assertions.assertEquals(1, results.get(4).left.left.val);
    }

    @Test
    void Example2() {
        int n = 1;
        List<TreeNode> results = UniqueBinarySearchTreesIi.generateTrees(n);

        TreeNode firstRoot = new TreeNode(1);

        List<TreeNode> expectedResults = List.of(firstRoot);

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 262 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0097.interleaving-string\InterleavingString.java

class InterleavingString {
    public boolean isInterleave(String s1, String s2, String s3) {
        int l1 = s1.length();
        int l2 = s2.length();
        int l3 = s3.length();
        if (l1 + l2 != l3) return false;

        boolean[][] dp = new boolean[l2 + 1][l1 + 1];
        dp[0][0] = true;

        for (int j = 1; j < dp[0].length; j++) {
            dp[0][j] = dp[0][j - 1] && (s1.charAt(j -1) == s3.charAt(j - 1));
        }

        for (int i = 1; i < dp.length; i++) {
            dp[i][0] = dp[i - 1][0] && (s2.charAt(i - 1) == s3.charAt(i - 1));
        }

        for (int i = 1; i < dp.length; i++) {
            for (int j = 1; j < dp[0].length; j++) {

=== Chunk 263 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0097.interleaving-string\InterleavingString.java

dp[i][j] = (dp[i - 1][j] && (s2.charAt(i - 1) == s3.charAt(i + j - 1))) || (dp[i][j - 1] && (s1.charAt(j - 1) == s3.charAt(i + j -1)));
            }
        }

        return dp[l2][l1];
    }
}

=== Chunk 264 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0097.interleaving-string\InterleavingStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 265 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0097.interleaving-string\InterleavingStringTest.java

public class InterleavingStringTest {
    InterleavingString InterleavingString = new InterleavingString();

    @Test
    void Example1() {
        String s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac";
        boolean results = InterleavingString.isInterleave(s1, s2, s3);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc";
        boolean results = InterleavingString.isInterleave(s1, s2, s3);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s1 = "", s2 = "", s3 = "";

=== Chunk 266 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0097.interleaving-string\InterleavingStringTest.java

String s1 = "", s2 = "", s3 = "";
        boolean results = InterleavingString.isInterleave(s1, s2, s3);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 267 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0098.validate-binary-search-tree\ValidateBinarySearchTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 268 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0098.validate-binary-search-tree\ValidateBinarySearchTree.java

class ValidateBinarySearchTree {
    private boolean isValidBST(TreeNode root, long min, long max) {
        if (root == null) return true;
        if (root.val >= max || root.val <= min) return false;

        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);
    }

    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
}

=== Chunk 269 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0098.validate-binary-search-tree\ValidateBinarySearchTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 270 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0098.validate-binary-search-tree\ValidateBinarySearchTreeTest.java

public class ValidateBinarySearchTreeTest {
    ValidateBinarySearchTree ValidateBinarySearchTree = new ValidateBinarySearchTree();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(2);
        root.left = new TreeNode(1);
        root.right = new TreeNode(3);
        boolean results = ValidateBinarySearchTree.isValidBST(root);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(5);
        root.left = new TreeNode(1);
        root.right = new TreeNode(4);
        root.right.left = new TreeNode(3);
        root.right.right = new TreeNode(6);
        boolean results = ValidateBinarySearchTree.isValidBST(root);

=== Chunk 271 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0098.validate-binary-search-tree\ValidateBinarySearchTreeTest.java

boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        TreeNode root = new TreeNode(2);
        root.left = new TreeNode(2);
        root.right = new TreeNode(2);
        boolean results = ValidateBinarySearchTree.isValidBST(root);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        TreeNode root = new TreeNode(5);
        root.left = new TreeNode(4);
        root.right = new TreeNode(6);
        root.right.left = new TreeNode(3);
        root.right.right = new TreeNode(7);
        boolean results = ValidateBinarySearchTree.isValidBST(root);

=== Chunk 272 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0098.validate-binary-search-tree\ValidateBinarySearchTreeTest.java

boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example5() {
        TreeNode root = new TreeNode(2147483647);
        boolean results = ValidateBinarySearchTree.isValidBST(root);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 273 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0100.same-tree\SameTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class SameTree {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if ((p != null && q == null) || (p == null && q != null)) return false;
        if (p == null) return true;
        if (p.val == q.val) {
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }
        return false;
    }
}

=== Chunk 274 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0100.same-tree\SameTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 275 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0100.same-tree\SameTreeTest.java

public class SameTreeTest {
    SameTree SameTree = new SameTree();

    @Test
    void Example1() {
        TreeNode p = new TreeNode(1);
        p.left = new TreeNode(2);
        p.right = new TreeNode(3);
        TreeNode q = new TreeNode(1);
        q.left = new TreeNode(2);
        q.right = new TreeNode(3);
        boolean results = SameTree.isSameTree(p, q);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        TreeNode p = new TreeNode(1);
        p.left = new TreeNode(2);
        TreeNode q = new TreeNode(1);
        q.right = new TreeNode(2);
        boolean results = SameTree.isSameTree(p, q);
        boolean expectedResults = false;

=== Chunk 276 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0100.same-tree\SameTreeTest.java

boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        TreeNode p = new TreeNode(1);
        p.left = new TreeNode(2);
        p.right = new TreeNode(1);
        TreeNode q = new TreeNode(1);
        q.left = new TreeNode(1);
        q.right = new TreeNode(2);
        boolean results = SameTree.isSameTree(p, q);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 277 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0101.symmetric-tree\SymmetricTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 278 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0101.symmetric-tree\SymmetricTree.java

class SymmetricTree {
    private boolean isSymmetric(TreeNode t1, TreeNode t2) {
        if (t1 == null && t2 == null) return true;
        if (t1 == null || t2 == null || t1.val != t2.val) return false;
        return isSymmetric(t1.left, t2.right) && isSymmetric(t1.right, t2.left);
    }

    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return isSymmetric(root.left, root.right);
    }
}

=== Chunk 279 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0101.symmetric-tree\SymmetricTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 280 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0101.symmetric-tree\SymmetricTreeTest.java

public class SymmetricTreeTest {
    SymmetricTree SymmetricTree = new SymmetricTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(2);
        TreeNode forthNode = new TreeNode(3);
        TreeNode fifthNode = new TreeNode(4);
        TreeNode sixthNode = new TreeNode(4);
        TreeNode seventhNode = new TreeNode(3);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        thirdNode.left = sixthNode;
        thirdNode.right = seventhNode;

        boolean results = SymmetricTree.isSymmetric(firstNode);
        boolean expectedResult = true;

=== Chunk 281 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0101.symmetric-tree\SymmetricTreeTest.java

boolean expectedResult = true;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(2);
        TreeNode forthNode = new TreeNode(3);
        TreeNode fifthNode = new TreeNode(3);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.right = forthNode;
        thirdNode.right = fifthNode;

        boolean results = SymmetricTree.isSymmetric(firstNode);
        boolean expectedResult = false;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 282 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0102.binary-tree-level-order-traversal\BinaryTreeLevelOrderTraversal.java

import java.util.ArrayList;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 283 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0102.binary-tree-level-order-traversal\BinaryTreeLevelOrderTraversal.java

class BinaryTreeLevelOrderTraversal {
    List<List<Integer>> ans = new ArrayList<>();

    private void levelOrder(TreeNode root, int level) {
        if (root == null) return;
        if (ans.size() <= level) ans.add(new ArrayList<>());
        ans.get(level).add(root.val);
        levelOrder(root.left, level + 1);
        levelOrder(root.right, level + 1);
    }

    public List<List<Integer>> levelOrder(TreeNode root) {
        levelOrder(root, 0);
        return ans;
    }
}

=== Chunk 284 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0102.binary-tree-level-order-traversal\BinaryTreeLevelOrderTraversalTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

=== Chunk 285 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0102.binary-tree-level-order-traversal\BinaryTreeLevelOrderTraversalTest.java

public class BinaryTreeLevelOrderTraversalTest {
    BinaryTreeLevelOrderTraversal BinaryTreeLevelOrderTraversal = new BinaryTreeLevelOrderTraversal();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(9);
        root.right = new TreeNode(20);
        root.right.left = new TreeNode(15);
        root.right.right = new TreeNode(7);

        List<List<Integer>> results = BinaryTreeLevelOrderTraversal.levelOrder(root);
        List<List<Integer>> expectedResult = new ArrayList<>();
        List<Integer> first = new ArrayList<>();
        List<Integer> second = new ArrayList<>();
        List<Integer> third = new ArrayList<>();
        first.add(3);
        second.add(9);
        second.add(20);

=== Chunk 286 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0102.binary-tree-level-order-traversal\BinaryTreeLevelOrderTraversalTest.java

second.add(9);
        second.add(20);
        third.add(15);
        third.add(7);
        expectedResult.add(first);
        expectedResult.add(second);
        expectedResult.add(third);
        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(1);

        List<List<Integer>> results = BinaryTreeLevelOrderTraversal.levelOrder(root);
        List<List<Integer>> expectedResult = new ArrayList<>();
        List<Integer> first = new ArrayList<>();
        first.add(1);
        expectedResult.add(first);
        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example3() {
        TreeNode root = null;

=== Chunk 287 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0102.binary-tree-level-order-traversal\BinaryTreeLevelOrderTraversalTest.java

TreeNode root = null;

        List<List<Integer>> results = BinaryTreeLevelOrderTraversal.levelOrder(root);
        List<List<Integer>> expectedResult = new ArrayList<>();
        List<Integer> first = new ArrayList<>();
        expectedResult.add(first);
        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 288 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0103.binary-tree-zigzag-level-order-traversal\BinaryTreeZigzagLevelOrderTraversal.java

import java.util.*;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 289 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0103.binary-tree-zigzag-level-order-traversal\BinaryTreeZigzagLevelOrderTraversal.java

class BinaryTreeZigzagLevelOrderTraversal {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) return res;
        Queue<TreeNode> nodeQueue = new ArrayDeque<>();
        nodeQueue.offer(root);
        boolean isOrderLeft = true;

        while (!nodeQueue.isEmpty()) {
            Deque<Integer> levelList = new LinkedList<>();
            int size = nodeQueue.size();
            for (int i = 0; i < size; i++) {
                TreeNode currNode = nodeQueue.poll();
                if (isOrderLeft)
                    levelList.offerLast(currNode.val);
                else
                    levelList.offerFirst(currNode.val);
                if (currNode.left != null)

=== Chunk 290 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0103.binary-tree-zigzag-level-order-traversal\BinaryTreeZigzagLevelOrderTraversal.java

if (currNode.left != null)
                    nodeQueue.offer(currNode.left);
                if (currNode.right != null)
                    nodeQueue.offer(currNode.right);
            }
            res.add(new LinkedList<>(levelList));
            isOrderLeft = !isOrderLeft;
        }

        return res;
    }
}

=== Chunk 291 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0103.binary-tree-zigzag-level-order-traversal\BinaryTreeZigzagLevelOrderTraversalTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 292 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0103.binary-tree-zigzag-level-order-traversal\BinaryTreeZigzagLevelOrderTraversalTest.java

public class BinaryTreeZigzagLevelOrderTraversalTest {
    BinaryTreeZigzagLevelOrderTraversal binaryTreeZigzagLevelOrderTraversal = new BinaryTreeZigzagLevelOrderTraversal();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(9);
        root.right = new TreeNode(20);
        root.right.left = new TreeNode(15);
        root.right.right = new TreeNode(7);

        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(List.of(3));
        expectedResults.add(Arrays.asList(20, 9));
        expectedResults.add(Arrays.asList(15, 7));

        Assertions.assertEquals(expectedResults, binaryTreeZigzagLevelOrderTraversal.zigzagLevelOrder(root));
    }

    @Test
    void Example2() {

=== Chunk 293 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0103.binary-tree-zigzag-level-order-traversal\BinaryTreeZigzagLevelOrderTraversalTest.java

}

    @Test
    void Example2() {
        TreeNode root = new TreeNode(1);

        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(List.of(1));

        Assertions.assertEquals(expectedResults, binaryTreeZigzagLevelOrderTraversal.zigzagLevelOrder(root));
    }

    @Test
    void Example3() {
        List<List<Integer>> expectedResults = new ArrayList<>();

        Assertions.assertEquals(expectedResults, binaryTreeZigzagLevelOrderTraversal.zigzagLevelOrder(null));
    }
}

=== Chunk 294 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0104.maximum-depth-of-binary-tree\MaximumDepthOfBinaryTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class MaximumDepthOfBinaryTree {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}

=== Chunk 295 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0104.maximum-depth-of-binary-tree\MaximumDepthOfBinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 296 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0104.maximum-depth-of-binary-tree\MaximumDepthOfBinaryTreeTest.java

public class MaximumDepthOfBinaryTreeTest {
    MaximumDepthOfBinaryTree MaximumDepthOfBinaryTree = new MaximumDepthOfBinaryTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(9);
        TreeNode thirdNode = new TreeNode(20);
        TreeNode forthNode = new TreeNode(15);
        TreeNode fifthNode = new TreeNode(7);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        thirdNode.left = forthNode;
        thirdNode.right = fifthNode;

        int expectedResult = 3;
        int results = MaximumDepthOfBinaryTree.maxDepth(firstNode);

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {

=== Chunk 297 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0104.maximum-depth-of-binary-tree\MaximumDepthOfBinaryTreeTest.java

}

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(1);
        firstNode.right = new TreeNode(2);

        int expectedResult = 2;
        int results = MaximumDepthOfBinaryTree.maxDepth(firstNode);

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 298 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0105.construct-binary-tree-from-preorder-and-inorder-traversal\ConstructBinaryTreeFromPreorderAndInorderTraversal.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 299 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0105.construct-binary-tree-from-preorder-and-inorder-traversal\ConstructBinaryTreeFromPreorderAndInorderTraversal.java

class ConstructBinaryTreeFromPreorderAndInorderTraversal {
    private TreeNode buildTreeHelper(int[] preorder, int[] inorder, int preStart, int inStart, int inEnd) {
        if (preStart > preorder.length - 1 || inStart > inEnd) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[preStart]);
        int mid = 0;
        for (int i = inStart; i <= inEnd; i++) {
            if (inorder[i] == preorder[preStart]) {
                mid = i;
                break;
            }
        }
        root.left = buildTreeHelper(preorder, inorder, preStart + 1, inStart, mid - 1);
        root.right = buildTreeHelper(preorder, inorder, preStart + mid - inStart + 1, mid + 1, inEnd);
        return root;
    }

=== Chunk 300 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0105.construct-binary-tree-from-preorder-and-inorder-traversal\ConstructBinaryTreeFromPreorderAndInorderTraversal.java

return root;
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return buildTreeHelper(preorder, inorder, 0, 0, inorder.length - 1);
    }
}

=== Chunk 301 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0105.construct-binary-tree-from-preorder-and-inorder-traversal\ConstructBinaryTreeFromPreorderAndInorderTraversalTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 302 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0105.construct-binary-tree-from-preorder-and-inorder-traversal\ConstructBinaryTreeFromPreorderAndInorderTraversalTest.java

public class ConstructBinaryTreeFromPreorderAndInorderTraversalTest {
    ConstructBinaryTreeFromPreorderAndInorderTraversal ConstructBinaryTreeFromPreorderAndInorderTraversal = new ConstructBinaryTreeFromPreorderAndInorderTraversal();

    @Test
    void Example1() {
        int[] preorder = {3, 9, 20, 15, 7};
        int[] inorder = {9, 3, 15, 20, 7};

        TreeNode results = ConstructBinaryTreeFromPreorderAndInorderTraversal.buildTree(preorder, inorder);
        Assertions.assertEquals(3, results.val);
        Assertions.assertEquals(9, results.left.val);
        Assertions.assertEquals(20, results.right.val);
        Assertions.assertEquals(15, results.right.left.val);
        Assertions.assertEquals(7, results.right.right.val);
    }

    @Test

=== Chunk 303 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0105.construct-binary-tree-from-preorder-and-inorder-traversal\ConstructBinaryTreeFromPreorderAndInorderTraversalTest.java

}

    @Test
    void Example2() {
        int[] preorder = {-1};
        int[] inorder = {-1};

        TreeNode results = ConstructBinaryTreeFromPreorderAndInorderTraversal.buildTree(preorder, inorder);
        Assertions.assertEquals(-1, results.val);
    }
}

=== Chunk 304 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0106.construct-binary-tree-from-inorder-and-postorder-traversal\ConstructBinaryTreeFromInorderAndPostorderTraversal.java

import java.util.HashMap;
import java.util.Map;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 305 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0106.construct-binary-tree-from-inorder-and-postorder-traversal\ConstructBinaryTreeFromInorderAndPostorderTraversal.java

class ConstructBinaryTreeFromInorderAndPostorderTraversal {
    int postIndex;
    int[] postorder;
    int[] inorder;
    Map<Integer, Integer> indexMap = new HashMap<>();

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.inorder = inorder;
        this.postorder = postorder;
        postIndex = postorder.length - 1;

        int index = 0;
        for (Integer val : inorder) {
            indexMap.put(val, index++);
        }

        return helper(0, inorder.length - 1);
    }

    private TreeNode helper(int leftIndex, int rightIndex) {
        if (leftIndex > rightIndex) {
            return null;
        }

        int rootVal = postorder[postIndex];
        TreeNode root = new TreeNode(rootVal);

=== Chunk 306 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0106.construct-binary-tree-from-inorder-and-postorder-traversal\ConstructBinaryTreeFromInorderAndPostorderTraversal.java

TreeNode root = new TreeNode(rootVal);
        int index = indexMap.get(rootVal);

        postIndex--;
        root.right = helper(index + 1, rightIndex);
        root.left = helper(leftIndex, index - 1);
        return root;
    }
}

=== Chunk 307 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0106.construct-binary-tree-from-inorder-and-postorder-traversal\ConstructBinaryTreeFromInorderAndPostorderTraversalTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 308 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0106.construct-binary-tree-from-inorder-and-postorder-traversal\ConstructBinaryTreeFromInorderAndPostorderTraversalTest.java

public class ConstructBinaryTreeFromInorderAndPostorderTraversalTest {
    ConstructBinaryTreeFromInorderAndPostorderTraversal constructBinaryTreeFromInorderAndPostorderTraversal = new ConstructBinaryTreeFromInorderAndPostorderTraversal();

    @Test
    void Example1() {
        int[] inorder = {9, 3, 15, 20, 7},  postorder = {9, 15, 7, 20, 3};
        TreeNode root = constructBinaryTreeFromInorderAndPostorderTraversal.buildTree(inorder, postorder);

        Assertions.assertEquals(3, root.val);
        Assertions.assertEquals(9, root.left.val);
        Assertions.assertEquals(20, root.right.val);
        Assertions.assertEquals(15, root.right.left.val);
        Assertions.assertEquals(7, root.right.right.val);
    }

    @Test
    void Example2() {

=== Chunk 309 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0106.construct-binary-tree-from-inorder-and-postorder-traversal\ConstructBinaryTreeFromInorderAndPostorderTraversalTest.java

}

    @Test
    void Example2() {
        int[] inorder = {-1}, postorder = {-1};
        TreeNode root = constructBinaryTreeFromInorderAndPostorderTraversal.buildTree(inorder, postorder);

        Assertions.assertEquals(-1, root.val);
    }
}

=== Chunk 310 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0108.convert-sorted-array-to-binary-search-tree\ConvertSortedArrayToBinarySearchTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 311 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0108.convert-sorted-array-to-binary-search-tree\ConvertSortedArrayToBinarySearchTree.java

class ConvertSortedArrayToBinarySearchTree {
    private TreeNode toBST(int[] nums, int sIdx, int eIdx) {
        if (sIdx > eIdx) return null;
        int mIdx = (sIdx + eIdx) / 2;
        TreeNode root = new TreeNode(nums[mIdx]);
        root.left = toBST(nums, sIdx, mIdx - 1);
        root.right = toBST(nums, mIdx + 1, eIdx);
        return root;
    }

    public TreeNode sortedArrayToBST(int[] nums) {
        return toBST(nums, 0, nums.length - 1);
    }
}

=== Chunk 312 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0108.convert-sorted-array-to-binary-search-tree\ConvertSortedArrayToBinarySearchTree2.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 313 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0108.convert-sorted-array-to-binary-search-tree\ConvertSortedArrayToBinarySearchTree2.java

class ConvertSortedArrayToBinarySearchTree2 {
    private TreeNode toBST(int[] nums, int sIdx, int eIdx) {
        if (sIdx > eIdx) return null;
        int mIdx = (sIdx + eIdx) % 2 == 1 ? (sIdx + eIdx + 1) / 2 : (sIdx + eIdx) / 2;
        TreeNode root = new TreeNode(nums[mIdx]);
        root.left = toBST(nums, sIdx, mIdx - 1);
        root.right = toBST(nums, mIdx + 1, eIdx);
        return root;
    }

    public TreeNode sortedArrayToBST(int[] nums) {
        return toBST(nums, 0, nums.length - 1);
    }
}

=== Chunk 314 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0108.convert-sorted-array-to-binary-search-tree\ConvertSortedArrayToBinarySearchTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 315 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0108.convert-sorted-array-to-binary-search-tree\ConvertSortedArrayToBinarySearchTreeTest.java

public class ConvertSortedArrayToBinarySearchTreeTest {
    ConvertSortedArrayToBinarySearchTree ConvertSortedArrayToBinarySearchTree = new ConvertSortedArrayToBinarySearchTree();
    ConvertSortedArrayToBinarySearchTree2 ConvertSortedArrayToBinarySearchTree2 = new ConvertSortedArrayToBinarySearchTree2();

    @Test
    void Example1() {
        int[] nums = {-10, -3, 0, 5, 9};
        TreeNode results = ConvertSortedArrayToBinarySearchTree.sortedArrayToBST(nums);

        Assertions.assertEquals(0, results.val);
        Assertions.assertEquals(-10, results.left.val);
        Assertions.assertEquals(5, results.right.val);
        Assertions.assertEquals(-3, results.left.right.val);
        Assertions.assertEquals(9, results.right.right.val);
    }

    @Test

=== Chunk 316 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0108.convert-sorted-array-to-binary-search-tree\ConvertSortedArrayToBinarySearchTreeTest.java

}

    @Test
    void Example2() {
        int[] nums = {1, 3};
        TreeNode results = ConvertSortedArrayToBinarySearchTree.sortedArrayToBST(nums);

        Assertions.assertEquals(1, results.val);
        Assertions.assertEquals(3, results.right.val);
    }

    @Test
    void Example3() {
        int[] nums = {-10, -3, 0, 5, 9};
        TreeNode results = ConvertSortedArrayToBinarySearchTree2.sortedArrayToBST(nums);

        Assertions.assertEquals(0, results.val);
        Assertions.assertEquals(-3, results.left.val);
        Assertions.assertEquals(9, results.right.val);
        Assertions.assertEquals(-10, results.left.left.val);
        Assertions.assertEquals(5, results.right.left.val);
    }

    @Test
    void Example4() {

=== Chunk 317 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0108.convert-sorted-array-to-binary-search-tree\ConvertSortedArrayToBinarySearchTreeTest.java

}

    @Test
    void Example4() {
        int[] nums = {1, 3};
        TreeNode results = ConvertSortedArrayToBinarySearchTree2.sortedArrayToBST(nums);

        Assertions.assertEquals(3, results.val);
        Assertions.assertEquals(1, results.left.val);
    }
}

=== Chunk 318 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0109.convert-sorted-list-to-binary-search-tree\ConvertSortedListToBinarySearchTree.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 319 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0109.convert-sorted-list-to-binary-search-tree\ConvertSortedListToBinarySearchTree.java

class ConvertSortedListToBinarySearchTree {
    private ListNode preMid(ListNode head) {
        ListNode slow = head, fast = head.next, pre = head;
        while (fast != null && fast.next != null) {
            pre = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
        return pre;
    }

    public TreeNode sortedListToBST(ListNode head) {
        if (head == null) return null;
        if (head.next == null) return new TreeNode(head.val);
        ListNode preMid = preMid(head);
        ListNode mid = preMid.next;
        preMid.next = null;
        TreeNode t = new TreeNode(mid.val);
        t.left = sortedListToBST(head);
        t.right = sortedListToBST(mid.next);
        return t;
    }
}

=== Chunk 320 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0109.convert-sorted-list-to-binary-search-tree\ConvertSortedListToBinarySearchTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 321 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0109.convert-sorted-list-to-binary-search-tree\ConvertSortedListToBinarySearchTreeTest.java

public class ConvertSortedListToBinarySearchTreeTest {
    ConvertSortedListToBinarySearchTree ConvertSortedListToBinarySearchTree = new ConvertSortedListToBinarySearchTree();

    @Test
    void Example1() {
        ListNode firstNode = new ListNode(-10);
        ListNode secondNode = new ListNode(-3);
        ListNode thirdNode = new ListNode(0);
        ListNode forthNode = new ListNode(5);
        ListNode fifthNode = new ListNode(9);

        firstNode.next = secondNode;
        secondNode.next = thirdNode;
        thirdNode.next = forthNode;
        forthNode.next = fifthNode;

        TreeNode results = ConvertSortedListToBinarySearchTree.sortedListToBST(firstNode);

        Assertions.assertEquals(0, results.val);

=== Chunk 322 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0109.convert-sorted-list-to-binary-search-tree\ConvertSortedListToBinarySearchTreeTest.java

Assertions.assertEquals(0, results.val);
        Assertions.assertEquals(-3, results.left.val);
        Assertions.assertEquals(9, results.right.val);
        Assertions.assertEquals(-10, results.left.left.val);
        Assertions.assertEquals(5, results.right.left.val);
    }

    @Test
    void Example2() {
        TreeNode results = ConvertSortedListToBinarySearchTree.sortedListToBST(null);

        Assertions.assertNull(results);
    }
}

=== Chunk 323 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0110.balanced-binary-tree\BalancedBinaryTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class BalancedBinaryTree {
    private boolean result = true;

    private int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        if (Math.abs(l - r) > 1) result = false;
        return Math.max(l, r) + 1;
    }

    public boolean isBalanced(TreeNode root) {
        maxDepth(root);
        return result;
    }
}

=== Chunk 324 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0110.balanced-binary-tree\BalancedBinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 325 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0110.balanced-binary-tree\BalancedBinaryTreeTest.java

public class BalancedBinaryTreeTest {
    BalancedBinaryTree BalancedBinaryTree = new BalancedBinaryTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(9);
        TreeNode thirdNode = new TreeNode(20);
        TreeNode forthNode = new TreeNode(15);
        TreeNode fifthNode = new TreeNode(7);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        thirdNode.left = forthNode;
        thirdNode.right = fifthNode;

        boolean expectedResult = true;
        boolean results = BalancedBinaryTree.isBalanced(firstNode);

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(1);

=== Chunk 326 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0110.balanced-binary-tree\BalancedBinaryTreeTest.java

TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(2);
        TreeNode forthNode = new TreeNode(3);
        TreeNode fifthNode = new TreeNode(3);
        TreeNode sixthNode = new TreeNode(4);
        TreeNode seventhNode = new TreeNode(4);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        forthNode.left = sixthNode;
        forthNode.right = seventhNode;

        boolean expectedResult = false;
        boolean results = BalancedBinaryTree.isBalanced(firstNode);

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example3() {

=== Chunk 327 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0110.balanced-binary-tree\BalancedBinaryTreeTest.java

}

    @Test
    void Example3() {
        boolean expectedResult = true;
        boolean results = BalancedBinaryTree.isBalanced(null);

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 328 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0111.minimum-depth-of-binary-tree\MinimumDepthOfBinaryTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class MinimumDepthOfBinaryTree {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        int left = minDepth(root.left);
        int right = minDepth(root.right);
        if (left == 0 || right == 0) return left + right + 1;
        return Math.min(left, right) + 1;
    }
}

=== Chunk 329 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0111.minimum-depth-of-binary-tree\MinimumDepthOfBinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 330 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0111.minimum-depth-of-binary-tree\MinimumDepthOfBinaryTreeTest.java

public class MinimumDepthOfBinaryTreeTest {
    MinimumDepthOfBinaryTree MinimumDepthOfBinaryTree = new MinimumDepthOfBinaryTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(9);
        TreeNode thirdNode = new TreeNode(20);
        TreeNode forthNode = new TreeNode(15);
        TreeNode fifthNode = new TreeNode(7);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        thirdNode.left = forthNode;
        thirdNode.right = fifthNode;

        int results = MinimumDepthOfBinaryTree.minDepth(firstNode);
        int expectedResult = 2;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {

=== Chunk 331 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0111.minimum-depth-of-binary-tree\MinimumDepthOfBinaryTreeTest.java

}

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(2);
        TreeNode secondNode = new TreeNode(3);
        TreeNode thirdNode = new TreeNode(4);
        TreeNode forthNode = new TreeNode(5);
        TreeNode fifthNode = new TreeNode(6);

        firstNode.right = secondNode;
        secondNode.right = thirdNode;
        thirdNode.right = forthNode;
        forthNode.right = fifthNode;

        int results = MinimumDepthOfBinaryTree.minDepth(firstNode);
        int expectedResult = 5;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 332 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0112.path-sum\PathSum.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class PathSum {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) return false;
        if (root.left == null && root.right == null && root.val == targetSum) return true;
        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
    }
}

=== Chunk 333 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0112.path-sum\PathSumTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 334 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0112.path-sum\PathSumTest.java

public class PathSumTest {
    PathSum PathSum = new PathSum();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(5);
        TreeNode secondNode = new TreeNode(4);
        TreeNode thirdNode = new TreeNode(8);
        TreeNode forthNode = new TreeNode(11);
        TreeNode fifthNode = new TreeNode(13);
        TreeNode sixthNode = new TreeNode(4);
        TreeNode seventhNode = new TreeNode(7);
        TreeNode eighthNode = new TreeNode(2);
        TreeNode ninthNode = new TreeNode(1);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        thirdNode.left = fifthNode;
        thirdNode.right = sixthNode;
        forthNode.left = seventhNode;
        forthNode.right = eighthNode;

=== Chunk 335 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0112.path-sum\PathSumTest.java

forthNode.right = eighthNode;
        sixthNode.right = ninthNode;

        int targetSum = 22;
        boolean results = PathSum.hasPathSum(firstNode, targetSum);
        boolean expectedResult = true;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(3);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;

        int targetSum = 5;
        boolean results = PathSum.hasPathSum(firstNode, targetSum);
        boolean expectedResult = false;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example3() {

=== Chunk 336 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0112.path-sum\PathSumTest.java

}

    @Test
    void Example3() {
        int targetSum = 0;
        boolean results = PathSum.hasPathSum(null, targetSum);
        boolean expectedResult = false;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 337 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0113.path-sum-ii\PathSumIi.java

import java.util.ArrayList;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 338 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0113.path-sum-ii\PathSumIi.java

class PathSumIi {
    private void pathSum(TreeNode root, int sum, List<Integer> sol, List<List<Integer>> res) {
        if (root == null) return;
        sol.add(root.val);
        if (root.left == null && root.right == null && sum == root.val) {
            res.add(new ArrayList<>(sol));
        } else {
            pathSum(root.left, sum - root.val, sol, res);
            pathSum(root.right, sum - root.val, sol, res);
        }

        sol.remove(sol.size() - 1);
    }

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<List<Integer>> res = new ArrayList<>();
        pathSum(root, targetSum, new ArrayList<>(), res);
        return res;
    }
}

=== Chunk 339 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0113.path-sum-ii\PathSumIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 340 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0113.path-sum-ii\PathSumIiTest.java

public class PathSumIiTest {
    PathSumIi PathSumIi = new PathSumIi();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(5);
        root.left = new TreeNode(4);
        root.left.left = new TreeNode(11);
        root.left.left.left = new TreeNode(7);
        root.left.left.right = new TreeNode(2);
        root.right = new TreeNode(8);
        root.right.left = new TreeNode(13);
        root.right.right = new TreeNode(4);
        root.right.right.left = new TreeNode(5);
        root.right.right.right = new TreeNode(1);
        int targetSum = 22;
        List<List<Integer>> results = PathSumIi.pathSum(root, targetSum);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(5, 4, 11, 2));

=== Chunk 341 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0113.path-sum-ii\PathSumIiTest.java

expectedResults.add(Arrays.asList(5, 8, 4, 5));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        int targetSum = 5;
        List<List<Integer>> results = PathSumIi.pathSum(root, targetSum);
        List<List<Integer>> expectedResults = new ArrayList<>();

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        int targetSum = 0;
        List<List<Integer>> results = PathSumIi.pathSum(root, targetSum);

=== Chunk 342 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0113.path-sum-ii\PathSumIiTest.java

List<List<Integer>> expectedResults = new ArrayList<>();

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 343 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0114.flatten-binary-tree-to-linked-list\FlattenBinaryTreeToLinkedList.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class FlattenBinaryTreeToLinkedList {
    TreeNode prev = null;

    public void flatten(TreeNode root) {
        if (root == null) return;
        flatten(root.right);
        flatten(root.left);
        root.left = null;
        root.right = prev;
        prev = root;
    }
}

=== Chunk 344 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0114.flatten-binary-tree-to-linked-list\FlattenBinaryTreeToLinkedListTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 345 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0114.flatten-binary-tree-to-linked-list\FlattenBinaryTreeToLinkedListTest.java

public class FlattenBinaryTreeToLinkedListTest {
    FlattenBinaryTreeToLinkedList FlattenBinaryTreeToLinkedList = new FlattenBinaryTreeToLinkedList();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(4);
        root.right = new TreeNode(5);
        root.right.right = new TreeNode(6);
        FlattenBinaryTreeToLinkedList.flatten(root);

        Assertions.assertEquals(1, root.val);
        Assertions.assertEquals(2, root.right.val);
        Assertions.assertEquals(3, root.right.right.val);
        Assertions.assertEquals(4, root.right.right.right.val);
        Assertions.assertEquals(5, root.right.right.right.right.val);

=== Chunk 346 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0114.flatten-binary-tree-to-linked-list\FlattenBinaryTreeToLinkedListTest.java

Assertions.assertEquals(6, root.right.right.right.right.right.val);
    }

    @Test
    void Example2() {
        TreeNode root = null;
        FlattenBinaryTreeToLinkedList.flatten(root);
        Assertions.assertNull(root);
    }

    @Test
    void Example3() {
        TreeNode root = new TreeNode(0);
        FlattenBinaryTreeToLinkedList.flatten(root);
        Assertions.assertEquals(0, root.val);
    }
}

=== Chunk 347 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0116.populating-next-right-pointers-in-each-node\PopulatingNextRightPointersInEachNode.java

/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class PopulatingNextRightPointersInEachNode {
    public NextNode connect(NextNode root) {
        if (root == null) return null;
        if (root.left != null) root.left.next = root.right;
        if (root.right != null && root.next != null) root.right.next = root.next.left;
        connect(root.left);
        connect(root.right);
        return root;
    }
}

=== Chunk 348 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0116.populating-next-right-pointers-in-each-node\PopulatingNextRightPointersInEachNodeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 349 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0116.populating-next-right-pointers-in-each-node\PopulatingNextRightPointersInEachNodeTest.java

public class PopulatingNextRightPointersInEachNodeTest {
    PopulatingNextRightPointersInEachNode PopulatingNextRightPointersInEachNode = new PopulatingNextRightPointersInEachNode();

    @Test
    void Example1() {
        NextNode root = new NextNode(1);
        root.left = new NextNode(2);
        root.right = new NextNode(3);
        root.left.left = new NextNode(4);
        root.left.right = new NextNode(5);
        root.right.left = new NextNode(6);
        root.right.right = new NextNode(7);

        NextNode results = PopulatingNextRightPointersInEachNode.connect(root);

        Assertions.assertNull(results.next);
        Assertions.assertEquals(3, results.left.next.val);
        Assertions.assertNull(results.right.next);

=== Chunk 350 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0116.populating-next-right-pointers-in-each-node\PopulatingNextRightPointersInEachNodeTest.java

Assertions.assertEquals(5, results.left.left.next.val);
        Assertions.assertEquals(6, results.left.right.next.val);
        Assertions.assertEquals(7, results.right.left.next.val);
        Assertions.assertNull(results.right.right.next);
    }

    @Test
    void Example2() {
        NextNode results = PopulatingNextRightPointersInEachNode.connect(null);
        Assertions.assertNull(results);
    }
}

=== Chunk 351 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0117.populating-next-right-pointers-in-each-node-ii\PopulatingNextRightPointersInEachNodeIi.java

/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

=== Chunk 352 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0117.populating-next-right-pointers-in-each-node-ii\PopulatingNextRightPointersInEachNodeIi.java

class PopulatingNextRightPointersInEachNodeIi {
    public NextNode connect(NextNode root) {
        NextNode dummyHead = new NextNode(0);
        NextNode pre = dummyHead;
        NextNode res = root;
        while (root != null) {
            if (root.left != null) {
                pre.next = root.left;
                pre = pre.next;
            }
            if (root.right != null) {
                pre.next = root.right;
                pre = pre.next;
            }
            root = root.next;
            if (root == null) {
                pre = dummyHead;
                root = dummyHead.next;
                dummyHead.next = null;
            }
        }
        return res;
    }
}

=== Chunk 353 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0117.populating-next-right-pointers-in-each-node-ii\PopulatingNextRightPointersInEachNodeIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 354 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0117.populating-next-right-pointers-in-each-node-ii\PopulatingNextRightPointersInEachNodeIiTest.java

public class PopulatingNextRightPointersInEachNodeIiTest {
    PopulatingNextRightPointersInEachNodeIi PopulatingNextRightPointersInEachNodeIi = new PopulatingNextRightPointersInEachNodeIi();

    @Test
    void Example1() {
        NextNode root = new NextNode(1);
        root.left = new NextNode(2);
        root.left.left = new NextNode(4);
        root.left.right = new NextNode(5);
        root.right = new NextNode(3);
        root.right.right = new NextNode(7);
        NextNode results = PopulatingNextRightPointersInEachNodeIi.connect(root);

        Assertions.assertEquals(3, results.left.next.val);
        Assertions.assertEquals(5, results.left.left.next.val);
        Assertions.assertEquals(7, results.left.right.next.val);
    }

    @Test
    void Example2() {

=== Chunk 355 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0117.populating-next-right-pointers-in-each-node-ii\PopulatingNextRightPointersInEachNodeIiTest.java

}

    @Test
    void Example2() {
        NextNode results = PopulatingNextRightPointersInEachNodeIi.connect(null);

        Assertions.assertNull(results);
    }
}

=== Chunk 356 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0118.pascals-triangle\PascalsTriangle.java

import java.util.ArrayList;
import java.util.List;

class PascalsTriangle {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < numRows; i++) {
            List<Integer> temp = new ArrayList<>();
            for (int j = 0; j < i + 1; j++) {
                if (j == 0 || j == i) {
                    temp.add(1);
                } else {
                    temp.add(ans.get(i - 1).get(j - 1) + ans.get(i - 1).get(j));
                }
            }
            ans.add(temp);
        }
        return ans;
    }
}

=== Chunk 357 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0118.pascals-triangle\PascalsTriangleTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

=== Chunk 358 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0118.pascals-triangle\PascalsTriangleTest.java

public class PascalsTriangleTest {
    PascalsTriangle PascalsTriangle = new PascalsTriangle();

    @Test
    void Example1() {
        int numRows = 5;
        List<List<Integer>> results = PascalsTriangle.generate(numRows);
        List<List<Integer>> expectedResults = new ArrayList<>();
        List<Integer> first = new ArrayList<>();
        List<Integer> second = new ArrayList<>();
        List<Integer> third = new ArrayList<>();
        List<Integer> forth = new ArrayList<>();
        List<Integer> fifth = new ArrayList<>();
        first.add(1);
        second.add(1);
        second.add(1);
        third.add(1);
        third.add(2);
        third.add(1);
        forth.add(1);
        forth.add(3);
        forth.add(3);
        forth.add(1);

=== Chunk 359 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0118.pascals-triangle\PascalsTriangleTest.java

forth.add(3);
        forth.add(1);
        fifth.add(1);
        fifth.add(4);
        fifth.add(6);
        fifth.add(4);
        fifth.add(1);
        expectedResults.add(first);
        expectedResults.add(second);
        expectedResults.add(third);
        expectedResults.add(forth);
        expectedResults.add(fifth);

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int numRows = 1;
        List<List<Integer>> results = PascalsTriangle.generate(numRows);
        List<List<Integer>> expectedResults = new ArrayList<>();
        List<Integer> first = new ArrayList<>();
        first.add(1);
        expectedResults.add(first);

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 360 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0118.pascals-triangle\PascalsTriangleTest.java

}
}

=== Chunk 361 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0120.triangle\Triangle.java

import java.util.Arrays;
import java.util.List;

=== Chunk 362 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0120.triangle\Triangle.java

class Triangle {
    public int minimumTotal(List<List<Integer>> triangle) {
        int[] dp = new int[triangle.size()];
        dp[0] = triangle.get(0).get(0);
        for (int i = 1; i < triangle.size(); i++) {
            int[] mem = dp.clone();
            for (int j = 0; j < triangle.get(i).size(); j++) {
                if (j == 0) {
                    dp[j] = triangle.get(i).get(j) + mem[j];
                } else if (j == triangle.get(i).size() - 1) {
                    dp[j] = triangle.get(i).get(j) + mem[j - 1];
                } else {
                    dp[j] = triangle.get(i).get(j) + Math.min(mem[j], mem[j - 1]);
                }
            }
        }

        int res = Integer.MAX_VALUE;
        for (int num : dp) {

=== Chunk 363 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0120.triangle\Triangle.java

for (int num : dp) {
            res = Math.min(res, num);
        }
        return res;
    }
}

=== Chunk 364 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0120.triangle\TriangleTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

=== Chunk 365 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0120.triangle\TriangleTest.java

public class TriangleTest {
    Triangle Triangle = new Triangle();

    @Test
    void Example1() {
        List<List<Integer>> triangle = new LinkedList<>();
        triangle.add(List.of(2));
        triangle.add(Arrays.asList(3, 4));
        triangle.add(Arrays.asList(6, 5, 7));
        triangle.add(Arrays.asList(4, 1, 8, 3));
        int results = Triangle.minimumTotal(triangle);
        int expectedResult = 11;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        List<List<Integer>> triangle = new LinkedList<>();
        triangle.add(List.of(-10));
        int results = Triangle.minimumTotal(triangle);
        int expectedResult = -10;

        Assertions.assertEquals(expectedResult, results);
    }

=== Chunk 366 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0120.triangle\TriangleTest.java

}

    @Test
    void Example3() {
        List<List<Integer>> triangle = new LinkedList<>();
        triangle.add(List.of(-1));
        triangle.add(Arrays.asList(2, 3));
        triangle.add(Arrays.asList(1, -1, -3));
        int results = Triangle.minimumTotal(triangle);
        int expectedResult = -1;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 367 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0121.best-time-to-buy-and-sell-stock\BestTimeToBuyAndSellStock.java

class BestTimeToBuyAndSellStock {
    public int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE, maxProfit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minPrice)
                minPrice = prices[i];
            else if (prices[i] - minPrice > maxProfit)
                maxProfit = prices[i] - minPrice;
        }
        return maxProfit;
    }
}

=== Chunk 368 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0121.best-time-to-buy-and-sell-stock\BestTimeToBuyAndSellStockTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 369 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0121.best-time-to-buy-and-sell-stock\BestTimeToBuyAndSellStockTest.java

public class BestTimeToBuyAndSellStockTest {
    BestTimeToBuyAndSellStock BestTimeToBuyAndSellStock = new BestTimeToBuyAndSellStock();

    @Test
    void Example1() {
        int[] prices = {7, 1, 5, 3, 6, 4};
        int results = BestTimeToBuyAndSellStock.maxProfit(prices);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] prices = {7, 6, 4, 3, 1};
        int results = BestTimeToBuyAndSellStock.maxProfit(prices);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] prices = {1, 2};
        int results = BestTimeToBuyAndSellStock.maxProfit(prices);

=== Chunk 370 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0121.best-time-to-buy-and-sell-stock\BestTimeToBuyAndSellStockTest.java

int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 371 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0122.best-time-to-buy-and-sell-stock-ii\BestTimeToBuyAndSellStockIi.java

class BestTimeToBuyAndSellStockIi {
    public int maxProfit(int[] prices) {
        int profit = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1]) {
                profit += prices[i] - prices[i - 1] ;
            }
        }
        return profit;
    }
}

=== Chunk 372 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0122.best-time-to-buy-and-sell-stock-ii\BestTimeToBuyAndSellStockIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 373 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0122.best-time-to-buy-and-sell-stock-ii\BestTimeToBuyAndSellStockIiTest.java

public class BestTimeToBuyAndSellStockIiTest {
    BestTimeToBuyAndSellStockIi BestTimeToBuyAndSellStockIi = new BestTimeToBuyAndSellStockIi();

    @Test
    void Example1() {
        int[] prices = {7, 1, 5, 3, 6, 4};
        int results = BestTimeToBuyAndSellStockIi.maxProfit(prices);
        int expectedResults = 7;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] prices = {1, 2, 3, 4, 5};
        int results = BestTimeToBuyAndSellStockIi.maxProfit(prices);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] prices = {7, 6, 4, 3, 1};
        int results = BestTimeToBuyAndSellStockIi.maxProfit(prices);

=== Chunk 374 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0122.best-time-to-buy-and-sell-stock-ii\BestTimeToBuyAndSellStockIiTest.java

int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 375 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0126.word-ladder-ii\WordLadderIi.java

import java.util.*;

=== Chunk 376 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0126.word-ladder-ii\WordLadderIi.java

class WordLadderIi {
    private void bfs(Set<String> startSet, Set<String> endSet, Map<String, List<String>> map, Set<String> dict, boolean reverse) {
        if (startSet.size() == 0) return;
        if (startSet.size() > endSet.size()) {
            bfs(endSet, startSet, map, dict, !reverse);
            return;
        }

        Set<String> tmp = new HashSet<>();
        boolean finish = false;
        dict.removeAll(startSet);

        for (String s : startSet) {
            char[] chs = s.toCharArray();
            for (int i = 0; i < chs.length; i++) {
                char old = chs[i];
                for (char c = 'a'; c <= 'z'; c++) {
                    chs[i] = c;
                    String word = new String(chs);

=== Chunk 377 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0126.word-ladder-ii\WordLadderIi.java

if (dict.contains(word)) {
                        if (endSet.contains(word)) {
                            finish = true;
                        } else {
                            tmp.add(word);
                        }

                        String key = reverse ? word : s;
                        String val = reverse ? s : word;

                        if (map.get(key) == null) {
                            map.put(key, new ArrayList<>());
                        }

                        map.get(key).add(val);
                    }
                }
                chs[i] = old;
            }
        }

        if (!finish) {
            bfs(tmp, endSet, map, dict, reverse);
        }
    }

=== Chunk 378 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0126.word-ladder-ii\WordLadderIi.java

}
    }

    private void dfs(List<List<String>> res, List<String> list, String endWord, String word, Map<String, List<String>> map) {
        if (word.equals(endWord)) {
            res.add(new ArrayList<>(list));
            return;
        }

        if (map.get(word) == null) return;
        for (String next : map.get(word)) {
            list.add(next);
            dfs(res, list, endWord, next, map);
            list.remove(list.size() - 1);
        }
    }

    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        List<List<String>> res = new ArrayList<>();
        Set<String> dict = new HashSet<>(wordList);
        if (!dict.contains(endWord)) return res;

=== Chunk 379 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0126.word-ladder-ii\WordLadderIi.java

Map<String, List<String>> map = new HashMap<>();
        Set<String> startSet = new HashSet<>();
        Set<String> endSet = new HashSet<>();
        startSet.add(beginWord);
        endSet.add(endWord);
        bfs(startSet, endSet, map, dict, false);

        List<String> list = new ArrayList<>();
        list.add(beginWord);
        dfs(res, list, endWord, beginWord, map);

        return res;
    }
}

=== Chunk 380 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0126.word-ladder-ii\WordLadderIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 381 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0126.word-ladder-ii\WordLadderIiTest.java

public class WordLadderIiTest {
    WordLadderIi WordLadderIi = new WordLadderIi();

    @Test
    void Example1() {
        String beginWord = "hit", endWord = "cog";
        List<String> wordList = Arrays.asList("hot","dot","dog","lot","log","cog");
        List<List<String>> results = WordLadderIi.findLadders(beginWord, endWord, wordList);
        List<List<String>> expectedResults = new ArrayList<>();
        List<String> firstList = Arrays.asList("hit","hot","dot","dog","cog");
        List<String> secondList = Arrays.asList("hit","hot","lot","log","cog");
        expectedResults.add(firstList);
        expectedResults.add(secondList);

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {

=== Chunk 382 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0126.word-ladder-ii\WordLadderIiTest.java

}

    @Test
    void Example2() {
        String beginWord = "hit", endWord = "cog";
        List<String> wordList = Arrays.asList("hot","dot","dog","lot","log");
        List<List<String>> results = WordLadderIi.findLadders(beginWord, endWord, wordList);
        List<List<String>> expectedResults = new ArrayList<>();

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 383 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0128.longest-consecutive-sequence\LongestConsecutiveSequence.java

import java.util.HashMap;
import java.util.Map;

=== Chunk 384 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0128.longest-consecutive-sequence\LongestConsecutiveSequence.java

class LongestConsecutiveSequence {
    private int forward(Map<Integer, Integer> countForNum, int num) {
        if (!countForNum.containsKey(num)) {
            return 0;
        }
        int cnt = countForNum.get(num);
        if (cnt > 1) {
            return cnt;
        }
        cnt = forward(countForNum, num + 1) + 1;
        countForNum.put(num, cnt);
        return cnt;
    }

    private int maxCount(Map<Integer, Integer> countForNum) {
        int max = 0;
        for (int num : countForNum.keySet()) {
            max = Math.max(max, countForNum.get(num));
        }
        return max;
    }

    public int longestConsecutive(int[] nums) {
        Map<Integer, Integer> countForNum = new HashMap<>();
        for (int num : nums) {

=== Chunk 385 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0128.longest-consecutive-sequence\LongestConsecutiveSequence.java

for (int num : nums) {
            countForNum.put(num, 1);
        }
        for (int num : nums) {
            forward(countForNum, num);
        }
        return maxCount(countForNum);
    }
}

=== Chunk 386 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0128.longest-consecutive-sequence\LongestConsecutiveSequenceTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class LongestConsecutiveSequenceTest {
    LongestConsecutiveSequence LongestConsecutiveSequence = new LongestConsecutiveSequence();

    @Test
    void Example1() {
        int[] nums = {100, 4, 200, 1, 3, 2};

        int results = LongestConsecutiveSequence.longestConsecutive(nums);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {0, 3, 7, 2, 5, 8, 4, 6, 0, 1};

        int results = LongestConsecutiveSequence.longestConsecutive(nums);
        int expectedResults = 9;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 387 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0129.sum-root-to-leaf-numbers\SumRootToLeafNumbers.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 388 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0129.sum-root-to-leaf-numbers\SumRootToLeafNumbers.java

class SumRootToLeafNumbers {
    private int sum = 0;

    public int sumNumbers(TreeNode root) {
        dfs(root, 0);
        return sum;
    }

    private void dfs(TreeNode root, int currSum) {
        int tempSum = currSum * 10 + root.val;
        if (root.left == null && root.right == null) {
            sum += tempSum;
            return;
        }
        if (root.left != null) {
            dfs(root.left, tempSum);
        }
        if (root.right != null) {
            dfs(root.right, tempSum);
        }
    }
}

=== Chunk 389 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0129.sum-root-to-leaf-numbers\SumRootToLeafNumbersTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SumRootToLeafNumbersTest {
    SumRootToLeafNumbers sumRootToLeafNumbers = new SumRootToLeafNumbers();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);

        Assertions.assertEquals(25, sumRootToLeafNumbers.sumNumbers(root));
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(4);
        root.left = new TreeNode(9);
        root.right = new TreeNode(0);
        root.left.left = new TreeNode(5);
        root.left.right = new TreeNode(1);

        Assertions.assertEquals(1026, sumRootToLeafNumbers.sumNumbers(root));
    }
}

=== Chunk 390 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0130.surrounded-regions\SurroundedRegions.java

class SurroundedRegions {
    private void DFS(char[][] board, int row, int col) {
        if (row < 0 || row > board.length - 1 || col < 0 || col > board[0].length) return;
        if (board[row][col] == 'O') board[row][col] = '*';
        if (row > 1 && board[row - 1][col] == 'O') DFS(board, row - 1, col);
        if (row < board.length - 2 && board[row + 1][col] == 'O') DFS(board, row + 1, col);
        if (col > 1 && board[row][col - 1] == 'O') DFS(board, row, col - 1);
        if (col < board[row].length - 2 && board[row][col + 1] == 'O') DFS(board, row, col + 1);
    }

    public void solve(char[][] board) {
        if (board.length < 2 || board[0].length < 2) return;
        int m = board.length, n = board[0].length;
        for (int i = 0; i < m; i++) {

=== Chunk 391 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0130.surrounded-regions\SurroundedRegions.java

for (int i = 0; i < m; i++) {
            if (board[i][0] == 'O') DFS(board, i, 0);
            if (board[i][n - 1] == 'O') DFS(board, i, n - 1);
        }
        for (int j = 0; j < n; j++) {
            if (board[0][j] == 'O') DFS(board, 0, j);
            if (board[m - 1][j] == 'O') DFS(board, m - 1, j);
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'O') board[i][j] = 'X';
                else if (board[i][j] == '*') board[i][j] = 'O';
            }
        }
    }
}

=== Chunk 392 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0130.surrounded-regions\SurroundedRegionsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 393 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0130.surrounded-regions\SurroundedRegionsTest.java

public class SurroundedRegionsTest {
    SurroundedRegions SurroundedRegions = new SurroundedRegions();

    @Test
    void Example1() {
        char[][] board = {{'X', 'X', 'X', 'X'}, {'X', 'O', 'O', 'X'}, {'X', 'X', 'O', 'X'}, {'X', 'O', 'X', 'X'}};
        SurroundedRegions.solve(board);
        char[][] expectedResults = {{'X', 'X', 'X', 'X'}, {'X', 'X', 'X', 'X'}, {'X', 'X', 'X', 'X'}, {'X', 'O', 'X', 'X'}};

        Assertions.assertArrayEquals(expectedResults, board);
    }

    @Test
    void Example2() {
        char[][] board = {{'X'}};
        SurroundedRegions.solve(board);
        char[][] expectedResults = {{'X'}};

        Assertions.assertArrayEquals(expectedResults, board);
    }
}

=== Chunk 394 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0131.palindrome-partitioning\PalindromePartitioning.java

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 395 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0131.palindrome-partitioning\PalindromePartitioning.java

class PalindromePartitioning {
    boolean[][] f;
    List<List<String>> ans  = new ArrayList<>();
    List<String> temp = new ArrayList<>();
    int n;

    public List<List<String>> partition(String s) {
        n = s.length();
        f = new boolean[n][n];
        for (int i = 0; i < n; i++)
            Arrays.fill(f[i], true);
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                f[i][j] = (s.charAt(i) == s.charAt(j)) && f[i + 1][j - 1];
            }
        }

        dfs(s, 0);
        return ans;
    }

    private void dfs(String s, int i) {
        if (i == n) {
            ans.add(new ArrayList<>(temp));
            return;
        }
        for (int j = i; j < n; j++) {
            if (f[i][j]) {

=== Chunk 396 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0131.palindrome-partitioning\PalindromePartitioning.java

if (f[i][j]) {
                temp.add(s.substring(i, j + 1));
                dfs(s, j + 1);
                temp.remove(temp.size() - 1);
            }
        }
    }
}

=== Chunk 397 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0131.palindrome-partitioning\PalindromePartitioningTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 398 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0131.palindrome-partitioning\PalindromePartitioningTest.java

public class PalindromePartitioningTest {
    PalindromePartitioning palindromePartitioning = new PalindromePartitioning();

    @Test
    void Example1() {
        String s = "aab";
        List<List<String>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList("a", "a", "b"));
        expectedResults.add(Arrays.asList("aa", "b"));

        Assertions.assertEquals(expectedResults, palindromePartitioning.partition(s));
    }

    @Test
    void Example2() {
        String s = "a";
        List<List<String>> expectedResults = new ArrayList<>();
        expectedResults.add(List.of("a"));

        Assertions.assertEquals(expectedResults, palindromePartitioning.partition(s));
    }
}

=== Chunk 399 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0134.gas-station\GasStation.java

class GasStation {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length, i = 0;
        while (i < n) {
            int sumOfGas = 0, sumOfCost = 0, cnt = 0;
            while (cnt < n) {
                int j = (i + cnt) % n;
                sumOfGas += gas[j];
                sumOfCost += cost[j];
                if (sumOfCost > sumOfGas)
                    break;
                cnt++;
            }
            if (cnt == n)
                return i;
            else
                i = i + cnt + 1;
        }
        return -1;
    }
}

=== Chunk 400 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0134.gas-station\GasStationTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class GasStationTest {
    GasStation gasStation = new GasStation();

    @Test
    void Example1() {
        int[] gas = {1, 2, 3, 4, 5}, cost = {3, 4, 5, 1, 2};

        Assertions.assertEquals(3, gasStation.canCompleteCircuit(gas, cost));
    }

    @Test
    void Example2() {
        int[] gas = {2, 3, 4}, cost = {3, 4, 3};

        Assertions.assertEquals(-1, gasStation.canCompleteCircuit(gas, cost));
    }
}

=== Chunk 401 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0135.candy\Candy.java

import java.util.Arrays;

class Candy {
    public int candy(int[] ratings) {
        int[] left = new int[ratings.length];
        int[] right = new int[ratings.length];

        Arrays.fill(left, 1);
        Arrays.fill(right, 1);
        for (int i = 1; i < ratings.length; i++) {
            if (ratings[i] > ratings[i - 1]) left[i] = left[i - 1] + 1;
        }

        for (int i = ratings.length - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1]) right[i] = right[i + 1] + 1;
        }

        int total = 0;
        for (int i = 0; i < ratings.length; i++) {
            total += Math.max(left[i], right[i]);
        }

        return total;
    }
}

=== Chunk 402 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0135.candy\CandyTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class CandyTest {
    Candy Candy = new Candy();

    @Test
    void Example1() {
        int[] ratings = {1, 0, 2};
        int results = Candy.candy(ratings);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] ratings = {1, 2, 2};
        int results = Candy.candy(ratings);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 403 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0136.single-number\SingleNumber.java

class SingleNumber {
    public int singleNumber(int[] nums) {
        int ret = 0;
        for (int n : nums) ret = ret ^ n;
        return ret;
    }
}

=== Chunk 404 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0136.single-number\SingleNumberTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 405 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0136.single-number\SingleNumberTest.java

public class SingleNumberTest {
    SingleNumber SingleNumber = new SingleNumber();

    @Test
    void Example1() {
        int[] nums = {2, 2, 1};
        int results = SingleNumber.singleNumber(nums);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {4, 1, 2, 1, 2};
        int results = SingleNumber.singleNumber(nums);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {1};
        int results = SingleNumber.singleNumber(nums);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 406 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0141.linked-list-cycle\LinkedListCycle.java

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class LinkedListCycle {
    public boolean hasCycle(ListNode head) {
        if (head == null) return false;

        ListNode l1 = head, l2 = head.next;
        while (l1 != null && l2 != null && l2.next != null) {
            if (l1 == l2) {
                return true;
            }
            l1 = l1.next;
            l2 = l2.next.next;
        }

        return false;
    }
}

=== Chunk 407 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0141.linked-list-cycle\LinkedListCycleTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 408 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0141.linked-list-cycle\LinkedListCycleTest.java

public class LinkedListCycleTest {
    LinkedListCycle LinkedListCycle = new LinkedListCycle();

    @Test
    void Example1() {
        ListNode zeroNode = new ListNode(3);
        ListNode firstNode = new ListNode(2);
        ListNode secondNode = new ListNode(0);
        ListNode thirdNode = new ListNode(-4);
        zeroNode.next = firstNode;
        firstNode.next = secondNode;
        secondNode.next = thirdNode;
        thirdNode.next = firstNode;

        boolean expectedResults = true;

        boolean results;

        results = LinkedListCycle.hasCycle(zeroNode);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        ListNode zeroNode = new ListNode(1);
        ListNode firstNode = new ListNode(2);

=== Chunk 409 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0141.linked-list-cycle\LinkedListCycleTest.java

ListNode firstNode = new ListNode(2);
        zeroNode.next = firstNode;
        firstNode.next = zeroNode;

        boolean expectedResults = true;

        boolean results;

        results = LinkedListCycle.hasCycle(zeroNode);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        ListNode zeroNode = new ListNode(1);

        boolean expectedResults = false;

        boolean results;

        results = LinkedListCycle.hasCycle(zeroNode);
        Assertions.assertEquals(expectedResults, results);
    }

}

=== Chunk 410 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0142.linked-list-cycle-ii\LinkedListCycleIi.java

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class LinkedListCycleIi {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head, fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) break;
        }
        if (fast == null || fast.next == null) return null;
        while (head != slow) {
            head = head.next;
            slow = slow.next;
        }
        return head;
    }
}

=== Chunk 411 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0142.linked-list-cycle-ii\LinkedListCycleIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 412 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0142.linked-list-cycle-ii\LinkedListCycleIiTest.java

public class LinkedListCycleIiTest {
    LinkedListCycleIi LinkedListCycleIi = new LinkedListCycleIi();

    @Test
    void Example1() {
        ListNode head = new ListNode(3);
        ListNode secondNode = new ListNode(2);
        head.next = secondNode;
        secondNode.next = new ListNode(0);
        secondNode.next.next = new ListNode(-4);
        secondNode.next.next.next = secondNode;

        ListNode result = LinkedListCycleIi.detectCycle(head);

        Assertions.assertEquals(2, result.val);
    }

    @Test
    void Example2() {
        ListNode head = new ListNode(1);
        ListNode secondNode = new ListNode(2);
        head.next = secondNode;
        secondNode.next = head;

        ListNode result = LinkedListCycleIi.detectCycle(head);

=== Chunk 413 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0142.linked-list-cycle-ii\LinkedListCycleIiTest.java

Assertions.assertEquals(1, result.val);
    }

    @Test
    void Example3() {
        ListNode head = new ListNode(1);
        ListNode result = LinkedListCycleIi.detectCycle(head);

        Assertions.assertNull(result);
    }
}

=== Chunk 414 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0144.binary-tree-preorder-traversal\BinaryTreePreorderTraversal.java

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 415 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0144.binary-tree-preorder-traversal\BinaryTreePreorderTraversal.java

class BinaryTreePreorderTraversal {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ret = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (node == null) continue;
            ret.add(node.val);
            stack.push(node.right);
            stack.push(node.left);
        }
        return ret;
    }
}

=== Chunk 416 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0144.binary-tree-preorder-traversal\BinaryTreePreorderTraversalTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

=== Chunk 417 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0144.binary-tree-preorder-traversal\BinaryTreePreorderTraversalTest.java

public class BinaryTreePreorderTraversalTest {
    BinaryTreePreorderTraversal BinaryTreePreorderTraversal = new BinaryTreePreorderTraversal();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(3);

        firstNode.right = secondNode;
        secondNode.left = thirdNode;

        List<Integer> results = BinaryTreePreorderTraversal.preorderTraversal(firstNode);
        List<Integer> expectedResult = new ArrayList<>();
        expectedResult.add(1);
        expectedResult.add(2);
        expectedResult.add(3);

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {

=== Chunk 418 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0144.binary-tree-preorder-traversal\BinaryTreePreorderTraversalTest.java

}

    @Test
    void Example2() {
        List<Integer> results = BinaryTreePreorderTraversal.preorderTraversal(null);
        List<Integer> expectedResult = new ArrayList<>();

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example3() {
        TreeNode firstNode = new TreeNode(1);

        List<Integer> results = BinaryTreePreorderTraversal.preorderTraversal(firstNode);
        List<Integer> expectedResult = new ArrayList<>();
        expectedResult.add(1);

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 419 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0145.binary-tree-postorder-traversal\BinaryTreePostorderTraversal.java

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 420 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0145.binary-tree-postorder-traversal\BinaryTreePostorderTraversal.java

class BinaryTreePostorderTraversal {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> ret = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (node == null) continue;
            ret.add(node.val);
            stack.push(node.left);
            stack.push(node.right);
        }
        Collections.reverse(ret);
        return ret;
    }
}

=== Chunk 421 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0145.binary-tree-postorder-traversal\BinaryTreePostorderTraversalTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

=== Chunk 422 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0145.binary-tree-postorder-traversal\BinaryTreePostorderTraversalTest.java

public class BinaryTreePostorderTraversalTest {
    BinaryTreePostorderTraversal BinaryTreePostorderTraversal = new BinaryTreePostorderTraversal();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(3);

        firstNode.right = secondNode;
        secondNode.left = thirdNode;

        List<Integer> results = BinaryTreePostorderTraversal.postorderTraversal(firstNode);
        List<Integer> expectedResult = new ArrayList<>();
        expectedResult.add(3);
        expectedResult.add(2);
        expectedResult.add(1);

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {

=== Chunk 423 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0145.binary-tree-postorder-traversal\BinaryTreePostorderTraversalTest.java

}

    @Test
    void Example2() {
        List<Integer> results = BinaryTreePostorderTraversal.postorderTraversal(null);
        List<Integer> expectedResult = new ArrayList<>();

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example3() {
        TreeNode firstNode = new TreeNode(1);

        List<Integer> results = BinaryTreePostorderTraversal.postorderTraversal(firstNode);
        List<Integer> expectedResult = new ArrayList<>();
        expectedResult.add(1);

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 424 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0148.sort-list\SortList.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

=== Chunk 425 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0148.sort-list\SortList.java

class SortList {
    private ListNode getMid(ListNode head) {
        ListNode midPrev = null;
        while (head != null && head.next != null) {
            midPrev = (midPrev == null) ? head : midPrev.next;
            head = head.next.next;
        }
        ListNode mid = midPrev.next;
        midPrev.next = null;
        return mid;
    }

    private ListNode merge(ListNode list1, ListNode list2) {
        ListNode dummyHead = new ListNode(0);
        ListNode tail = dummyHead;
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                tail.next = list1;
                list1 = list1.next;
                tail = tail.next;
            } else {
                tail.next = list2;
                list2 = list2.next;

=== Chunk 426 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0148.sort-list\SortList.java

list2 = list2.next;
                tail = tail.next;
            }
        }
        tail.next = (list1 != null) ? list1 : list2;
        return dummyHead.next;
    }

    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode mid = getMid(head);
        ListNode left = sortList(head);
        ListNode right = sortList(mid);
        return merge(left, right);
    }
}

=== Chunk 427 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0148.sort-list\SortListTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 428 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0148.sort-list\SortListTest.java

public class SortListTest {
    SortList SortList = new SortList();

    @Test
    void Example1() {
        ListNode firstNode = new ListNode(4);
        ListNode secondNode = new ListNode(2);
        ListNode thirdNode = new ListNode(1);
        ListNode forthNode = new ListNode(3);

        firstNode.next = secondNode;
        secondNode.next = thirdNode;
        thirdNode.next = forthNode;

        ListNode results = SortList.sortList(firstNode);

        Assertions.assertEquals(1, results.val);
        Assertions.assertEquals(2, results.next.val);
        Assertions.assertEquals(3, results.next.next.val);
        Assertions.assertEquals(4, results.next.next.next.val);
    }

    @Test
    void Example2() {
        ListNode firstNode = new ListNode(-1);

=== Chunk 429 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0148.sort-list\SortListTest.java

ListNode firstNode = new ListNode(-1);
        ListNode secondNode = new ListNode(5);
        ListNode thirdNode = new ListNode(3);
        ListNode forthNode = new ListNode(4);
        ListNode fifthNode = new ListNode(0);

        firstNode.next = secondNode;
        secondNode.next = thirdNode;
        thirdNode.next = forthNode;
        forthNode.next = fifthNode;

        ListNode results = SortList.sortList(firstNode);

        firstNode.next = fifthNode;
        fifthNode.next = thirdNode;
        thirdNode.next = forthNode;
        forthNode.next = secondNode;
        secondNode.next = null;

        Assertions.assertEquals(-1, results.val);
        Assertions.assertEquals(0, results.next.val);

=== Chunk 430 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0148.sort-list\SortListTest.java

Assertions.assertEquals(3, results.next.next.val);
        Assertions.assertEquals(4, results.next.next.next.val);
        Assertions.assertEquals(5, results.next.next.next.next.val);
    }

    @Test
    void Example3() {
        ListNode results = SortList.sortList(null);

        Assertions.assertNull(results);
    }
}

=== Chunk 431 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0150.evaluate-reverse-polish-notation\EvaluateReversePolishNotation.java

import java.util.Stack;

=== Chunk 432 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0150.evaluate-reverse-polish-notation\EvaluateReversePolishNotation.java

class EvaluateReversePolishNotation {
    public int evalRPN(String[] tokens) {
        Stack<Integer> stack = new Stack<>();
        for (String token : tokens) {
            if (isNumber(token)) {
                stack.push(Integer.parseInt(token));
            } else {
                int num2 = stack.pop();
                int num1 = stack.pop();
                switch (token) {
                    case "+":
                        stack.push(num1 + num2);
                        break;
                    case "-":
                        stack.push(num1 - num2);
                        break;
                    case "*":
                        stack.push(num1 * num2);
                        break;
                    case "/":

=== Chunk 433 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0150.evaluate-reverse-polish-notation\EvaluateReversePolishNotation.java

case "/":
                        stack.push(num1 / num2);
                        break;
                    default:
                }
            }
        }
        return stack.pop();
    }

    private boolean isNumber(String token) {
        return !("+".equals(token) || "-".equals(token) || "*".equals(token) || "/".equals(token));
    }
}

=== Chunk 434 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0150.evaluate-reverse-polish-notation\EvaluateReversePolishNotation2.java

class EvaluateReversePolishNotation2 {
    public int evalRPN(String[] tokens) {
        int n = tokens.length;
        int[] stack = new int[(n + 1) /2];
        int index = -1;
        for (int i = 0; i < n; i++) {
            String token = tokens[i];
            switch (token) {
                case "+":
                    index--;
                    stack[index] += stack[index + 1];
                    break;
                case "-":
                    index--;
                    stack[index] -= stack[index + 1];
                    break;
                case "*":
                    index--;
                    stack[index] *= stack[index + 1];
                    break;
                case "/":
                    index--;

=== Chunk 435 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0150.evaluate-reverse-polish-notation\EvaluateReversePolishNotation2.java

index--;
                    stack[index] /= stack[index + 1];
                    break;
                default:
                    index++;
                    stack[index] = Integer.parseInt(token);
            }
        }
        return stack[index];
    }
}

=== Chunk 436 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0150.evaluate-reverse-polish-notation\EvaluateReversePolishNotationTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 437 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0150.evaluate-reverse-polish-notation\EvaluateReversePolishNotationTest.java

public class EvaluateReversePolishNotationTest {
    EvaluateReversePolishNotation evaluateReversePolishNotation = new EvaluateReversePolishNotation();
    EvaluateReversePolishNotation2 evaluateReversePolishNotation2 = new EvaluateReversePolishNotation2();

    @Test
    void Example1() {
        String[] tokens = {"2", "1", "+", "3", "*"};

        Assertions.assertEquals(9, evaluateReversePolishNotation.evalRPN(tokens));
        Assertions.assertEquals(9, evaluateReversePolishNotation2.evalRPN(tokens));
    }

    @Test
    void Example2() {
        String[] tokens = {"4", "13", "5", "/", "+"};

        Assertions.assertEquals(6, evaluateReversePolishNotation.evalRPN(tokens));
        Assertions.assertEquals(6, evaluateReversePolishNotation2.evalRPN(tokens));
    }

=== Chunk 438 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0150.evaluate-reverse-polish-notation\EvaluateReversePolishNotationTest.java

}

    @Test
    void Example3() {
        String[] tokens = {"10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"};

        Assertions.assertEquals(22, evaluateReversePolishNotation.evalRPN(tokens));
        Assertions.assertEquals(22, evaluateReversePolishNotation2.evalRPN(tokens));
    }
}

=== Chunk 439 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0151.reverse-words-in-a-string\ReverseWordsInAString.java

class ReverseWordsInAString {
    private void reverse(char[] a, int i, int j) {
        while (i < j) {
            char t = a[i];
            a[i++] = a[j];
            a[j--] = t;
        }
    }

    private void reverseWords(char[] a, int n) {
        int i = 0, j = 0;

        while (i < n) {
            while (i < j || i < n && a[i] == ' ') i++;
            while (j < i || j < n && a[j] != ' ') j++;
            reverse(a, i, j - 1);
        }
    }

    private String cleanSpaces(char[] a, int n) {
        int i = 0, j = 0;
        while (j < n) {
            while (j < n && a[j] == ' ') j++;
            while (j < n && a[j] != ' ') a[i++] = a[j++];
            while (j < n && a[j] == ' ') j++;
            if (j < n) a[i++] = ' ';
        }

=== Chunk 440 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0151.reverse-words-in-a-string\ReverseWordsInAString.java

}

        return new String(a).substring(0, i);
    }

    public String reverseWords(String s) {
        if (s == null) return null;

        char[] a = s.toCharArray();
        int n = a.length;

        reverse(a, 0, n - 1);
        reverseWords(a, n);
        return cleanSpaces(a, n);
    }
}

=== Chunk 441 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0151.reverse-words-in-a-string\ReverseWordsInAStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 442 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0151.reverse-words-in-a-string\ReverseWordsInAStringTest.java

public class ReverseWordsInAStringTest {
    ReverseWordsInAString ReverseWordsInAString = new ReverseWordsInAString();

    @Test
    void Example1() {
        String s = "the sky is blue";
        String results = ReverseWordsInAString.reverseWords(s);
        String expectedResults = "blue is sky the";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "  hello world  ";
        String results = ReverseWordsInAString.reverseWords(s);
        String expectedResults = "world hello";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "a good   example";
        String results = ReverseWordsInAString.reverseWords(s);

=== Chunk 443 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0151.reverse-words-in-a-string\ReverseWordsInAStringTest.java

String expectedResults = "example good a";

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 444 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0152.maximum-product-subarray\MaximumProductSubarray.java

class MaximumProductSubarray {
    public int maxProduct(int[] nums) {
        if (nums == null || nums.length == 0) return 0;

        int max = nums[0], min = nums[0], result = nums[0];
        for (int i = 1; i < nums.length; i++) {
            int temp = max;
            max = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);
            min = Math.min(Math.min(temp * nums[i], min * nums[i]), nums[i]);
            if (max > result) result = max;
        }
        return result;
    }
}

=== Chunk 445 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0152.maximum-product-subarray\MaximumProductSubarrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 446 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0152.maximum-product-subarray\MaximumProductSubarrayTest.java

public class MaximumProductSubarrayTest {
    MaximumProductSubarray MaximumProductSubarray = new MaximumProductSubarray();

    @Test
    void Example1() {
        int[] nums = {2, 3, -2, 4};
        int results = MaximumProductSubarray.maxProduct(nums);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {-2, 0, -1};
        int results = MaximumProductSubarray.maxProduct(nums);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {3, 2, 4, -1};
        int results = MaximumProductSubarray.maxProduct(nums);
        int expectedResults = 24;

=== Chunk 447 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0152.maximum-product-subarray\MaximumProductSubarrayTest.java

int expectedResults = 24;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 448 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0153.find-minimum-in-rotated-sorted-array\FindMinimumInRotatedSortedArray.java

class FindMinimumInRotatedSortedArray {
    public int findMin(int[] nums) {
        int l = 0, h = nums.length - 1;
        while (l < h) {
            int m = l + (h - l) / 2;
            if (nums[m] <= nums[h]) {
                h = m;
            } else {
                l = m + 1;
            }
        }
        return nums[l];
    }
}

=== Chunk 449 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0153.find-minimum-in-rotated-sorted-array\FindMinimumInRotatedSortedArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 450 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0153.find-minimum-in-rotated-sorted-array\FindMinimumInRotatedSortedArrayTest.java

public class FindMinimumInRotatedSortedArrayTest {
    FindMinimumInRotatedSortedArray FindMinimumInRotatedSortedArray = new FindMinimumInRotatedSortedArray();

    @Test
    void Example1() {
        int[] nums = {3, 4, 5, 1, 2};
        int results = FindMinimumInRotatedSortedArray.findMin(nums);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {4, 5, 6, 7, 0, 1, 2};
        int results = FindMinimumInRotatedSortedArray.findMin(nums);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {11, 13, 15, 17};

=== Chunk 451 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0153.find-minimum-in-rotated-sorted-array\FindMinimumInRotatedSortedArrayTest.java

int[] nums = {11, 13, 15, 17};
        int results = FindMinimumInRotatedSortedArray.findMin(nums);
        int expectedResults = 11;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 452 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0155.min-stack\MinStack.java

import java.util.Stack;

=== Chunk 453 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0155.min-stack\MinStack.java

class MinStack {
    private Stack<Integer> dataStack;
    private Stack<Integer> minStack;
    private int min;

    public MinStack() {
        dataStack = new Stack<>();
        minStack = new Stack<>();
        min = Integer.MAX_VALUE;
    }
    
    public void push(int val) {
        dataStack.push(val);
        min = Math.min(min, val);
        minStack.push(min);
    }
    
    public void pop() {
        dataStack.pop();
        minStack.pop();
        min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek();
    }
    
    public int top() {
        return dataStack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:

=== Chunk 454 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0155.min-stack\MinStack.java

* MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */

=== Chunk 455 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0155.min-stack\MinStackTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

class MinStackTest {
    @Test
    void Example1() {
        MinStack minStack = new MinStack();
        minStack.push(-2);
        minStack.push(0);
        minStack.push(-3);
        Assertions.assertEquals(-3, minStack.getMin());
        minStack.pop();
        Assertions.assertEquals(0, minStack.top());
        Assertions.assertEquals(-2, minStack.getMin());
    }
}

=== Chunk 456 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0160.intersection-of-two-linked-lists\IntersectionOfTwoLinkedLists.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class IntersectionOfTwoLinkedLists {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode l1 = headA, l2 = headB;
        while (l1 != l2) {
            l1 = (l1 == null) ? headB : l1.next;
            l2 = (l2 == null) ? headA : l2.next;
        }
        return l1;
    }
}

=== Chunk 457 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0160.intersection-of-two-linked-lists\IntersectionOfTwoLinkedListsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 458 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0160.intersection-of-two-linked-lists\IntersectionOfTwoLinkedListsTest.java

public class IntersectionOfTwoLinkedListsTest {
    IntersectionOfTwoLinkedLists IntersectionOfTwoLinkedLists = new IntersectionOfTwoLinkedLists();

    @Test
    void Example1() {
        ListNode headAFirstNode = new ListNode(4);
        ListNode headASecondNode = new ListNode(1);

        ListNode headBFirstNode = new ListNode(5);
        ListNode headBSecondNode = new ListNode(6);
        ListNode headBThirdNode = new ListNode(1);

        ListNode intersectionNode = new ListNode(8);
        ListNode intersectionFirstNode = new ListNode(4);
        ListNode intersectionSecondNode = new ListNode(5);

        // Link List
        headAFirstNode.next = headASecondNode;
        headASecondNode.next = intersectionNode;

        headBFirstNode.next = headBSecondNode;

=== Chunk 459 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0160.intersection-of-two-linked-lists\IntersectionOfTwoLinkedListsTest.java

headBFirstNode.next = headBSecondNode;
        headBSecondNode.next = headBThirdNode;
        headBThirdNode.next = intersectionNode;

        intersectionNode.next = intersectionFirstNode;
        intersectionFirstNode.next = intersectionSecondNode;

        ListNode results;
        results = IntersectionOfTwoLinkedLists.getIntersectionNode(headAFirstNode, headBFirstNode);
        Assertions.assertEquals(intersectionNode, results);
    }

    @Test
    void Example2() {
        ListNode headAFirstNode = new ListNode(1);
        ListNode headASecondNode = new ListNode(9);
        ListNode headAThirdNode = new ListNode(1);

        ListNode headBFirstNode = new ListNode(3);

        ListNode intersectionNode = new ListNode(2);

=== Chunk 460 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0160.intersection-of-two-linked-lists\IntersectionOfTwoLinkedListsTest.java

ListNode intersectionFirstNode = new ListNode(4);

        // Link List
        headAFirstNode.next = headASecondNode;
        headASecondNode.next = headAThirdNode;
        headAThirdNode.next = intersectionNode;

        headBFirstNode.next = intersectionNode;

        intersectionNode.next = intersectionFirstNode;

        ListNode results;
        results = IntersectionOfTwoLinkedLists.getIntersectionNode(headAFirstNode, headBFirstNode);
        Assertions.assertEquals(intersectionNode, results);
    }

    @Test
    void Example3() {
        ListNode headAFirstNode = new ListNode(2);
        ListNode headASecondNode = new ListNode(6);
        ListNode headAThirdNode = new ListNode(4);

        ListNode headBFirstNode = new ListNode(1);

=== Chunk 461 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0160.intersection-of-two-linked-lists\IntersectionOfTwoLinkedListsTest.java

ListNode headBSecondNode = new ListNode(5);

        // Link List
        headAFirstNode.next = headASecondNode;
        headASecondNode.next = headAThirdNode;

        headBFirstNode.next = headBSecondNode;

        ListNode results;
        results = IntersectionOfTwoLinkedLists.getIntersectionNode(headAFirstNode, headBFirstNode);
        Assertions.assertNull(results);
    }
}

=== Chunk 462 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0162.find-peak-element\FindPeakElement.java

class FindPeakElement {
    private int search(int[] nums, int l, int r) {
        if (l == r) return l;
        int mid = (l + r) / 2;
        if (nums[mid] > nums[mid + 1]) return search(nums, l, mid);
        return search(nums, mid + 1, r);
    }

    public int findPeakElement(int[] nums) {
        return search(nums, 0, nums.length - 1);
    }
}

=== Chunk 463 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0162.find-peak-element\FindPeakElementTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class FindPeakElementTest {
    FindPeakElement FindPeakElement = new FindPeakElement();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3, 1};
        int results = FindPeakElement.findPeakElement(nums);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 2, 1, 3, 5, 6, 4};
        int results = FindPeakElement.findPeakElement(nums);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 464 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0167.two-sum-ii-input-array-is-sorted\TwoSumIiInputArrayIsSorted.java

class TwoSumIiInputArrayIsSorted {
    public int[] twoSum(int[] numbers, int target) {
        if (numbers == null) return null;

        int i = 0, j = numbers.length - 1;
        while (i < j) {
            int sum = numbers[i] + numbers[j];
            if (sum == target) {
                return new int[] {i + 1, j + 1};
            } else if (sum > target) {
                j--;
            } else {
                i++;
            }
        }

        return null;
    }
}

=== Chunk 465 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0167.two-sum-ii-input-array-is-sorted\TwoSumIiInputArrayIsSortedTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 466 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0167.two-sum-ii-input-array-is-sorted\TwoSumIiInputArrayIsSortedTest.java

public class TwoSumIiInputArrayIsSortedTest {
    TwoSumIiInputArrayIsSorted twoSum = new TwoSumIiInputArrayIsSorted();

    @Test
    void Example1() {
        int[] nums = {2, 7, 11, 15};
        int target = 9;
        int[] expectedResults = {1, 2};

        int[] results;

        results = twoSum.twoSum(nums, target);
        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {2, 3, 4};
        int target = 6;
        int[] expectedResults = {1, 3};

        int[] results;

        results = twoSum.twoSum(nums, target);
        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {-1, 0};
        int target = -1;

=== Chunk 467 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0167.two-sum-ii-input-array-is-sorted\TwoSumIiInputArrayIsSortedTest.java

int target = -1;
        int[] expectedResults = {1, 2};

        int[] results;

        results = twoSum.twoSum(nums, target);
        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 468 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0173.binary-search-tree-iterator\BinarySearchTreeIterator.java

import java.util.Stack;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 469 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0173.binary-search-tree-iterator\BinarySearchTreeIterator.java

class BSTIterator {
    private final Stack<TreeNode> stack = new Stack<>();

    private void pushAll(TreeNode node) {
        while (node != null) {
            stack.push(node);
            node = node.left;
        }
    }

    public BSTIterator(TreeNode root) {
        pushAll(root);
    }
    
    public int next() {
        TreeNode tempNode = stack.pop();
        pushAll(tempNode.right);
        return tempNode.val;
    }
    
    public boolean hasNext() {
        return !stack.isEmpty();
    }
}

/**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator obj = new BSTIterator(root);
 * int param_1 = obj.next();
 * boolean param_2 = obj.hasNext();
 */

=== Chunk 470 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0173.binary-search-tree-iterator\BinarySearchTreeIteratorTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 471 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0173.binary-search-tree-iterator\BinarySearchTreeIteratorTest.java

public class BinarySearchTreeIteratorTest {
    @Test
    void Example1() {
        TreeNode root = new TreeNode(7);
        root.left = new TreeNode(3);
        root.right = new TreeNode(15);
        root.right.left = new TreeNode(9);
        root.right.right = new TreeNode(20);

        BSTIterator bSTIterator = new BSTIterator(root);
        Assertions.assertEquals(3, bSTIterator.next());
        Assertions.assertEquals(7, bSTIterator.next());
        Assertions.assertTrue(bSTIterator.hasNext());
        Assertions.assertEquals(9, bSTIterator.next());
        Assertions.assertTrue(bSTIterator.hasNext());
        Assertions.assertEquals(15, bSTIterator.next());
        Assertions.assertTrue(bSTIterator.hasNext());

=== Chunk 472 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0173.binary-search-tree-iterator\BinarySearchTreeIteratorTest.java

Assertions.assertEquals(20, bSTIterator.next());
        Assertions.assertFalse(bSTIterator.hasNext());
    }
}

=== Chunk 473 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0188.best-time-to-buy-and-sell-stock-iv\BestTimeToBuyAndSellStockIv.java

class BestTimeToBuyAndSellStockIv {
    public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        if (n <= 1) return 0;
        if (k >= n / 2) {
            int maxPro = 0;
            for (int i = 1; i < n; i++) {
                if (prices[i] > prices[i - 1]) maxPro += prices[i] - prices[i - 1];
            }
            return maxPro;
        }

        int[][] dp = new int[k + 1][n];
        for (int i = 1; i <= k; i++) {
            int localMax = dp[i - 1][0] - prices[0];
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.max(dp[i][j - 1], prices[j] + localMax);
                localMax = Math.max(localMax, dp[i - 1][j] - prices[j]);
            }
        }
        return dp[k][n - 1];
    }
}

=== Chunk 474 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0188.best-time-to-buy-and-sell-stock-iv\BestTimeToBuyAndSellStockIvTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class BestTimeToBuyAndSellStockIvTest {
    BestTimeToBuyAndSellStockIv BestTimeToBuyAndSellStockIv = new BestTimeToBuyAndSellStockIv();

    @Test
    void Example1() {
        int k = 2;
        int[] prices = {2, 4, 1};
        int results = BestTimeToBuyAndSellStockIv.maxProfit(k, prices);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int k = 2;
        int[] prices = {3, 2, 6, 5, 0, 3};
        int results = BestTimeToBuyAndSellStockIv.maxProfit(k, prices);
        int expectedResults = 7;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 475 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0189.rotate-array\RotateArray.java

class RotateArray {
    private void reverse(int[] nums, int l, int r) {
        while (l < r) {
            int temp = nums[l];
            nums[l] = nums[r];
            nums[r] = temp;
            l++;
            r--;
        }
    }

    public void rotate(int[] nums, int k) {
        k = k % nums.length;
        // reverse array
        int l = 0, r = nums.length - 1;
        reverse(nums, l, r);

        // reverse left part
        r = k - 1;
        reverse(nums, l, r);

        // reverse right part
        l = k;
        r = nums.length - 1;
        reverse(nums, l, r);
    }
}

=== Chunk 476 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0189.rotate-array\RotateArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class RotateArrayTest {
    RotateArray RotateArray = new RotateArray();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3, 4, 5, 6, 7};
        int k = 3;
        RotateArray.rotate(nums, k);
        int[] expectedResults = {5, 6, 7, 1, 2, 3, 4};

        Assertions.assertArrayEquals(expectedResults, nums);
    }

    @Test
    void Example2() {
        int[] nums = {-1, -100, 3, 99};
        int k = 2;
        RotateArray.rotate(nums, k);
        int[] expectedResults = {3, 99, -1, -100};

        Assertions.assertArrayEquals(expectedResults, nums);
    }
}

=== Chunk 477 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0190.reverse-bits\ReverseBits.java

public class ReverseBits {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int ret = 0;
        for (int i = 0; i < 32; i++) {
            ret <<= 1;
            ret |= (n & 1);
            n >>= 1;
        }
        return ret;
    }
}

=== Chunk 478 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0190.reverse-bits\ReverseBitsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ReverseBitsTest {
    ReverseBits ReverseBits = new ReverseBits();

    @Test
    void Example1() {
        int n = 43261596;
        int results = ReverseBits.reverseBits(n);
        int expectedResults = 964176192;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = Integer.parseUnsignedInt("4294967293");
        int results = ReverseBits.reverseBits(n);
        int expectedResults = Integer.parseUnsignedInt("3221225471");

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 479 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0191.number-of-1-bits\NumberOf1Bits.java

public class NumberOf1Bits {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int cnt = 0;
        // deal with sign part
        if (n < 0) {
            cnt++;
            n = n + 1 + Integer.MAX_VALUE;
        }
        while (n != 0) {
            if ((n & 1) == 1) cnt++;
            n = n >> 1;
        }
        return cnt;
    }
}

=== Chunk 480 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0191.number-of-1-bits\NumberOf1BitsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 481 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0191.number-of-1-bits\NumberOf1BitsTest.java

public class NumberOf1BitsTest {
    NumberOf1Bits NumberOf1Bits = new NumberOf1Bits();

    @Test
    void Example1() {
        int n = 521;
        int results = NumberOf1Bits.hammingWeight(n);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 2097152;
        int results = NumberOf1Bits.hammingWeight(n);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int n = -3;
        int results = NumberOf1Bits.hammingWeight(n);
        int expectedResults = 31;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 482 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0198.house-robber\HouseRobber.java

class HouseRobber {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        if (n == 1) return nums[0];
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++)
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);

        return dp[n - 1];
    }
}

=== Chunk 483 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0198.house-robber\HouseRobber2.java

class HouseRobber2 {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        if (n == 1) return nums[0];
        int first = nums[0];
        int second = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}

=== Chunk 484 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0198.house-robber\HouseRobberTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 485 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0198.house-robber\HouseRobberTest.java

public class HouseRobberTest {
    HouseRobber houseRobber = new HouseRobber();
    HouseRobber2 houseRobber2 = new HouseRobber2();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3, 1};

        Assertions.assertEquals(4, houseRobber.rob(nums));
        Assertions.assertEquals(4, houseRobber2.rob(nums));
    }

    @Test
    void Example2() {
        int[] nums = {2, 7, 9, 3, 1};

        Assertions.assertEquals(12, houseRobber.rob(nums));
        Assertions.assertEquals(12, houseRobber2.rob(nums));
    }

    @Test
    void Example3() {
        int[] nums = {2, 1, 1, 2};

        Assertions.assertEquals(4, houseRobber.rob(nums));
        Assertions.assertEquals(4, houseRobber2.rob(nums));
    }
}

=== Chunk 486 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0199.binary-tree-right-side-view\BinaryTreeRightSideView.java

import java.util.ArrayList;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 487 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0199.binary-tree-right-side-view\BinaryTreeRightSideView.java

class BinaryTreeRightSideView {
    private void rightSideViewHelper(TreeNode root, int level, List<Integer> list) {
        if (root == null) {
            return;
        }
        if (level == list.size()) {
            list.add(root.val);
        }
        rightSideViewHelper(root.right, level + 1, list);
        rightSideViewHelper(root.left, level + 1, list);
    }

    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        rightSideViewHelper(root, 0, list);
        return list;
    }
}

=== Chunk 488 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0199.binary-tree-right-side-view\BinaryTreeRightSideViewTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

=== Chunk 489 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0199.binary-tree-right-side-view\BinaryTreeRightSideViewTest.java

public class BinaryTreeRightSideViewTest {
    BinaryTreeRightSideView BinaryTreeRightSideView = new BinaryTreeRightSideView();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.left.right = new TreeNode(5);
        root.right = new TreeNode(3);
        root.right.right = new TreeNode(4);

        List<Integer> results = BinaryTreeRightSideView.rightSideView(root);
        List<Integer> expectedResult = new ArrayList<>();
        expectedResult.add(1);
        expectedResult.add(3);
        expectedResult.add(4);
        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(1);
        root.right = new TreeNode(3);

=== Chunk 490 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0199.binary-tree-right-side-view\BinaryTreeRightSideViewTest.java

root.right = new TreeNode(3);

        List<Integer> results = BinaryTreeRightSideView.rightSideView(root);
        List<Integer> expectedResult = new ArrayList<>();
        expectedResult.add(1);
        expectedResult.add(3);
        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example3() {
        TreeNode root = null;

        List<Integer> results = BinaryTreeRightSideView.rightSideView(root);
        List<Integer> expectedResult = new ArrayList<>();
        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 491 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0200.number-of-islands\NumberOfIslands.java

class NumberOfIslands {
    private int m;
    private int n;

    private void DFSMarking(char[][] grid, int i, int j) {
        if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == '0') return;
        grid[i][j] = '0';
        DFSMarking(grid, i + 1, j);
        DFSMarking(grid, i - 1, j);
        DFSMarking(grid, i, j + 1);
        DFSMarking(grid, i, j - 1);
    }

    public int numIslands(char[][] grid) {
        int island = 0;
        m = grid.length;
        n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    DFSMarking(grid, i, j);
                    island++;
                }
            }
        }
        return island;
    }
}

=== Chunk 492 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0200.number-of-islands\NumberOfIslandsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 493 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0200.number-of-islands\NumberOfIslandsTest.java

public class NumberOfIslandsTest {
    NumberOfIslands NumberOfIslands = new NumberOfIslands();

    @Test
    void Example1() {
        char[][] grid = {{'1', '1', '1', '1', '0'}, {'1', '1', '0', '1', '0'}, {'1', '1', '0', '0', '0'}, {'0', '0', '0', '0', '0'}};
        int results = NumberOfIslands.numIslands(grid);
        int expectedResult = 1;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        char[][] grid = {{'1', '1', '0', '0', '0'}, {'1', '1', '0', '0', '0'}, {'0', '0', '1', '0', '0'}, {'0', '0', '0', '1', '1'}};
        int results = NumberOfIslands.numIslands(grid);
        int expectedResult = 3;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 494 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0202.happy-number\HappyNumber.java

import java.util.HashMap;
import java.util.Map;

class HappyNumber {
    private int happyNumber(int n) {
        int res = 0;
        while (n > 0) {
            int num = n % 10;
            res += num * num;
            n /= 10;
        }
        return res;
    }

    public boolean isHappy(int n) {
        Map<Integer, Integer> map = new HashMap<>();
        int happyNumber = n;
        map.put(happyNumber, 1);
        while (happyNumber != 0 && happyNumber != 1) {
            happyNumber = happyNumber(happyNumber);
            if (map.containsKey(happyNumber)) {
                return false;
            } else {
                map.put(happyNumber, 1);
            }
        }
        return happyNumber == 1;
    }
}

=== Chunk 495 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0202.happy-number\HappyNumberTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class HappyNumberTest {
    HappyNumber HappyNumber = new HappyNumber();

    @Test
    void Example1() {
        int n = 19;
        boolean results = HappyNumber.isHappy(n);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 2;
        boolean results = HappyNumber.isHappy(n);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 496 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0205.isomorphic-strings\IsomorphicStrings.java

class IsomorphicStrings {
    public boolean isIsomorphic(String s, String t) {
        int[] preIndexOfs = new int[256];
        int[] preIndexOft = new int[256];
        for (int i = 0; i < s.length(); i++) {
            char sc = s.charAt(i), tc = t.charAt(i);
            if (preIndexOfs[sc] != preIndexOft[tc]) {
                return false;
            }
            preIndexOfs[sc] = i + 1;
            preIndexOft[tc] = i + 1;
        }
        return true;
    }
}

=== Chunk 497 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0205.isomorphic-strings\IsomorphicStringsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 498 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0205.isomorphic-strings\IsomorphicStringsTest.java

public class IsomorphicStringsTest {
    IsomorphicStrings IsomorphicStrings = new IsomorphicStrings();

    @Test
    void Example1() {
        String s = "egg";
        String t = "add";

        boolean results = IsomorphicStrings.isIsomorphic(s, t);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "foo";
        String t = "bar";

        boolean results = IsomorphicStrings.isIsomorphic(s, t);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "paper";
        String t = "title";

=== Chunk 499 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0205.isomorphic-strings\IsomorphicStringsTest.java

String t = "title";

        boolean results = IsomorphicStrings.isIsomorphic(s, t);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        String s = "ab";
        String t = "aa";

        boolean results = IsomorphicStrings.isIsomorphic(s, t);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 500 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0206.reverse-linked-list\ReverseLinkedList.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class ReverseLinkedList {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode next = head.next;
        ListNode newHead = reverseList(next);
        next.next = head;
        head.next = null;
        return newHead;
    }
}

=== Chunk 501 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0206.reverse-linked-list\ReverseLinkedListTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 502 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0206.reverse-linked-list\ReverseLinkedListTest.java

public class ReverseLinkedListTest {
    ReverseLinkedList ReverseLinkedList = new ReverseLinkedList();

    @Test
    void Example1() {
        ListNode firstNode = new ListNode(1);
        ListNode secondNode = new ListNode(2);
        ListNode thirdNode = new ListNode(3);
        ListNode forthNode = new ListNode(4);
        ListNode fifthNode = new ListNode(5);

        firstNode.next = secondNode;
        secondNode.next = thirdNode;
        thirdNode.next = forthNode;
        forthNode.next = fifthNode;

        ListNode results = ReverseLinkedList.reverseList(firstNode);

        fifthNode.next = forthNode;
        forthNode.next = thirdNode;
        thirdNode.next = secondNode;
        secondNode.next = firstNode;
        firstNode.next = null;

=== Chunk 503 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0206.reverse-linked-list\ReverseLinkedListTest.java

firstNode.next = null;

        Assertions.assertEquals(fifthNode, results);
    }

    @Test
    void Example2() {
        ListNode firstNode = new ListNode(1);
        ListNode secondNode = new ListNode(2);

        firstNode.next = secondNode;

        ListNode results = ReverseLinkedList.reverseList(firstNode);

        secondNode.next = firstNode;
        firstNode.next = null;

        Assertions.assertEquals(secondNode, results);
    }

    @Test
    void Example3() {
        ListNode firstNode = null;

        ListNode results = ReverseLinkedList.reverseList(firstNode);
        Assertions.assertNull(results);
    }
}

=== Chunk 504 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0207.course-schedule\CourseSchedule.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 505 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0207.course-schedule\CourseSchedule.java

class CourseSchedule {
    private boolean hasCycle(boolean[] globalMarked, boolean[] localMarked, List<Integer>[] graphic, int curNode) {
        if (localMarked[curNode]) {
            return true;
        }
        if (globalMarked[curNode]) {
            return false;
        }
        globalMarked[curNode] = true;
        localMarked[curNode] = true;
        for (int nextNode : graphic[curNode]) {
            if (hasCycle(globalMarked, localMarked, graphic, nextNode)) {
                return true;
            }
        }
        localMarked[curNode] = false;
        return false;
    }

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graphic = new List[numCourses];
        for (int i = 0; i < numCourses; i++) {

=== Chunk 506 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0207.course-schedule\CourseSchedule.java

for (int i = 0; i < numCourses; i++) {
            graphic[i] = new ArrayList<>();
        }
        for (int[] pre : prerequisites) {
            graphic[pre[0]].add(pre[1]);
        }
        boolean[] globalMarked = new boolean[numCourses];
        boolean[] localMarked = new boolean[numCourses];
        for (int i = 0; i < numCourses; i++) {
            if (hasCycle(globalMarked, localMarked, graphic, i)) {
                return false;
            }
        }
        return true;
    }
}

=== Chunk 507 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0207.course-schedule\CourseScheduleTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class CourseScheduleTest {
    CourseSchedule CourseSchedule = new CourseSchedule();

    @Test
    void Example1() {
        int numCourses = 2;
        int[][] prerequisites = {{1, 0}};
        boolean results = CourseSchedule.canFinish(numCourses, prerequisites);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int numCourses = 2;
        int[][] prerequisites ={{1, 0},{0, 1}};
        boolean results = CourseSchedule.canFinish(numCourses, prerequisites);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 508 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0208.implement-trie-prefix-tree\ImplementTriePrefixTree.java

class Trie {
    private class Node {
        Node[] childs = new Node[26];
        boolean isLeaf;
    }

    private Node root = new Node();

    private int indexForChar(char c) {
        return c - 'a';
    }

    public Trie() {
        
    }

    private void insert(String word, Node node) {
        if (node == null) return;
        if (word.length() == 0) {
            node.isLeaf = true;
            return;
        }
        int index = indexForChar(word.charAt(0));
        if (node.childs[index] == null) {
            node.childs[index] = new Node();
        }
        insert(word.substring(1), node.childs[index]);
    }
    
    public void insert(String word) {
        insert(word, root);
    }

=== Chunk 509 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0208.implement-trie-prefix-tree\ImplementTriePrefixTree.java

insert(word, root);
    }

    private boolean search(String word, Node node) {
        if (node == null) return false;
        if (word.length() == 0) return node.isLeaf;
        int index = indexForChar(word.charAt(0));
        return search(word.substring(1), node.childs[index]);
    }
    
    public boolean search(String word) {
        return search(word, root);
    }

    private boolean startWith(String prefix, Node node) {
        if (node == null) return false;
        if (prefix.length() == 0) return true;
        int index = indexForChar(prefix.charAt(0));
        return startWith(prefix.substring(1), node.childs[index]);
    }
    
    public boolean startsWith(String prefix) {
        return startWith(prefix, root);
    }
}

/**

=== Chunk 510 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0208.implement-trie-prefix-tree\ImplementTriePrefixTree.java

}
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */

=== Chunk 511 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0208.implement-trie-prefix-tree\ImplementTriePrefixTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ImplementTriePrefixTreeTest {
    @Test
    void Example1() {
        Trie trie = new Trie();
        trie.insert("apple");
        Assertions.assertTrue(trie.search("apple"));
        Assertions.assertFalse(trie.search("app"));
        Assertions.assertTrue(trie.startsWith("app"));
        trie.insert("app");
        Assertions.assertTrue(trie.search("app"));
    }
}

=== Chunk 512 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0209.minimum-size-subarray-sum\MinimumSizeSubarraySum.java

class MinimumSizeSubarraySum {
    public int minSubArrayLen(int target, int[] nums) {
        int sum = 0, left = 0, res = Integer.MAX_VALUE;
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            while (sum >= target) {
                res = Math.min(res, right - left + 1);
                sum -= nums[left++];
            }
        }
        return res == Integer.MAX_VALUE ? 0 : res;
    }
}

=== Chunk 513 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0209.minimum-size-subarray-sum\MinimumSizeSubarraySumTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 514 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0209.minimum-size-subarray-sum\MinimumSizeSubarraySumTest.java

public class MinimumSizeSubarraySumTest {
    MinimumSizeSubarraySum MinimumSizeSubarraySum = new MinimumSizeSubarraySum();

    @Test
    void Example1() {
        int target = 7;
        int[] nums = {2, 3, 1, 2, 4, 3};
        int results = MinimumSizeSubarraySum.minSubArrayLen(target, nums);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int target = 4;
        int[] nums = {1, 4, 4};
        int results = MinimumSizeSubarraySum.minSubArrayLen(target, nums);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int target = 11;
        int[] nums = {1, 1, 1, 1, 1, 1, 1, 1};

=== Chunk 515 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0209.minimum-size-subarray-sum\MinimumSizeSubarraySumTest.java

int[] nums = {1, 1, 1, 1, 1, 1, 1, 1};
        int results = MinimumSizeSubarraySum.minSubArrayLen(target, nums);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        int target = 11;
        int[] nums = {1, 2, 3, 4, 5};
        int results = MinimumSizeSubarraySum.minSubArrayLen(target, nums);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 516 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0210.course-schedule-ii\CourseScheduleIi.java

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

=== Chunk 517 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0210.course-schedule-ii\CourseScheduleIi.java

class CourseScheduleIi {
    private boolean hasCycle(boolean[] globalMarked, boolean[] localMarked, List<Integer>[] graphic, int curNode, Stack<Integer> postOrder) {
        if (localMarked[curNode]) {
            return true;
        }
        if (globalMarked[curNode]) {
            return false;
        }
        globalMarked[curNode] = true;
        localMarked[curNode] = true;
        for (int nextNode : graphic[curNode]) {
            if (hasCycle(globalMarked, localMarked, graphic, nextNode, postOrder)) {
                return true;
            }
        }
        localMarked[curNode] = false;
        postOrder.push(curNode);
        return false;
    }

    public int[] findOrder(int numCourses, int[][] prerequisites) {

=== Chunk 518 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0210.course-schedule-ii\CourseScheduleIi.java

List<Integer>[] graphic = new List[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graphic[i] = new ArrayList<>();
        }
        for (int[] pre : prerequisites) {
            graphic[pre[0]].add(pre[1]);
        }
        Stack<Integer> postOder = new Stack<>();
        boolean[] globalMarked = new boolean[numCourses];
        boolean[] localMarked = new boolean[numCourses];
        for (int i = 0; i < numCourses; i++) {
            if (hasCycle(globalMarked, localMarked, graphic, i, postOder)) {
                return new int[0];
            }
        }
        int[] orders = new int[numCourses];
        for (int i = numCourses - 1; i >= 0; i--) {
            orders[i] = postOder.pop();
        }
        return orders;
    }
}

=== Chunk 519 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0210.course-schedule-ii\CourseScheduleIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 520 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0210.course-schedule-ii\CourseScheduleIiTest.java

public class CourseScheduleIiTest {
    CourseScheduleIi CourseScheduleIi = new CourseScheduleIi();

    @Test
    void Example1() {
        int numCourses = 2;
        int[][] prerequisites = {{1, 0}};
        int[] results = CourseScheduleIi.findOrder(numCourses, prerequisites);
        int[] expectedResults = {0, 1};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int numCourses = 4;
        int[][] prerequisites = {{1, 0}, {2, 0}, {3, 1}, {3, 2}};
        int[] results = CourseScheduleIi.findOrder(numCourses, prerequisites);
        int[] expectedResults = {0, 1, 2, 3};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 521 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0210.course-schedule-ii\CourseScheduleIiTest.java

}

    @Test
    void Example3() {
        int numCourses = 1;
        int[][] prerequisites = {};
        int[] results = CourseScheduleIi.findOrder(numCourses, prerequisites);
        int[] expectedResults = {0};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 522 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0215.kth-largest-element-in-an-array\KthLargestElementInAnArray.java

import java.util.Arrays;

class KthLargestElementInAnArray {
    public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return nums[nums.length - k];
    }
}

=== Chunk 523 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0215.kth-largest-element-in-an-array\KthLargestElementInAnArray2.java

import java.util.PriorityQueue;

class KthLargestElementInAnArray2 {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int val : nums) {
            pq.add(val);
            if (pq.size() > k) {
                pq.poll();
            }
        }
        return pq.peek();
    }
}

=== Chunk 524 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0215.kth-largest-element-in-an-array\KthLargestElementInAnArray3.java

class KthLargestElementInAnArray3 {
    private void swap(int[] a, int i, int j) {
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    private int partition(int[] a, int l, int h) {
        int i = l, j = h + 1;
        while (true) {
            while (a[++i] < a[l] && i < h);
            while (a[--j] > a[l] && j > l);
            if (i >= j) {
                break;
            }
            swap(a, i, j);
        }
        swap(a, l, j);
        return j;
    }

    public int findKthLargest(int[] nums, int k) {
        k = nums.length - k;
        int l = 0, h = nums.length - 1;
        while (l < h) {
            int j = partition(nums, l, h);
            if (j == k) {
                break;
            } else if (j < k) {

=== Chunk 525 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0215.kth-largest-element-in-an-array\KthLargestElementInAnArray3.java

} else if (j < k) {
                l = j + 1;
            } else {
                h = j - 1;
            }
        }
        return nums[k];
    }
}

=== Chunk 526 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0215.kth-largest-element-in-an-array\KthLargestElementInAnArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 527 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0215.kth-largest-element-in-an-array\KthLargestElementInAnArrayTest.java

public class KthLargestElementInAnArrayTest {
    KthLargestElementInAnArray KthLargestElementInAnArray = new KthLargestElementInAnArray();
    KthLargestElementInAnArray2 KthLargestElementInAnArray2 = new KthLargestElementInAnArray2();
    KthLargestElementInAnArray3 KthLargestElementInAnArray3 = new KthLargestElementInAnArray3();

    @Test
    void Example1() {
        int[] nums = {3, 2, 1, 5, 6, 4};
        int k = 2;

        int results = KthLargestElementInAnArray.findKthLargest(nums, k);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);

        results = KthLargestElementInAnArray2.findKthLargest(nums, k);
        Assertions.assertEquals(expectedResults, results);

=== Chunk 528 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0215.kth-largest-element-in-an-array\KthLargestElementInAnArrayTest.java

results = KthLargestElementInAnArray3.findKthLargest(nums, k);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {3, 2, 3, 1, 2, 4, 5, 5, 6};
        int k = 4;

        int results = KthLargestElementInAnArray.findKthLargest(nums, k);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);

        results = KthLargestElementInAnArray2.findKthLargest(nums, k);
        Assertions.assertEquals(expectedResults, results);

        results = KthLargestElementInAnArray3.findKthLargest(nums, k);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 529 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0217.contains-duplicate\ContainsDuplicate.java

import java.util.HashSet;
import java.util.Set;

class ContainsDuplicate {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }
        return set.size() < nums.length;
    }
}

=== Chunk 530 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0217.contains-duplicate\ContainsDuplicateTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 531 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0217.contains-duplicate\ContainsDuplicateTest.java

public class ContainsDuplicateTest {
    ContainsDuplicate ContainsDuplicate = new ContainsDuplicate();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3, 1};

        boolean results = ContainsDuplicate.containsDuplicate(nums);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 2, 3, 4};

        boolean results = ContainsDuplicate.containsDuplicate(nums);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {1, 1, 1, 3, 3, 4, 3, 2, 4, 2};

        boolean results = ContainsDuplicate.containsDuplicate(nums);

=== Chunk 532 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0217.contains-duplicate\ContainsDuplicateTest.java

boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 533 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0218.the-skyline-problem\TheSkylineProblem.java

import java.util.*;

=== Chunk 534 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0218.the-skyline-problem\TheSkylineProblem.java

class TheSkylineProblem {
    public List<List<Integer>> getSkyline(int[][] buildings) {
        List<List<Integer>> res = new ArrayList<>();
        List<int[]> height = new ArrayList<>();
        for (int[] b : buildings) {
            height.add(new int[]{b[0], -b[2]});
            height.add(new int[]{b[1], b[2]});
        }
        height.sort((a, b) -> {
            if (a[0] != b[0]) return a[0] - b[0];
            else return a[1] - b[1];
        });
        Queue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));
        pq.offer(0);
        int prev = 0;
        for (int[] h : height) {
            if (h[1] < 0) pq.offer(-h[1]);
            else pq.remove(h[1]);
            int cur = pq.peek() != null ? pq.peek() : 0;
            if (prev != cur) {

=== Chunk 535 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0218.the-skyline-problem\TheSkylineProblem.java

if (prev != cur) {
                res.add(Arrays.asList(h[0], cur));
                prev = cur;
            }
        }
        return res;
    }
}

=== Chunk 536 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0218.the-skyline-problem\TheSkylineProblemTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 537 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0218.the-skyline-problem\TheSkylineProblemTest.java

public class TheSkylineProblemTest {
    TheSkylineProblem TheSkylineProblem = new TheSkylineProblem();

    @Test
    void Example1() {
        int[][] buildings = {{2,9,10},{3,7,15},{5,12,12},{15,20,10},{19,24,8}};
        List<List<Integer>> results = TheSkylineProblem.getSkyline(buildings);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(2, 10));
        expectedResults.add(Arrays.asList(3, 15));
        expectedResults.add(Arrays.asList(7, 12));
        expectedResults.add(Arrays.asList(12, 0));
        expectedResults.add(Arrays.asList(15, 10));
        expectedResults.add(Arrays.asList(20, 8));
        expectedResults.add(Arrays.asList(24, 0));

        Assertions.assertEquals(expectedResults, results);

=== Chunk 538 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0218.the-skyline-problem\TheSkylineProblemTest.java

}

    @Test
    void Example2() {
        int[][] buildings = {{0,2,3},{2,5,3}};
        List<List<Integer>> results = TheSkylineProblem.getSkyline(buildings);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(0, 3));
        expectedResults.add(Arrays.asList(5, 0));

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 539 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0219.contains-duplicate-ii\ContainsDuplicateIi.java

import java.util.HashMap;
import java.util.Map;

class ContainsDuplicateIi {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {
                if (Math.abs(map.get(nums[i]) - i) <= k) return true;
            }
            map.put(nums[i], i);
        }
        return false;
    }
}

=== Chunk 540 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0219.contains-duplicate-ii\ContainsDuplicateIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 541 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0219.contains-duplicate-ii\ContainsDuplicateIiTest.java

public class ContainsDuplicateIiTest {
    ContainsDuplicateIi ContainsDuplicateIi = new ContainsDuplicateIi();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3, 1};
        int k = 3;
        boolean results = ContainsDuplicateIi.containsNearbyDuplicate(nums, k);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 0, 1, 1};
        int k = 1;
        boolean results = ContainsDuplicateIi.containsNearbyDuplicate(nums, k);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {1, 2, 3, 1, 2, 3};
        int k = 2;

=== Chunk 542 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0219.contains-duplicate-ii\ContainsDuplicateIiTest.java

int k = 2;
        boolean results = ContainsDuplicateIi.containsNearbyDuplicate(nums, k);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 543 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0222.count-complete-tree-nodes\CountCompleteTreeNodes.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 544 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0222.count-complete-tree-nodes\CountCompleteTreeNodes.java

class CountCompleteTreeNodes {
    private int leftHeight(TreeNode node) {
        int h = 0;
        while (node != null) {
            h++;
            node = node.left;
        }
        return h;
    }

    public int countNodes(TreeNode root) {
        if (root == null) return 0;

        int l = leftHeight(root.left);
        int r = leftHeight(root.right);
        if (l == r)
            return countNodes(root.right) + (1 << l);
        return countNodes(root.left) + (1 << r);
    }
}

=== Chunk 545 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0222.count-complete-tree-nodes\CountCompleteTreeNodesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 546 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0222.count-complete-tree-nodes\CountCompleteTreeNodesTest.java

public class CountCompleteTreeNodesTest {
    CountCompleteTreeNodes CountCompleteTreeNodes = new CountCompleteTreeNodes();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right = new TreeNode(3);
        root.right.left = new TreeNode(6);

        int results = CountCompleteTreeNodes.countNodes(root);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int results = CountCompleteTreeNodes.countNodes(null);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test

=== Chunk 547 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0222.count-complete-tree-nodes\CountCompleteTreeNodesTest.java

}

    @Test
    void Example3() {
        TreeNode root = new TreeNode(1);
        int results = CountCompleteTreeNodes.countNodes(root);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 548 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0223.rectangle-area\RectangleArea.java

class RectangleArea {
    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        int areaOfA = (ax2 - ax1) * (ay2 - ay1);
        int areaOfB = (bx2 - bx1) * (by2 - by1);

        int left = Math.max(ax1, bx1);
        int right = Math.min(ax2, bx2);
        int xOverlap = right - left;

        int top = Math.min(ay2, by2);
        int bottom = Math.max(ay1, by1);
        int yOverlap = top - bottom;

        int areaOfOverlap = 0;
        if (xOverlap > 0 && yOverlap > 0) {
            areaOfOverlap = xOverlap * yOverlap;
        }

        return areaOfA + areaOfB - areaOfOverlap;
    }
}

=== Chunk 549 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0223.rectangle-area\RectangleAreaTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 550 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0223.rectangle-area\RectangleAreaTest.java

public class RectangleAreaTest {
    RectangleArea RectangleArea = new RectangleArea();

    @Test
    void Example1() {
        int ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2;
        int results = RectangleArea.computeArea(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);
        int expectedResults = 45;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2;
        int results = RectangleArea.computeArea(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);
        int expectedResults = 16;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 551 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0224.basic-calculator\BasicCalculator.java

import java.util.Stack;

=== Chunk 552 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0224.basic-calculator\BasicCalculator.java

class BasicCalculator {
    public int calculate(String s) {
        Stack<Integer> stack = new Stack<>();
        int result = 0, number = 0, sign = 1;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (Character.isDigit(c)) {
                number = 10 * number + (int)(c - '0');
            } else if (c == '+') {
                result += sign * number;
                number = 0;
                sign = 1;
            } else if (c == '-') {
                result += sign * number;
                number = 0;
                sign = -1;
            } else if (c == '(') {
                stack.push(result);
                stack.push(sign);
                sign = 1;
                result = 0;

=== Chunk 553 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0224.basic-calculator\BasicCalculator.java

result = 0;
            } else if (c == ')') {
                result += sign * number;
                number = 0;
                result *= stack.pop();
                result += stack.pop();
            }
        }
        if (number != 0) result += sign * number;
        return result;
    }
}

=== Chunk 554 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0224.basic-calculator\BasicCalculatorTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 555 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0224.basic-calculator\BasicCalculatorTest.java

public class BasicCalculatorTest {
    BasicCalculator BasicCalculator = new BasicCalculator();

    @Test
    void Example1() {
        String s = "1 + 1";
        int results = BasicCalculator.calculate(s);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = " 2-1 + 2 ";
        int results = BasicCalculator.calculate(s);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "(1+(4+5+2)-3)+(6+8)";
        int results = BasicCalculator.calculate(s);
        int expectedResults = 23;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 556 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0225.implement-stack-using-queues\ImplementStackUsingQueues.java

import java.util.LinkedList;
import java.util.Queue;

=== Chunk 557 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0225.implement-stack-using-queues\ImplementStackUsingQueues.java

class MyStack {
    private Queue<Integer> queue;

    public MyStack() {
        queue = new LinkedList<>();
    }
    
    public void push(int x) {
        queue.add(x);
        int cnt = queue.size();
        while (cnt -- > 1) {
            queue.add(queue.poll());
        }
    }
    
    public int pop() {
        return queue.remove();
    }
    
    public int top() {
        if (queue.isEmpty()) return 0;
        return queue.peek();
    }
    
    public boolean empty() {
        return queue.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */

=== Chunk 558 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0225.implement-stack-using-queues\ImplementStackUsingQueuesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ImplementStackUsingQueuesTest {
    @Test
    void Example1() {
        MyStack myStack = new MyStack();
        myStack.push(1);
        myStack.push(2);
        Assertions.assertEquals(2, myStack.top());
        Assertions.assertEquals(2, myStack.pop());
        Assertions.assertFalse(myStack.empty());
    }
}

=== Chunk 559 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0226.invert-binary-tree\InvertBinaryTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class InvertBinaryTree {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;
        TreeNode left = root.left;
        root.left = invertTree(root.right);
        root.right = invertTree(left);
        return root;
    }
}

=== Chunk 560 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0226.invert-binary-tree\InvertBinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 561 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0226.invert-binary-tree\InvertBinaryTreeTest.java

public class InvertBinaryTreeTest {
    InvertBinaryTree InvertBinaryTree = new InvertBinaryTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(4);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(7);
        TreeNode forthNode = new TreeNode(1);
        TreeNode fifthNode = new TreeNode(3);
        TreeNode sixthNode = new TreeNode(6);
        TreeNode seventhNode = new TreeNode(9);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        thirdNode.left = sixthNode;
        thirdNode.right = seventhNode;

        TreeNode results = InvertBinaryTree.invertTree(firstNode);

=== Chunk 562 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0226.invert-binary-tree\InvertBinaryTreeTest.java

firstNode.left = thirdNode;
        firstNode.right = secondNode;
        thirdNode.left = seventhNode;
        thirdNode.right = sixthNode;
        secondNode.left = fifthNode;
        secondNode.right = forthNode;

        Assertions.assertEquals(firstNode, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(2);
        TreeNode secondNode = new TreeNode(1);
        TreeNode thirdNode = new TreeNode(3);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;

        TreeNode results = InvertBinaryTree.invertTree(firstNode);

        firstNode.left = thirdNode;
        firstNode.right = secondNode;

        Assertions.assertEquals(firstNode, results);
    }

    @Test
    void Example3() {

=== Chunk 563 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0226.invert-binary-tree\InvertBinaryTreeTest.java

}

    @Test
    void Example3() {
        TreeNode results = InvertBinaryTree.invertTree(null);

        Assertions.assertNull(results);
    }
}

=== Chunk 564 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0227.basic-calculator-ii\BasicCalculatorIi.java

import java.util.Stack;

=== Chunk 565 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0227.basic-calculator-ii\BasicCalculatorIi.java

class BasicCalculatorIi {
    public int calculate(String s) {
        if (s == null || s.isEmpty()) return 0;
        Stack<Integer> stack = new Stack<>();
        int currentNumber = 0;
        char operation = '+';
        for (int i = 0; i < s.length(); i++) {
            char currentChar = s.charAt(i);
            if (Character.isDigit(currentChar)) {
                currentNumber = (currentNumber * 10) + (currentChar - '0');
            }
            if (!Character.isDigit(currentChar) && !Character.isWhitespace(currentChar) || i == s.length() - 1) {
                if (operation == '-') {
                    stack.push(-currentNumber);
                } else if (operation == '+') {
                    stack.push(currentNumber);

=== Chunk 566 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0227.basic-calculator-ii\BasicCalculatorIi.java

stack.push(currentNumber);
                } else if (operation == '*') {
                    stack.push(stack.pop() * currentNumber);
                } else if (operation == '/') {
                    stack.push(stack.pop() / currentNumber);
                }
                operation = currentChar;
                currentNumber = 0;
            }
        }
        int res = 0;
        while (!stack.isEmpty()) {
            res += stack.pop();
        }
        return res;
    }
}

=== Chunk 567 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0227.basic-calculator-ii\BasicCalculatorIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 568 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0227.basic-calculator-ii\BasicCalculatorIiTest.java

public class BasicCalculatorIiTest {
    BasicCalculatorIi BasicCalculatorIi = new BasicCalculatorIi();

    @Test
    void Example1() {
        String s = "3+2*2";
        int results = BasicCalculatorIi.calculate(s);
        int expectedResults = 7;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = " 3/2 ";
        int results = BasicCalculatorIi.calculate(s);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = " 3+5 / 2 ";
        int results = BasicCalculatorIi.calculate(s);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 569 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0230.kth-smallest-element-in-a-bst\KthSmallestElementInABst.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 570 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0230.kth-smallest-element-in-a-bst\KthSmallestElementInABst.java

class KthSmallestElementInABst {
    private int count(TreeNode node) {
        if (node == null) return 0;
        return 1 + count(node.left) + count(node.right);
    }

    public int kthSmallest(TreeNode root, int k) {
        int leftCnt = count(root.left);
        if (leftCnt == k - 1) return root.val;
        if (leftCnt > k - 1) return kthSmallest(root.left, k);
        return kthSmallest(root.right, k - leftCnt - 1);
    }
}

=== Chunk 571 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0230.kth-smallest-element-in-a-bst\KthSmallestElementInABst2.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 572 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0230.kth-smallest-element-in-a-bst\KthSmallestElementInABst2.java

public class KthSmallestElementInABst2 {
    private int cnt = 0;
    private int val;

    private void inOrder(TreeNode node, int k) {
        if (node == null) return;
        inOrder(node.left, k);
        cnt++;
        if (cnt == k) {
            val = node.val;
            return;
        }
        inOrder(node.right, k);
    }

    public int kthSmallest(TreeNode root, int k) {
        inOrder(root, k);
        return val;
    }
}

=== Chunk 573 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0230.kth-smallest-element-in-a-bst\KthSmallestElementInABstTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 574 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0230.kth-smallest-element-in-a-bst\KthSmallestElementInABstTest.java

public class KthSmallestElementInABstTest {
    KthSmallestElementInABst KthSmallestElementInABst = new KthSmallestElementInABst();
    KthSmallestElementInABst2 KthSmallestElementInABst2 = new KthSmallestElementInABst2();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(1);
        TreeNode thirdNode = new TreeNode(4);
        TreeNode forthNode = new TreeNode(2);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.right = forthNode;

        int k = 1;
        int results = KthSmallestElementInABst.kthSmallest(firstNode, k);
        int expectedResult = 1;

        Assertions.assertEquals(expectedResult, results);

=== Chunk 575 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0230.kth-smallest-element-in-a-bst\KthSmallestElementInABstTest.java

results = KthSmallestElementInABst2.kthSmallest(firstNode, k);
        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(5);
        TreeNode secondNode = new TreeNode(3);
        TreeNode thirdNode = new TreeNode(6);
        TreeNode forthNode = new TreeNode(2);
        TreeNode fifthNode = new TreeNode(4);
        TreeNode sixthNode = new TreeNode(1);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        forthNode.left = sixthNode;

        int k = 3;
        int results = KthSmallestElementInABst.kthSmallest(firstNode, k);
        int expectedResult = 3;

=== Chunk 576 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0230.kth-smallest-element-in-a-bst\KthSmallestElementInABstTest.java

int expectedResult = 3;

        Assertions.assertEquals(expectedResult, results);

        results = KthSmallestElementInABst2.kthSmallest(firstNode, k);
        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 577 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0231.power-of-two\PowerOfTwo.java

class PowerOfTwo {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }
}

=== Chunk 578 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0231.power-of-two\PowerOfTwoTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 579 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0231.power-of-two\PowerOfTwoTest.java

public class PowerOfTwoTest {
    PowerOfTwo PowerOfTwo = new PowerOfTwo();

    @Test
    void Example1() {
        int n = 1;
        boolean results = PowerOfTwo.isPowerOfTwo(n);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 16;
        boolean results = PowerOfTwo.isPowerOfTwo(n);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int n = 3;
        boolean results = PowerOfTwo.isPowerOfTwo(n);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 580 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0232.implement-queue-using-stacks\ImplementQueueUsingStacks.java

import java.util.Stack;

=== Chunk 581 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0232.implement-queue-using-stacks\ImplementQueueUsingStacks.java

class MyQueue {
    Stack<Integer> inStack;
    Stack<Integer> outStack;

    public MyQueue() {
        inStack = new Stack<>();
        outStack = new Stack<>();
    }
    
    public void push(int x) {
        inStack.push(x);
    }
    
    public int pop() {
        in2out();
        return outStack.pop();
    }

    public int peek() {
        in2out();
        return outStack.peek();
    }

    public boolean empty() {
        return inStack.isEmpty() && outStack.isEmpty();
    }

    private void in2out() {
        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:

=== Chunk 582 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0232.implement-queue-using-stacks\ImplementQueueUsingStacks.java

* MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */

=== Chunk 583 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0232.implement-queue-using-stacks\ImplementQueueUsingStacksTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ImplementQueueUsingStacksTest {
    @Test
    void Example1() {
        MyQueue myQueue = new MyQueue();
        myQueue.push(1);
        myQueue.push(2);
        Assertions.assertEquals(1, myQueue.peek());
        Assertions.assertEquals(1, myQueue.pop());
        Assertions.assertFalse(myQueue.empty());
    }
}

=== Chunk 584 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0234.palindrome-linked-list\PalindromeLinkedList.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

=== Chunk 585 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0234.palindrome-linked-list\PalindromeLinkedList.java

class PalindromeLinkedList {
    private void cut(ListNode head, ListNode cutNode) {
        while (head.next != cutNode) {
            head = head.next;
        }
        head.next = null;
    }

    private ListNode reverse(ListNode head) {
        ListNode newHead = null;
        while (head != null) {
            ListNode nextNode = head.next;
            head.next = newHead;
            newHead = head;
            head = nextNode;
        }
        return newHead;
    }

    private boolean isEqual(ListNode l1, ListNode l2) {
        while (l1 != null && l2 != null) {
            if (l1.val != l2.val) return false;
            l1 = l1.next;
            l2 = l2.next;
        }
        return true;
    }

    public boolean isPalindrome(ListNode head) {

=== Chunk 586 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0234.palindrome-linked-list\PalindromeLinkedList.java

public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) return true;
        ListNode slow = head, fast = head.next;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        if (fast != null) slow = slow.next;
        cut(head, slow);
        return isEqual(head, reverse(slow));
    }
}

=== Chunk 587 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0234.palindrome-linked-list\PalindromeLinkedListTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 588 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0234.palindrome-linked-list\PalindromeLinkedListTest.java

public class PalindromeLinkedListTest {
    PalindromeLinkedList PalindromeLinkedList = new PalindromeLinkedList();

    @Test
    void Example1() {
        ListNode firstNode = new ListNode(1);
        ListNode secondNode = new ListNode(2);
        ListNode thirdNode = new ListNode(2);
        ListNode forthNode = new ListNode(1);

        firstNode.next = secondNode;
        secondNode.next = thirdNode;
        thirdNode.next = forthNode;

        boolean results = PalindromeLinkedList.isPalindrome(firstNode);

        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        ListNode firstNode = new ListNode(1);
        firstNode.next = new ListNode(2);

=== Chunk 589 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0234.palindrome-linked-list\PalindromeLinkedListTest.java

firstNode.next = new ListNode(2);

        boolean results = PalindromeLinkedList.isPalindrome(firstNode);

        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 590 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0235.lowest-common-ancestor-of-a-binary-search-tree\LowestCommonAncestorOfABinarySearchTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class LowestCommonAncestorOfABinarySearchTree {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
        if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
        return root;
    }
}

=== Chunk 591 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0235.lowest-common-ancestor-of-a-binary-search-tree\LowestCommonAncestorOfABinarySearchTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 592 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0235.lowest-common-ancestor-of-a-binary-search-tree\LowestCommonAncestorOfABinarySearchTreeTest.java

public class LowestCommonAncestorOfABinarySearchTreeTest {
    LowestCommonAncestorOfABinarySearchTree LowestCommonAncestorOfABinarySearchTree = new LowestCommonAncestorOfABinarySearchTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(6);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(8);
        TreeNode forthNode = new TreeNode(0);
        TreeNode fifthNode = new TreeNode(4);
        TreeNode sixthNode = new TreeNode(7);
        TreeNode seventhNode = new TreeNode(9);
        TreeNode eighthNode = new TreeNode(3);
        TreeNode ninthNode = new TreeNode(5);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;

=== Chunk 593 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0235.lowest-common-ancestor-of-a-binary-search-tree\LowestCommonAncestorOfABinarySearchTreeTest.java

secondNode.left = forthNode;
        secondNode.right = fifthNode;
        thirdNode.left = sixthNode;
        thirdNode.right = seventhNode;
        fifthNode.left =eighthNode;
        fifthNode.right = ninthNode;

        TreeNode results = LowestCommonAncestorOfABinarySearchTree.lowestCommonAncestor(firstNode, secondNode, thirdNode);
        Assertions.assertEquals(6, results.val);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(6);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(8);
        TreeNode forthNode = new TreeNode(0);
        TreeNode fifthNode = new TreeNode(4);
        TreeNode sixthNode = new TreeNode(7);
        TreeNode seventhNode = new TreeNode(9);

=== Chunk 594 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0235.lowest-common-ancestor-of-a-binary-search-tree\LowestCommonAncestorOfABinarySearchTreeTest.java

TreeNode seventhNode = new TreeNode(9);
        TreeNode eighthNode = new TreeNode(3);
        TreeNode ninthNode = new TreeNode(5);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        thirdNode.left = sixthNode;
        thirdNode.right = seventhNode;
        fifthNode.left =eighthNode;
        fifthNode.right = ninthNode;

        TreeNode results = LowestCommonAncestorOfABinarySearchTree.lowestCommonAncestor(firstNode, secondNode, fifthNode);
        Assertions.assertEquals(2, results.val);
    }

    @Test
    void Example3() {
        TreeNode firstNode = new TreeNode(2);
        TreeNode secondNode = new TreeNode(1);

=== Chunk 595 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0235.lowest-common-ancestor-of-a-binary-search-tree\LowestCommonAncestorOfABinarySearchTreeTest.java

TreeNode secondNode = new TreeNode(1);

        firstNode.left = secondNode;

        TreeNode results = LowestCommonAncestorOfABinarySearchTree.lowestCommonAncestor(firstNode, firstNode, secondNode);
        Assertions.assertEquals(2, results.val);
    }
}

=== Chunk 596 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0236.lowest-common-ancestor-of-a-binary-tree\LowestCommonAncestorOfABinaryTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class LowestCommonAncestorOfABinaryTree {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p , q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        return left == null ? right : right == null ? left : root;
    }
}

=== Chunk 597 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0236.lowest-common-ancestor-of-a-binary-tree\LowestCommonAncestorOfABinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 598 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0236.lowest-common-ancestor-of-a-binary-tree\LowestCommonAncestorOfABinaryTreeTest.java

public class LowestCommonAncestorOfABinaryTreeTest {
    LowestCommonAncestorOfABinaryTree LowestCommonAncestorOfABinaryTree = new LowestCommonAncestorOfABinaryTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(5);
        TreeNode thirdNode = new TreeNode(1);
        TreeNode forthNode = new TreeNode(6);
        TreeNode fifthNode = new TreeNode(2);
        TreeNode sixthNode = new TreeNode(0);
        TreeNode seventhNode = new TreeNode(8);
        TreeNode eighthNode = new TreeNode(7);
        TreeNode ninthNode = new TreeNode(4);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;

=== Chunk 599 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0236.lowest-common-ancestor-of-a-binary-tree\LowestCommonAncestorOfABinaryTreeTest.java

secondNode.right = fifthNode;
        thirdNode.left = sixthNode;
        thirdNode.right = seventhNode;
        fifthNode.left =eighthNode;
        fifthNode.right = ninthNode;

        TreeNode results = LowestCommonAncestorOfABinaryTree.lowestCommonAncestor(firstNode, secondNode, thirdNode);
        Assertions.assertEquals(3, results.val);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(5);
        TreeNode thirdNode = new TreeNode(1);
        TreeNode forthNode = new TreeNode(6);
        TreeNode fifthNode = new TreeNode(2);
        TreeNode sixthNode = new TreeNode(0);
        TreeNode seventhNode = new TreeNode(8);
        TreeNode eighthNode = new TreeNode(7);

=== Chunk 600 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0236.lowest-common-ancestor-of-a-binary-tree\LowestCommonAncestorOfABinaryTreeTest.java

TreeNode eighthNode = new TreeNode(7);
        TreeNode ninthNode = new TreeNode(4);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        thirdNode.left = sixthNode;
        thirdNode.right = seventhNode;
        fifthNode.left =eighthNode;
        fifthNode.right = ninthNode;

        TreeNode results = LowestCommonAncestorOfABinaryTree.lowestCommonAncestor(firstNode, secondNode, ninthNode);
        Assertions.assertEquals(5, results.val);
    }

    @Test
    void Example3() {
        TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(2);

        firstNode.left = secondNode;

=== Chunk 601 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0236.lowest-common-ancestor-of-a-binary-tree\LowestCommonAncestorOfABinaryTreeTest.java

firstNode.left = secondNode;

        TreeNode results = LowestCommonAncestorOfABinaryTree.lowestCommonAncestor(firstNode, firstNode, secondNode);
        Assertions.assertEquals(1, results.val);
    }
}

=== Chunk 602 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0237.delete-node-in-a-linked-list\DeleteNodeInALinkedList.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class DeleteNodeInALinkedList {
    public void deleteNode(ListNode node) {
        ListNode nextNode = node.next;
        node.val = nextNode.val;
        node.next = nextNode.next;
        nextNode.next = null;
    }
}

=== Chunk 603 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0237.delete-node-in-a-linked-list\DeleteNodeInALinkedListTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 604 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0237.delete-node-in-a-linked-list\DeleteNodeInALinkedListTest.java

public class DeleteNodeInALinkedListTest {
    DeleteNodeInALinkedList DeleteNodeInALinkedList = new DeleteNodeInALinkedList();

    @Test
    void Example1() {
        ListNode head = new ListNode(4);
        head.next = new ListNode(5);
        head.next.next = new ListNode(1);
        head.next.next.next = new ListNode(9);
        DeleteNodeInALinkedList.deleteNode(head.next);

        Assertions.assertEquals(4, head.val);
        Assertions.assertEquals(1, head.next.val);
        Assertions.assertEquals(9, head.next.next.val);
    }

    @Test
    void Example2() {
        ListNode head = new ListNode(4);
        head.next = new ListNode(5);
        head.next.next = new ListNode(1);
        head.next.next.next = new ListNode(9);

=== Chunk 605 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0237.delete-node-in-a-linked-list\DeleteNodeInALinkedListTest.java

head.next.next.next = new ListNode(9);
        DeleteNodeInALinkedList.deleteNode(head.next.next);

        Assertions.assertEquals(4, head.val);
        Assertions.assertEquals(5, head.next.val);
        Assertions.assertEquals(9, head.next.next.val);
    }
}

=== Chunk 606 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0238.product-of-array-except-self\ProductOfArrayExceptSelf.java

class ProductOfArrayExceptSelf {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] left = new int[n];
        int[] right = new int[n];

        left[0] = 1;
        for (int i = 1; i < n; i++)
            left[i] = left[i - 1] * nums[i - 1];

        right[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--)
            right[i] = right[i + 1] * nums[i + 1];

        int[] ans = new int[n];
        for (int i = 0; i < n; i++)
            ans[i] = left[i] * right[i];

        return ans;
    }
}

=== Chunk 607 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0238.product-of-array-except-self\ProductOfArrayExceptSelf2.java

class ProductOfArrayExceptSelf2 {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];

        ans[0] = 1;
        for (int i = 1; i < n; i++)
            ans[i] = ans[i - 1] * nums[i - 1];

        int right = 1;
        for (int i = n - 1; i >= 0; i--) {
            ans[i] = ans[i] * right;
            right *= nums[i];
        }

        return ans;
    }
}

=== Chunk 608 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0238.product-of-array-except-self\ProductOfArrayExceptSelfTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 609 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0238.product-of-array-except-self\ProductOfArrayExceptSelfTest.java

public class ProductOfArrayExceptSelfTest {
    ProductOfArrayExceptSelf productOfArrayExceptSelf = new ProductOfArrayExceptSelf();
    ProductOfArrayExceptSelf2 productOfArrayExceptSelf2 = new ProductOfArrayExceptSelf2();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3 ,4};
        int[] results = productOfArrayExceptSelf.productExceptSelf(nums);

        Assertions.assertArrayEquals(new int[]{24, 12, 8, 6}, results);

        results = productOfArrayExceptSelf2.productExceptSelf(nums);

        Assertions.assertArrayEquals(new int[]{24, 12, 8, 6}, results);
    }

    @Test
    void Example2() {
        int[] nums = {-1, 1, 0, -3, 3};
        int[] results = productOfArrayExceptSelf.productExceptSelf(nums);

=== Chunk 610 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0238.product-of-array-except-self\ProductOfArrayExceptSelfTest.java

Assertions.assertArrayEquals(new int[]{0, 0, 9, 0, 0}, results);

        results = productOfArrayExceptSelf2.productExceptSelf(nums);

        Assertions.assertArrayEquals(new int[]{0, 0, 9, 0, 0}, results);
    }
}

=== Chunk 611 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0240.search-a-2d-matrix-ii\SearchA2dMatrixIi.java

class SearchA2dMatrixIi {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
        int m = matrix.length, n = matrix[0].length;
        int row = 0, col = n - 1;
        while (row < m && col >= 0) {
            if (matrix[row][col] == target) return true;
            else if (target < matrix[row][col]) col--;
            else row++;
        }
        return false;
    }
}

=== Chunk 612 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0240.search-a-2d-matrix-ii\SearchA2dMatrixIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 613 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0240.search-a-2d-matrix-ii\SearchA2dMatrixIiTest.java

public class SearchA2dMatrixIiTest {
    SearchA2dMatrixIi SearchA2dMatrixIi = new SearchA2dMatrixIi();

    @Test
    void Example1() {
        int[][] matrix = {{1, 4, 7, 11, 15}, {2, 5, 8, 12, 19}, {3, 6, 9, 16, 22}, {10, 13, 14, 17, 24}, {18, 21, 23, 26, 30}};

        int target = 5;
        boolean results = SearchA2dMatrixIi.searchMatrix(matrix, target);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] matrix = {{1, 4, 7, 11, 15}, {2, 5, 8, 12, 19}, {3, 6, 9, 16, 22}, {10, 13, 14, 17, 24}, {18, 21, 23, 26, 30}};

        int target = 20;
        boolean results = SearchA2dMatrixIi.searchMatrix(matrix, target);
        boolean expectedResults = false;

=== Chunk 614 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0240.search-a-2d-matrix-ii\SearchA2dMatrixIiTest.java

boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 615 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0241.different-ways-to-add-parentheses\DifferentWaysToAddParentheses.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 616 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0241.different-ways-to-add-parentheses\DifferentWaysToAddParentheses.java

class DifferentWaysToAddParentheses {
    public List<Integer> diffWaysToCompute(String expression) {
        List<Integer> ways = new ArrayList<>();
        for (int i = 0; i < expression.length(); i++) {
            char c = expression.charAt(i);
            if (c == '+' || c == '-' || c == '*') {
                List<Integer> left = diffWaysToCompute(expression.substring(0, i));
                List<Integer> right = diffWaysToCompute(expression.substring(i+1));
                for (int l : left) {
                    for (int r : right) {
                        switch (c) {
                            case '+':
                                ways.add(l + r);
                                break;
                            case '-':

=== Chunk 617 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0241.different-ways-to-add-parentheses\DifferentWaysToAddParentheses.java

case '-':
                                ways.add(l - r);
                                break;
                            case '*':
                                ways.add(l * r);
                                break;
                        }
                    }
                }
            }
        }
        if (ways.size() == 0) {
            ways.add(Integer.valueOf(expression));
        }
        return ways;
    }
}

=== Chunk 618 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0241.different-ways-to-add-parentheses\DifferentWaysToAddParenthesesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

=== Chunk 619 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0241.different-ways-to-add-parentheses\DifferentWaysToAddParenthesesTest.java

public class DifferentWaysToAddParenthesesTest {
    DifferentWaysToAddParentheses DifferentWaysToAddParentheses = new DifferentWaysToAddParentheses();

    @Test
    void Example1() {
        String expression = "2-1-1";
        List<Integer> results = DifferentWaysToAddParentheses.diffWaysToCompute(expression);
        List<Integer> expectedResults = Arrays.asList(2, 0);

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String expression = "2*3-4*5";
        List<Integer> results = DifferentWaysToAddParentheses.diffWaysToCompute(expression);
        List<Integer> expectedResults = Arrays.asList(-34, -10, -14, -10, 10);

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 620 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0242.valid-anagram\ValidAnagram.java

class ValidAnagram {
    public boolean isAnagram(String s, String t) {
        int[] counts = new int[26];
        for (char c : s.toCharArray()) {
            counts[c - 'a']++;
        }
        for (char c : t.toCharArray()) {
            counts[c - 'a']--;
        }
        for (int count: counts) {
            if (count != 0) return false;
        }
        return true;
    }
}

=== Chunk 621 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0242.valid-anagram\ValidAnagramTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ValidAnagramTest {
    ValidAnagram ValidAnagram = new ValidAnagram();

    @Test
    void Example1() {
        String s = "anagram";
        String t = "nagaram";

        boolean results = ValidAnagram.isAnagram(s, t);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "rat";
        String t = "car";

        boolean results = ValidAnagram.isAnagram(s, t);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 622 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0258.add-digits\AddDigits.java

class AddDigits {
    public int addDigits(int num) {
        while (num >= 10) {
            int sum = 0;
            while (num > 0) {
                sum += num % 10;
                num /= 10;
            }
            num = sum;
        }
        return num;
    }
}

=== Chunk 623 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0258.add-digits\AddDigitsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class AddDigitsTest {
    AddDigits addDigits = new AddDigits();

    @Test
    void Example1() {
        int num = 38;

        Assertions.assertEquals(2, addDigits.addDigits(num));
    }

    @Test
    void Example2() {
        int num = 0;

        Assertions.assertEquals(0, addDigits.addDigits(num));
    }
}

=== Chunk 624 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0260.single-number-iii\SingleNumberIii.java

class SingleNumberIii {
    public int[] singleNumber(int[] nums) {
        int diff = 0;
        for (int num : nums) diff ^= num;
        diff &= -diff;
        int[] ret = new int[2];
        for (int num : nums) {
            if ((num & diff) == 0) ret[0] ^= num;
            else ret[1] ^= num;
        }
        return ret;
    }
}

=== Chunk 625 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0260.single-number-iii\SingleNumberIiiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 626 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0260.single-number-iii\SingleNumberIiiTest.java

public class SingleNumberIiiTest {
    SingleNumberIii SingleNumberIii = new SingleNumberIii();

    @Test
    void Example1() {
        int[] nums = {1, 2, 1, 3, 2, 5};
        int[] results = SingleNumberIii.singleNumber(nums);
        int[] expectedResults = {5, 3};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {-1, 0};
        int[] results = SingleNumberIii.singleNumber(nums);
        int[] expectedResults = {0, -1};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {0, 1};
        int[] results = SingleNumberIii.singleNumber(nums);
        int[] expectedResults = {0, 1};

=== Chunk 627 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0260.single-number-iii\SingleNumberIiiTest.java

int[] expectedResults = {0, 1};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 628 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0263.ugly-number\UglyNumber.java

class UglyNumber {
    private int keepDividingWhenDivisible(int dividend, int divisor) {
        while (dividend % divisor == 0) {
            dividend /= divisor;
        }
        return dividend;
    }

    public boolean isUgly(int n) {
        if (n <= 0) return false;
        for (int factor : new int[]{2, 3, 5}) {
            n = keepDividingWhenDivisible(n, factor);
        }

        return n == 1;
    }
}

=== Chunk 629 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0263.ugly-number\UglyNumberTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 630 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0263.ugly-number\UglyNumberTest.java

public class UglyNumberTest {
    UglyNumber UglyNumber = new UglyNumber();

    @Test
    void Example1() {
        int n = 6;
        boolean results = UglyNumber.isUgly(n);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 1;
        boolean results = UglyNumber.isUgly(n);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int n = 14;
        boolean results = UglyNumber.isUgly(n);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 631 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0268.missing-number\MissingNumber.java

class MissingNumber {
    public int missingNumber(int[] nums) {
        int ret = 0;
        for (int i = 0; i < nums.length; i++) ret = ret ^ i ^ nums[i];
        return ret ^ nums.length;
    }
}

=== Chunk 632 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0268.missing-number\MissingNumberTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 633 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0268.missing-number\MissingNumberTest.java

public class MissingNumberTest {
    MissingNumber MissingNumber = new MissingNumber();

    @Test
    void Example1() {
        int[] nums = {3, 0, 1};
        int results = MissingNumber.missingNumber(nums);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {0, 1};
        int results = MissingNumber.missingNumber(nums);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {9, 6, 4, 2, 3, 5, 7, 0, 1};
        int results = MissingNumber.missingNumber(nums);
        int expectedResults = 8;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 634 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0278.first-bad-version\FirstBadVersion.java

/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class FirstBadVersion extends VersionControl {
    public int firstBadVersion(int n) {
        int l = 1, h = n;
        while (l < h) {
            int mid = l + (h - l) / 2;
            if (isBadVersion(mid)) {
                h = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
}

=== Chunk 635 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0278.first-bad-version\FirstBadVersionTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class FirstBadVersionTest {
    FirstBadVersion FirstBadVersion = new FirstBadVersion();

    @Test
    void Example1() {
        int n = 5;
        int results = FirstBadVersion.firstBadVersion(n);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 1;
        int results = FirstBadVersion.firstBadVersion(n);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 636 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0278.first-bad-version\VersionControl.java

public class VersionControl {
    public boolean isBadVersion(int version) {
        return version != 3;
    }
}

=== Chunk 637 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0279.perfect-squares\PerfectSquares.java

import java.util.Arrays;

class PerfectSquares {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= Math.sqrt(i); j++) {
                dp[i] = Math.min(dp[i], (dp[i - (j * j)] + 1));
            }
        }

        return dp[n];
    }
}

=== Chunk 638 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0279.perfect-squares\PerfectSquaresTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class PerfectSquaresTest {
    PerfectSquares PerfectSquares = new PerfectSquares();

    @Test
    void Example1() {
        int n = 12;
        int results = PerfectSquares.numSquares(n);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int n = 13;
        int results = PerfectSquares.numSquares(n);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 639 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0283.move-zeroes\MoveZeroes.java

class MoveZeroes {
    public void moveZeroes(int[] nums) {
        int idx = 0;
        for (int num : nums) {
            if (num != 0) {
                nums[idx++] = num;
            }
        }
        while (idx < nums.length) {
            nums[idx++] = 0;
        }
    }
}

=== Chunk 640 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0283.move-zeroes\MoveZeroesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MoveZeroesTest {
    MoveZeroes MoveZeroes = new MoveZeroes();

    @Test
    void Example1() {
        int[] nums = {0, 1, 0, 3, 12};

        MoveZeroes.moveZeroes(nums);
        int[] expectedResults = {1, 3, 12, 0, 0};

        Assertions.assertArrayEquals(expectedResults, nums);
    }

    @Test
    void Example2() {
        int[] nums = {0};

        MoveZeroes.moveZeroes(nums);
        int[] expectedResults = {0};

        Assertions.assertArrayEquals(expectedResults, nums);
    }
}

=== Chunk 641 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0287.find-the-duplicate-number\FindTheDuplicateNumber.java

class FindTheDuplicateNumber {
    public int findDuplicate(int[] nums) {
        int l = 1, h = nums.length - 1;
        while (l <= h) {
            int mid = l + (h - l) / 2;
            int cnt = 0;
            for (int i = 0; i < nums.length; i++) {
                if (nums[i] <= mid) cnt++;
            }
            if (cnt > mid) h = mid - 1;
            else l = mid + 1;
        }
        return l;
    }
}

=== Chunk 642 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0287.find-the-duplicate-number\FindTheDuplicateNumber2.java

class FindTheDuplicateNumber2 {
    public int findDuplicate(int[] nums) {
        int slow = nums[0], fast = nums[nums[0]];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        fast = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
}

=== Chunk 643 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0287.find-the-duplicate-number\FindTheDuplicateNumberTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 644 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0287.find-the-duplicate-number\FindTheDuplicateNumberTest.java

public class FindTheDuplicateNumberTest {
    FindTheDuplicateNumber FindTheDuplicateNumber = new FindTheDuplicateNumber();
    FindTheDuplicateNumber2 FindTheDuplicateNumber2 = new FindTheDuplicateNumber2();

    @Test
    void Example1() {
        int[] nums = {1, 3, 4, 2, 2};

        int results = FindTheDuplicateNumber.findDuplicate(nums);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);

        results = FindTheDuplicateNumber2.findDuplicate(nums);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {3, 1, 3, 4, 2};

        int results = FindTheDuplicateNumber.findDuplicate(nums);
        int expectedResults = 3;

=== Chunk 645 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0287.find-the-duplicate-number\FindTheDuplicateNumberTest.java

int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);

        results = FindTheDuplicateNumber2.findDuplicate(nums);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 646 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0290.word-pattern\WordPattern.java

import java.util.HashMap;
import java.util.Map;

=== Chunk 647 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0290.word-pattern\WordPattern.java

class WordPattern {
    public boolean wordPattern(String pattern, String s) {
        Map<String, Character> str2ch = new HashMap<>();
        Map<Character, String> ch2str = new HashMap<>();
        int n = s.length(), i = 0;
        for (int p = 0; p < pattern.length(); p++) {
            char currentPattern = pattern.charAt(p);
            if (i >= n) return false;
            int j = i;
            while (j < n && s.charAt(j) != ' ') {
                j++;
            }
            String word = s.substring(i, j);
            if (str2ch.containsKey(word) && str2ch.get(word) != currentPattern)
                return false;
            if (ch2str.containsKey(currentPattern) && !word.equals(ch2str.get(currentPattern)))
                return false;

=== Chunk 648 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0290.word-pattern\WordPattern.java

return false;
            str2ch.put(word, currentPattern);
            ch2str.put(currentPattern, word);
            i = j + 1;
        }
        return i >= n;
    }
}

=== Chunk 649 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0290.word-pattern\WordPatternTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 650 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0290.word-pattern\WordPatternTest.java

public class WordPatternTest {
    WordPattern wordPattern = new WordPattern();

    @Test
    void Example1() {
        String pattern = "abba", s = "dog cat cat dog";

        Assertions.assertTrue(wordPattern.wordPattern(pattern, s));
    }

    @Test
    void Example2() {
        String pattern = "abba", s = "dog cat cat fish";

        Assertions.assertFalse(wordPattern.wordPattern(pattern, s));
    }

    @Test
    void Example3() {
        String pattern = "aaaa", s = "dog cat cat dog";

        Assertions.assertFalse(wordPattern.wordPattern(pattern, s));
    }

    @Test
    void Example4() {
        String pattern = "abba", s = "dog dog dog dog";

        Assertions.assertFalse(wordPattern.wordPattern(pattern, s));
    }

    @Test

=== Chunk 651 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0290.word-pattern\WordPatternTest.java

}

    @Test
    void Example5() {
        String pattern = "jquery", s = "jquery";

        Assertions.assertFalse(wordPattern.wordPattern(pattern, s));
    }
}

=== Chunk 652 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0295.find-median-from-data-stream\FindMedianFromDataStream.java

import java.util.Collections;
import java.util.PriorityQueue;

=== Chunk 653 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0295.find-median-from-data-stream\FindMedianFromDataStream.java

class MedianFinder {
    private final PriorityQueue<Integer> small = new PriorityQueue<>(Collections.reverseOrder());
    private final PriorityQueue<Integer> large = new PriorityQueue<>();
    private boolean even = true;

    public MedianFinder() {
        
    }
    
    public void addNum(int num) {
        if (even) {
            large.offer(num);
            small.offer(large.poll());
        } else {
            small.offer(num);
            large.offer(small.poll());
        }
        even = !even;
    }
    
    public double findMedian() {
        if (even)
            if (!small.isEmpty() && !large.isEmpty())
                return (small.peek() + large.peek()) / 2.0;
            else
                return 0;
        else

=== Chunk 654 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0295.find-median-from-data-stream\FindMedianFromDataStream.java

return 0;
        else
            if (!small.isEmpty())
                return small.peek();
            else
                return 0;
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */

=== Chunk 655 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0295.find-median-from-data-stream\FindMedianFromDataStreamTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class FindMedianFromDataStreamTest {
    @Test
    void Example1() {
        MedianFinder medianFinder = new MedianFinder();
        medianFinder.addNum(1);
        medianFinder.addNum(2);
        Assertions.assertEquals(1.5, medianFinder.findMedian());
        medianFinder.addNum(3);
        Assertions.assertEquals(2.0, medianFinder.findMedian());
    }

    @Test
    void Example2() {
        MedianFinder medianFinder = new MedianFinder();
        medianFinder.addNum(1);
        Assertions.assertEquals(1, medianFinder.findMedian());
    }
}

=== Chunk 656 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0299.bulls-and-cows\BullsAndCows.java

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

=== Chunk 657 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0299.bulls-and-cows\BullsAndCows.java

class BullsAndCows {
    public String getHint(String secret, String guess) {
        int bulls = 0;
        for (int i = 0; i < secret.length(); i++) {
            if (secret.charAt(i) == guess.charAt(i)) {
                bulls++;
                secret = secret.substring(0, i) + secret.substring(i + 1);
                guess = guess.substring(0, i) + guess.substring(i + 1);
                i--;
            }
        }

        HashMap<Character, Integer> map = new HashMap<>();
        for (char c : secret.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }

        int cows = 0;
        for (char c : guess.toCharArray()) {
            if (map.containsKey(c) && map.get(c) != 0) {
                cows++;

=== Chunk 658 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0299.bulls-and-cows\BullsAndCows.java

cows++;
                map.put(c, map.get(c) - 1);
            }
        }

        return bulls + "A" + cows + "B";
    }
}

=== Chunk 659 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0299.bulls-and-cows\BullsAndCowsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 660 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0299.bulls-and-cows\BullsAndCowsTest.java

public class BullsAndCowsTest {
    BullsAndCows BullsAndCows = new BullsAndCows();

    @Test
    void Example1() {
        String secret = "1807", guess = "7810";
        String results = BullsAndCows.getHint(secret, guess);
        String expectedResults = "1A3B";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String secret = "1123", guess = "0111";
        String results = BullsAndCows.getHint(secret, guess);
        String expectedResults = "1A1B";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String secret = "11", guess = "11";
        String results = BullsAndCows.getHint(secret, guess);
        String expectedResults = "2A0B";

=== Chunk 661 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0299.bulls-and-cows\BullsAndCowsTest.java

String expectedResults = "2A0B";

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 662 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0300.longest-increasing-subsequence\LongestIncreasingSubsequence.java

import java.util.Arrays;

class LongestIncreasingSubsequence {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        dp[nums.length - 1] = 1;
        for (int i = nums.length - 2; i >= 0; i--) {
            int max = 1;
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] < nums[j]) {
                    if (max < dp[j] + 1) max = dp[j] + 1;
                }
            }
            dp[i] = max;
        }
        return Arrays.stream(dp).max().getAsInt();
    }
}

=== Chunk 663 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0300.longest-increasing-subsequence\LongestIncreasingSubsequenceTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 664 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0300.longest-increasing-subsequence\LongestIncreasingSubsequenceTest.java

public class LongestIncreasingSubsequenceTest {
    LongestIncreasingSubsequence LongestIncreasingSubsequence = new LongestIncreasingSubsequence();

    @Test
    void Example1() {
        int[] nums = {10, 9, 2, 5, 3, 7, 101, 18};
        int results = LongestIncreasingSubsequence.lengthOfLIS(nums);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {0, 1, 0, 3, 2, 3};
        int results = LongestIncreasingSubsequence.lengthOfLIS(nums);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {7, 7, 7, 7, 7, 7, 7};

=== Chunk 665 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0300.longest-increasing-subsequence\LongestIncreasingSubsequenceTest.java

int[] nums = {7, 7, 7, 7, 7, 7, 7};
        int results = LongestIncreasingSubsequence.lengthOfLIS(nums);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 666 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0307.range-sum-query-mutable\RangeSumQueryMutable.java

class NumArray {
    private int[] sums;
    private int[] nums;

    private int getSum(int i) {
        int sum = 0;
        while (i > 0) {
            sum += sums[i];
            i = i - (i & (-i));
        }
        return sum;
    }

    public NumArray(int[] nums) {
        this.nums = new int[nums.length];
        sums = new int[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            update(i, nums[i]);
        }
    }
    
    public void update(int index, int val) {
        int diff = val - nums[index];
        int j = index + 1;
        while (j < sums.length) {
            sums[j] += diff;
            j = j + (j & (-j));
        }
        nums[index] = val;
    }
    
    public int sumRange(int left, int right) {

=== Chunk 667 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0307.range-sum-query-mutable\RangeSumQueryMutable.java

public int sumRange(int left, int right) {
        return getSum(right + 1) - getSum(left);
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(index,val);
 * int param_2 = obj.sumRange(left,right);
 */

=== Chunk 668 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0307.range-sum-query-mutable\RangeSumQueryMutableTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class RangeSumQueryMutableTest {
    @Test
    void Example1() {
        int[] nums = {1, 3, 5};
        NumArray NumArray = new NumArray(nums);
        int result1 = NumArray.sumRange(0, 2);
        Assertions.assertEquals(9, result1);

        NumArray.update(1, 2);
        int result2 = NumArray.sumRange(0, 2);
        Assertions.assertEquals(8, result2);
    }
}

=== Chunk 669 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0309.best-time-to-buy-and-sell-stock-with-cooldown\BestTimeToBuyAndSellStockWithCooldown.java

class BestTimeToBuyAndSellStockWithCooldown {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n == 0) return 0;

        int[][] f = new int[n][3];
        f[0][0] = -prices[0];
        for (int i = 1; i < n; i++) {
            f[i][0] = Math.max(f[i - 1][0], f[i - 1][2] - prices[i]);
            f[i][1] = f[i - 1][0] + prices[i];
            f[i][2] = Math.max(f[i - 1][1], f[i - 1][2]);
        }
        return Math.max(f[n - 1][1], f[n - 1][2]);
    }
}

=== Chunk 670 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0309.best-time-to-buy-and-sell-stock-with-cooldown\BestTimeToBuyAndSellStockWithCooldown2.java

class BestTimeToBuyAndSellStockWithCooldown2 {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n == 0) return 0;

        int f0 = -prices[0];
        int f1 = 0, f2 = 0;
        for (int i = 1; i < n; i++) {
            int newF0 = Math.max(f0, f2 - prices[i]);
            int newF1 = f0 + prices[i];
            int newF2 = Math.max(f1, f2);
            f0 = newF0;
            f1 = newF1;
            f2 = newF2;
        }
        return Math.max(f1, f2);
    }
}

=== Chunk 671 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0309.best-time-to-buy-and-sell-stock-with-cooldown\BestTimeToBuyAndSellStockWithCooldownTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 672 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0309.best-time-to-buy-and-sell-stock-with-cooldown\BestTimeToBuyAndSellStockWithCooldownTest.java

public class BestTimeToBuyAndSellStockWithCooldownTest {
    BestTimeToBuyAndSellStockWithCooldown bestTimeToBuyAndSellStockWithCooldown = new BestTimeToBuyAndSellStockWithCooldown();
    BestTimeToBuyAndSellStockWithCooldown2 bestTimeToBuyAndSellStockWithCooldown2 = new BestTimeToBuyAndSellStockWithCooldown2();

    @Test
    void Example1() {
        int[] prices = {1, 2, 3, 0, 2};

        Assertions.assertEquals(3, bestTimeToBuyAndSellStockWithCooldown.maxProfit(prices));
        Assertions.assertEquals(3, bestTimeToBuyAndSellStockWithCooldown2.maxProfit(prices));
    }

    @Test
    void Example2() {
        int[] prices = {1};

        Assertions.assertEquals(0, bestTimeToBuyAndSellStockWithCooldown.maxProfit(prices));

=== Chunk 673 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0309.best-time-to-buy-and-sell-stock-with-cooldown\BestTimeToBuyAndSellStockWithCooldownTest.java

Assertions.assertEquals(0, bestTimeToBuyAndSellStockWithCooldown2.maxProfit(prices));
    }
}

=== Chunk 674 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0315.count-of-smaller-numbers-after-self\CountOfSmallerNumbersAfterSelf.java

import java.util.Arrays;
import java.util.List;

=== Chunk 675 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0315.count-of-smaller-numbers-after-self\CountOfSmallerNumbersAfterSelf.java

class CountOfSmallerNumbersAfterSelf {
    public List<Integer> countSmaller(int[] nums) {
        // copy from the solution.
        int min = 20001;
        int max = -1;
        for (int num : nums) {
            min = Math.min(min, num);
            max = Math.max(max, num);
        }

        min--;
        int[] count = new int[max - min + 1];
        Integer[] result = new Integer[nums.length];
        for (int i = nums.length-1; i >=0; i--) {
            int k = nums[i] - min - 1;
            int c = 0;
            do {
                c += count[k];
                k -= (-k&k);
            } while (k > 0);
            result[i] = c;

            k = nums[i]-min;
            while (k < count.length) {
                count[k]++;

=== Chunk 676 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0315.count-of-smaller-numbers-after-self\CountOfSmallerNumbersAfterSelf.java

count[k]++;
                k += (-k & k);
            }
        }

        return Arrays.asList(result);
    }
}

=== Chunk 677 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0315.count-of-smaller-numbers-after-self\CountOfSmallerNumbersAfterSelfTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.LinkedList;
import java.util.List;

=== Chunk 678 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0315.count-of-smaller-numbers-after-self\CountOfSmallerNumbersAfterSelfTest.java

public class CountOfSmallerNumbersAfterSelfTest {
    CountOfSmallerNumbersAfterSelf CountOfSmallerNumbersAfterSelf = new CountOfSmallerNumbersAfterSelf();

    @Test
    void Example1() {
        int[] nums = {5, 2, 6, 1};
        List<Integer> result = CountOfSmallerNumbersAfterSelf.countSmaller(nums);
        List<Integer> expectedResults = new LinkedList<>();
        expectedResults.add(2);
        expectedResults.add(1);
        expectedResults.add(1);
        expectedResults.add(0);

        Assertions.assertEquals(expectedResults, result);
    }

    @Test
    void Example2() {
        int[] nums = {-1};
        List<Integer> result = CountOfSmallerNumbersAfterSelf.countSmaller(nums);
        List<Integer> expectedResults = new LinkedList<>();

=== Chunk 679 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0315.count-of-smaller-numbers-after-self\CountOfSmallerNumbersAfterSelfTest.java

expectedResults.add(0);

        Assertions.assertEquals(expectedResults, result);
    }

    @Test
    void Example3() {
        int[] nums = {-1, -1};
        List<Integer> result = CountOfSmallerNumbersAfterSelf.countSmaller(nums);
        List<Integer> expectedResults = new LinkedList<>();
        expectedResults.add(0);
        expectedResults.add(0);

        Assertions.assertEquals(expectedResults, result);
    }
}

=== Chunk 680 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0318.maximum-product-of-word-lengths\MaximumProductOfWordLengths.java

class MaximumProductOfWordLengths {
    public int maxProduct(String[] words) {
        int n = words.length;
        int[] val = new int[n];
        for (int i = 0; i < n; i++) {
            for (char c : words[i].toCharArray()) {
                val[i] |= 1 << (c - 'a');
            }
        }
        int ret = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if ((val[i] & val[j]) == 0) {
                    ret = Math.max(ret, words[i].length() * words[j].length());
                }
            }
        }
        return ret;
    }
}

=== Chunk 681 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0318.maximum-product-of-word-lengths\MaximumProductOfWordLengthsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 682 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0318.maximum-product-of-word-lengths\MaximumProductOfWordLengthsTest.java

public class MaximumProductOfWordLengthsTest {
    MaximumProductOfWordLengths MaximumProductOfWordLengths = new MaximumProductOfWordLengths();

    @Test
    void Example1() {
        String[] words = {"abcw", "baz", "foo", "bar", "xtfn", "abcdef"};
        int results = MaximumProductOfWordLengths.maxProduct(words);
        int expectedResults = 16;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String[] words = {"a", "ab", "abc", "d", "cd", "bcd", "abcd"};
        int results = MaximumProductOfWordLengths.maxProduct(words);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 683 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0318.maximum-product-of-word-lengths\MaximumProductOfWordLengthsTest.java

}

    @Test
    void Example3() {
        String[] words = {"a", "aa", "aaa", "aaaa"};
        int results = MaximumProductOfWordLengths.maxProduct(words);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 684 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0322.coin-change\CoinChange.java

import java.util.Arrays;

class CoinChange {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int c : coins) {
                if (i >= c) {
                    dp[i] = Math.min(dp[i], dp[i - c] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}

=== Chunk 685 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0322.coin-change\CoinChangeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 686 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0322.coin-change\CoinChangeTest.java

public class CoinChangeTest {
    CoinChange CoinChange = new CoinChange();

    @Test
    void Example1() {
        int[] coins = {1, 2, 5};
        int amount = 11;
        int results = CoinChange.coinChange(coins, amount);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] coins = {2};
        int amount = 3;
        int results = CoinChange.coinChange(coins, amount);
        int expectedResults = -1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] coins = {1};
        int amount = 0;
        int results = CoinChange.coinChange(coins, amount);
        int expectedResults = 0;

=== Chunk 687 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0322.coin-change\CoinChangeTest.java

int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 688 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0326.power-of-three\PowerOfThree.java

class PowerOfThree {
    public boolean isPowerOfThree(int n) {
        if (n == 1) return true;
        if (n % 3 != 0 || n == 0) return false;
        return isPowerOfThree(n / 3);
    }
}

=== Chunk 689 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0326.power-of-three\PowerOfThreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 690 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0326.power-of-three\PowerOfThreeTest.java

public class PowerOfThreeTest {
    PowerOfThree PowerOfThree = new PowerOfThree();

    @Test
    void Example1() {
        int n = 27;
        boolean results = PowerOfThree.isPowerOfThree(n);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 0;
        boolean results = PowerOfThree.isPowerOfThree(n);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int n = 9;
        boolean results = PowerOfThree.isPowerOfThree(n);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {

=== Chunk 691 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0326.power-of-three\PowerOfThreeTest.java

}

    @Test
    void Example4() {
        int n = 1;
        boolean results = PowerOfThree.isPowerOfThree(n);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example5() {
        int n = 45;
        boolean results = PowerOfThree.isPowerOfThree(n);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 692 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0328.odd-even-linked-list\OddEvenLinkedList.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class OddEvenLinkedList {
    public ListNode oddEvenList(ListNode head) {
        if (head == null) return null;
        ListNode evenHead = head.next;
        ListNode odd = head, even = evenHead;
        while (even != null && even.next != null) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
}

=== Chunk 693 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0328.odd-even-linked-list\OddEvenLinkedListTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 694 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0328.odd-even-linked-list\OddEvenLinkedListTest.java

public class OddEvenLinkedListTest {
    OddEvenLinkedList OddEvenLinkedList = new OddEvenLinkedList();

    @Test
    void Example1() {
        ListNode firstNode = new ListNode(1);
        ListNode secondNode = new ListNode(2);
        ListNode thirdNode = new ListNode(3);
        ListNode forthNode = new ListNode(4);
        ListNode fifthNode = new ListNode(5);

        firstNode.next = secondNode;
        secondNode.next = thirdNode;
        thirdNode.next = forthNode;
        forthNode.next = fifthNode;

        ListNode results = OddEvenLinkedList.oddEvenList(firstNode);

        firstNode.next = thirdNode;
        thirdNode.next = fifthNode;
        fifthNode.next = secondNode;
        secondNode.next = forthNode;
        forthNode.next = null;

=== Chunk 695 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0328.odd-even-linked-list\OddEvenLinkedListTest.java

forthNode.next = null;

        Assertions.assertEquals(firstNode, results);
    }

    @Test
    void Example2() {
        ListNode firstNode = new ListNode(2);
        ListNode secondNode = new ListNode(1);
        ListNode thirdNode = new ListNode(3);
        ListNode forthNode = new ListNode(5);
        ListNode fifthNode = new ListNode(6);
        ListNode sixthNode = new ListNode(4);
        ListNode seventhNode = new ListNode(7);

        firstNode.next = secondNode;
        secondNode.next = thirdNode;
        thirdNode.next = forthNode;
        forthNode.next = fifthNode;
        fifthNode.next = sixthNode;
        sixthNode.next = seventhNode;

        ListNode results = OddEvenLinkedList.oddEvenList(firstNode);

=== Chunk 696 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0328.odd-even-linked-list\OddEvenLinkedListTest.java

firstNode.next = thirdNode;
        thirdNode.next = fifthNode;
        fifthNode.next = seventhNode;
        seventhNode.next = secondNode;
        secondNode.next = forthNode;
        forthNode.next = sixthNode;
        sixthNode.next = null;

        Assertions.assertEquals(firstNode, results);
    }
}

=== Chunk 697 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0334.increasing-triplet-subsequence\IncreasingTripletSubsequence.java

class IncreasingTripletSubsequence {
    public boolean increasingTriplet(int[] nums) {
        int min = Integer.MAX_VALUE, secondMin = Integer.MAX_VALUE;
        for (int num : nums) {
            if (num <= min) min = num;
            else if (num < secondMin) secondMin = num;
            else if (num > secondMin) return true;
        }
        return false;
    }
}

=== Chunk 698 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0334.increasing-triplet-subsequence\IncreasingTripletSubsequenceTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 699 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0334.increasing-triplet-subsequence\IncreasingTripletSubsequenceTest.java

public class IncreasingTripletSubsequenceTest {
    IncreasingTripletSubsequence IncreasingTripletSubsequence = new IncreasingTripletSubsequence();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3, 4, 5};
        boolean results = IncreasingTripletSubsequence.increasingTriplet(nums);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {5, 4, 3, 2, 1};
        boolean results = IncreasingTripletSubsequence.increasingTriplet(nums);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {2, 1, 5, 0, 4, 6};

=== Chunk 700 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0334.increasing-triplet-subsequence\IncreasingTripletSubsequenceTest.java

int[] nums = {2, 1, 5, 0, 4, 6};
        boolean results = IncreasingTripletSubsequence.increasingTriplet(nums);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 701 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0336.palindrome-pairs\PalindromePairs.java

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

=== Chunk 702 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0336.palindrome-pairs\PalindromePairs.java

class PalindromePairs {
    private boolean isPalindrome(String s) {
        int i = 0, j = s.length() - 1;
        while (i <= j) {
            if (s.charAt(i++) != s.charAt(j--)) return false;
        }
        return true;
    }

    public List<List<Integer>> palindromePairs(String[] words) {
        List<List<Integer>> res = new ArrayList<>();
        if (words == null || words.length == 0) return res;

        HashMap<String, Integer> map = new HashMap<>();
        for (int i = 0; i < words.length; i++) {
            map.put(new StringBuilder(words[i]).reverse().toString(), i);
        }

        if (map.containsKey("")) {
            int blankIdx = map.get("");
            for (int i = 0; i < words.length; i++) {

=== Chunk 703 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0336.palindrome-pairs\PalindromePairs.java

if (i != blankIdx && isPalindrome(words[i])) {
                    res.add(Arrays.asList(blankIdx, i));
                    res.add(Arrays.asList(i, blankIdx));
                }
            }
        }

        for (int i = 0; i < words.length; i++) {
            Integer reverseIdx = map.get(words[i]);
            if (reverseIdx != null && reverseIdx != i) {
                res.add(Arrays.asList(i, reverseIdx));
            }
        }

        for (int i = 0; i < words.length; i++) {
            String cur = words[i];
            for (int cut = 1; cut < cur.length(); cut++) {
                String left = cur.substring(0, cut);
                String right = cur.substring(cut);

                if (map.containsKey(right) && isPalindrome(left)) {

=== Chunk 704 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0336.palindrome-pairs\PalindromePairs.java

res.add(Arrays.asList(map.get(right), i));
                }

                if (map.containsKey(left) && isPalindrome(right)) {
                    res.add(Arrays.asList(i, map.get(left)));
                }
            }
        }

        return res;
    }
}

=== Chunk 705 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0336.palindrome-pairs\PalindromePairsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 706 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0336.palindrome-pairs\PalindromePairsTest.java

public class PalindromePairsTest {
    PalindromePairs PalindromePairs = new PalindromePairs();

    @Test
    void Example1() {
        String[] words = {"abcd","dcba","lls","s","sssll"};
        List<List<Integer>> results = PalindromePairs.palindromePairs(words);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(0, 1));
        expectedResults.add(Arrays.asList(1, 0));
        expectedResults.add(Arrays.asList(3, 2));
        expectedResults.add(Arrays.asList(2, 4));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String[] words = {"bat","tab","cat"};
        List<List<Integer>> results = PalindromePairs.palindromePairs(words);

=== Chunk 707 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0336.palindrome-pairs\PalindromePairsTest.java

List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(0, 1));
        expectedResults.add(Arrays.asList(1, 0));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String[] words = {"a",""};
        List<List<Integer>> results = PalindromePairs.palindromePairs(words);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(1, 0));
        expectedResults.add(Arrays.asList(0, 1));

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 708 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0337.house-robber-iii\HouseRobberIii.java

import java.util.HashMap;
import java.util.Map;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 709 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0337.house-robber-iii\HouseRobberIii.java

class HouseRobberIii {
    Map<TreeNode, Integer> cache = new HashMap<>();

    public int rob(TreeNode root) {
        if (root == null) return 0;
        if (cache.containsKey(root)) return cache.get(root);
        int val1 = root.val;
        if (root.left != null) val1 += rob(root.left.left) + rob(root.left.right);
        if (root.right != null) val1 += rob(root.right.left) + rob(root.right.right);
        int val2 = rob(root.left) + rob(root.right);
        int res = Math.max(val1, val2);
        cache.put(root, res);
        return res;
    }
}

=== Chunk 710 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0337.house-robber-iii\HouseRobberIiiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 711 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0337.house-robber-iii\HouseRobberIiiTest.java

public class HouseRobberIiiTest {
    HouseRobberIii HouseRobberIii = new HouseRobberIii();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(3);
        TreeNode forthNode = new TreeNode(3);
        TreeNode fifthNode = new TreeNode(1);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.right = forthNode;
        thirdNode.right = fifthNode;

        int results = HouseRobberIii.rob(firstNode);
        int expectedResult = 7;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(3);

=== Chunk 712 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0337.house-robber-iii\HouseRobberIiiTest.java

TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(4);
        TreeNode thirdNode = new TreeNode(5);
        TreeNode forthNode = new TreeNode(1);
        TreeNode fifthNode = new TreeNode(3);
        TreeNode sixthNode = new TreeNode(1);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        thirdNode.right = sixthNode;

        int results = HouseRobberIii.rob(firstNode);
        int expectedResult = 9;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 713 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0338.counting-bits\CountingBits.java

class CountingBits {
    public int[] countBits(int n) {
        int[] ret = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            ret[i] = ret[i & (i - 1)] + 1;
        }
        return ret;
    }
}

=== Chunk 714 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0338.counting-bits\CountingBitsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class CountingBitsTest {
    CountingBits CountingBits = new CountingBits();

    @Test
    void Example1() {
        int n = 2;
        int[] results = CountingBits.countBits(n);
        int[] expectedResults = {0, 1, 1};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 5;
        int[] results = CountingBits.countBits(n);
        int[] expectedResults = {0, 1, 1, 2, 1, 2};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 715 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0342.power-of-four\PowerOfFour.java

class PowerOfFour {
    public boolean isPowerOfFour(int n) {
        return n > 0 && (n & (n - 1)) == 0 && (n & 0b01010101010101010101010101010101) != 0;
    }
}

=== Chunk 716 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0342.power-of-four\PowerOfFourTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 717 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0342.power-of-four\PowerOfFourTest.java

public class PowerOfFourTest {
    PowerOfFour PowerOfFour = new PowerOfFour();

    @Test
    void Example1() {
        int n = 16;
        boolean results = PowerOfFour.isPowerOfFour(n);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 5;
        boolean results = PowerOfFour.isPowerOfFour(n);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int n = 1;
        boolean results = PowerOfFour.isPowerOfFour(n);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 718 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0344.reverse-string\ReverseString.java

class ReverseString {
    public void reverseString(char[] s) {
        int l = 0, r = s.length - 1;
        while (l < r) {
            char temp = s[r];
            s[r] = s[l];
            s[l] = temp;
            l++;
            r--;
        }
    }
}

=== Chunk 719 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0344.reverse-string\ReverseStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ReverseStringTest {
    ReverseString ReverseString = new ReverseString();

    @Test
    void Example1() {
        char[] s = {'h', 'e', 'l', 'l', 'o'};
        ReverseString.reverseString(s);
        char[] expectedResults = {'o', 'l', 'l', 'e', 'h'};

        Assertions.assertArrayEquals(expectedResults, s);
    }

    @Test
    void Example2() {
        char[] s = {'H', 'a', 'n', 'n', 'a', 'h'};
        ReverseString.reverseString(s);
        char[] expectedResults = {'h', 'a', 'n', 'n', 'a', 'H'};

        Assertions.assertArrayEquals(expectedResults, s);
    }
}

=== Chunk 720 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0345.reverse-vowels-of-a-string\ReverseVowelsOfAString.java

import java.util.Arrays;
import java.util.HashSet;

=== Chunk 721 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0345.reverse-vowels-of-a-string\ReverseVowelsOfAString.java

class ReverseVowelsOfAString {
    private final static HashSet<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));

    public String reverseVowels(String s) {
        if (s == null) return null;

        int i = 0, j = s.length() - 1;
        char[] result = new char[s.length()];
        while (i <= j) {
            char ci = s.charAt(i);
            char cj = s.charAt(j);
            if (!vowels.contains(ci)) {
                result[i++] = ci;
            } else if (!vowels.contains(cj)) {
                result[j--] = cj;
            } else {
                result[i++] = cj;
                result[j--] = ci;
            }
        }

        return new String(result);
    }
}

=== Chunk 722 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0345.reverse-vowels-of-a-string\ReverseVowelsOfAStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ReverseVowelsOfAStringTest {
    ReverseVowelsOfAString reverseVowelsOfAString = new ReverseVowelsOfAString();

    @Test
    void Example1() {
        String s = "hello";
        String expectedResults = "holle";

        String results;

        results = reverseVowelsOfAString.reverseVowels(s);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "leetcode";
        String expectedResults = "leotcede";

        String results;

        results = reverseVowelsOfAString.reverseVowels(s);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 723 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0347.top-k-frequent-elements\TopKFrequentElements.java

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

=== Chunk 724 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0347.top-k-frequent-elements\TopKFrequentElements.java

class TopKFrequentElements {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> frequencyForNum = new HashMap<>();
        for (int num : nums) {
            frequencyForNum.put(num, frequencyForNum.getOrDefault(num, 0) + 1);
        }
        List<Integer>[] buckets = new ArrayList[nums.length + 1];
        for (int key : frequencyForNum.keySet()) {
            int frequency = frequencyForNum.get(key);
            if (buckets[frequency] == null) {
                buckets[frequency] = new ArrayList<>();
            }
            buckets[frequency].add(key);
        }
        List<Integer> topK = new ArrayList<>();
        for (int i = buckets.length - 1; i >= 0 && topK.size() < k; i--) {
            if (buckets[i] == null) {

=== Chunk 725 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0347.top-k-frequent-elements\TopKFrequentElements.java

if (buckets[i] == null) {
                continue;
            }
            if (buckets[i].size() <= (k - topK.size())) {
                topK.addAll(buckets[i]);
            } else {
                topK.addAll(buckets[i].subList(0, k- topK.size()));
            }
        }
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = topK.get(i);
        }
        return res;
    }
}

=== Chunk 726 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0347.top-k-frequent-elements\TopKFrequentElementsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class TopKFrequentElementsTest {
    TopKFrequentElements TopKFrequentElements = new TopKFrequentElements();

    @Test
    void Example1() {
        int[] nums = {1, 1, 1, 2, 2, 3};
        int k = 2;

        int[] results = TopKFrequentElements.topKFrequent(nums, k);
        int[] expectedResults = {1, 2};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1};
        int k = 1;

        int[] results = TopKFrequentElements.topKFrequent(nums, k);
        int[] expectedResults = {1};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 727 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0352.data-stream-as-disjoint-intervals\DataStreamAsDisjointIntervals.java

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

=== Chunk 728 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0352.data-stream-as-disjoint-intervals\DataStreamAsDisjointIntervals.java

class SummaryRanges {
    private final Set<Integer> values;

    public SummaryRanges() {
        values = new TreeSet<>();
    }
    
    public void addNum(int value) {
        values.add(value);
    }
    
    public int[][] getIntervals() {
        if (values.isEmpty())
            return new int[0][2];
        List<int[]> intervals = new ArrayList<>();
        int left = -1, right = -1;
        for (Integer value : values) {
            if (left < 0)
                left = right = value;
            else if (value == right + 1)
                right = value;
            else {
                intervals.add(new int[]{left, right});
                left = right = value;
            }
        }
        intervals.add(new int[]{left, right});

=== Chunk 729 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0352.data-stream-as-disjoint-intervals\DataStreamAsDisjointIntervals.java

intervals.add(new int[]{left, right});
        return intervals.toArray(new int[0][]);
    }
}

/**
 * Your SummaryRanges object will be instantiated and called as such:
 * SummaryRanges obj = new SummaryRanges();
 * obj.addNum(value);
 * int[][] param_2 = obj.getIntervals();
 */

=== Chunk 730 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0352.data-stream-as-disjoint-intervals\DataStreamAsDisjointIntervalsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 731 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0352.data-stream-as-disjoint-intervals\DataStreamAsDisjointIntervalsTest.java

public class DataStreamAsDisjointIntervalsTest {
    @Test
    void Example1() {
        SummaryRanges summaryRanges = new SummaryRanges();
        summaryRanges.addNum(1);
        Assertions.assertArrayEquals(new int[][]{{1, 1}}, summaryRanges.getIntervals());
        summaryRanges.addNum(3);
        Assertions.assertArrayEquals(new int[][]{{1, 1}, {3, 3}}, summaryRanges.getIntervals());
        summaryRanges.addNum(7);
        Assertions.assertArrayEquals(new int[][]{{1, 1}, {3, 3}, {7, 7}}, summaryRanges.getIntervals());
        summaryRanges.addNum(2);
        Assertions.assertArrayEquals(new int[][]{{1, 3}, {7, 7}}, summaryRanges.getIntervals());
        summaryRanges.addNum(6);

=== Chunk 732 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0352.data-stream-as-disjoint-intervals\DataStreamAsDisjointIntervalsTest.java

summaryRanges.addNum(6);
        Assertions.assertArrayEquals(new int[][]{{1, 3}, {6, 7}}, summaryRanges.getIntervals());
    }
}

=== Chunk 733 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0363.max-sum-of-rectangle-no-larger-than-k\MaxSumOfRectangleNoLargerThanK.java

import java.util.TreeSet;

=== Chunk 734 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0363.max-sum-of-rectangle-no-larger-than-k\MaxSumOfRectangleNoLargerThanK.java

class MaxSumOfRectangleNoLargerThanK {
    private int find(int[] sum, int k) {
        int res = Integer.MIN_VALUE;
        TreeSet<Integer> set = new TreeSet<>();
        set.add(0);
        int prefixSum = 0;
        for (int j : sum) {
            prefixSum += j;
            Integer target = set.ceiling(prefixSum - k);
            if (target != null) res = Math.max(res, prefixSum - target);
            set.add(prefixSum);
        }
        return res;
    }

    public int maxSumSubmatrix(int[][] matrix, int k) {
        int row = matrix.length;
        int col = matrix[0].length;
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < row; i++) {
            int[] colSum = new int[col];
            for (int j = i; j < row; j++) {

=== Chunk 735 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0363.max-sum-of-rectangle-no-larger-than-k\MaxSumOfRectangleNoLargerThanK.java

for (int j = i; j < row; j++) {
                for (int c = 0; c < col; c++) {
                    colSum[c] += matrix[j][c];
                }
                max = Math.max(max, find(colSum, k));
            }
        }
        return max;
    }
}

=== Chunk 736 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0363.max-sum-of-rectangle-no-larger-than-k\MaxSumOfRectangleNoLargerThanKTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 737 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0363.max-sum-of-rectangle-no-larger-than-k\MaxSumOfRectangleNoLargerThanKTest.java

public class MaxSumOfRectangleNoLargerThanKTest {
    MaxSumOfRectangleNoLargerThanK MaxSumOfRectangleNoLargerThanK = new MaxSumOfRectangleNoLargerThanK();

    @Test
    void Example1() {
        int[][] matrix = {{1, 0, 1}, {0, -2, 3}};
        int k = 2;
        int results = MaxSumOfRectangleNoLargerThanK.maxSumSubmatrix(matrix, k);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] matrix = {{2, 2, -1}};
        int k = 3;
        int results = MaxSumOfRectangleNoLargerThanK.maxSumSubmatrix(matrix, k);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 738 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0371.sum-of-two-integers\SumOfTwoIntegers.java

class SumOfTwoIntegers {
    public int getSum(int a, int b) {
        return b == 0 ? a : getSum((a ^ b), (a & b) << 1);
    }
}

=== Chunk 739 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0371.sum-of-two-integers\SumOfTwoIntegersTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SumOfTwoIntegersTest {
    SumOfTwoIntegers SumOfTwoIntegers = new SumOfTwoIntegers();

    @Test
    void Example1() {
        int a = 1, b = 2;
        int results = SumOfTwoIntegers.getSum(a, b);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int a = 2, b = 3;
        int results = SumOfTwoIntegers.getSum(a, b);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 740 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0374.guess-number-higher-or-lower\GuessGame.java

public class GuessGame {
    private int n = 0;

    void init(int pick) {
        n = pick;
    }

    int guess(int num) {
        return Integer.compare(n, num);
    }
}

=== Chunk 741 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0374.guess-number-higher-or-lower\GuessNumberHigherOrLower.java

// **
// * Forward declaration of guess API.
// * @param  num   your guess
// * @return 	     -1 if num is higher than the picked number
// *			      1 if num is lower than the picked number
// *               otherwise return 0
// * int guess(int num);
// */

public class GuessNumberHigherOrLower extends GuessGame {
    public int guessNumber(int n, int pick) {
        init(pick);
        int low = 0, high = n;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            int res = guess(mid);
            if (res == 0)
                return mid;
            else if (res < 0)
                high = mid - 1;
            else
                low = mid + 1;
        }
        return -1;
    }
}

=== Chunk 742 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0374.guess-number-higher-or-lower\GuessNumberHigherOrLowerTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class GuessNumberHigherOrLowerTest {
    GuessNumberHigherOrLower GuessNumberHigherOrLower = new GuessNumberHigherOrLower();

    @Test
    void Example1() {
        int n = 10, pick = 6;
        int results = GuessNumberHigherOrLower.guessNumber(n, pick);

        Assertions.assertEquals(pick, results);
    }

    @Test
    void Example2() {
        int n = 1, pick = 1;
        int results = GuessNumberHigherOrLower.guessNumber(n, pick);

        Assertions.assertEquals(pick, results);
    }

    @Test
    void Example3() {
        int n = 2, pick = 1;
        int results = GuessNumberHigherOrLower.guessNumber(n, pick);

        Assertions.assertEquals(pick, results);
    }
}

=== Chunk 743 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0376.wiggle-subsequence\WiggleSubsequence.java

class WiggleSubsequence {
    public int wiggleMaxLength(int[] nums) {
        if (nums.length < 2) {
            return nums.length;
        }
        int up = 1, down = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > nums[i - 1]) {
                up = down + 1;
            } else if (nums[i] < nums[i - 1]) {
                down = up + 1;
            }
        }
        return Math.max(up, down);
    }
}

=== Chunk 744 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0376.wiggle-subsequence\WiggleSubsequenceTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 745 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0376.wiggle-subsequence\WiggleSubsequenceTest.java

public class WiggleSubsequenceTest {
    WiggleSubsequence WiggleSubsequence = new WiggleSubsequence();

    @Test
    void Example1() {
        int[] nums = {1, 7, 4, 9, 2, 5};
        int results = WiggleSubsequence.wiggleMaxLength(nums);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 17, 5, 10, 13, 15, 10, 5, 16, 8};
        int results = WiggleSubsequence.wiggleMaxLength(nums);
        int expectedResults = 7;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        int results = WiggleSubsequence.wiggleMaxLength(nums);
        int expectedResults = 2;

=== Chunk 746 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0376.wiggle-subsequence\WiggleSubsequenceTest.java

int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        int[] nums = {0, 0};
        int results = WiggleSubsequence.wiggleMaxLength(nums);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example5() {
        int[] nums = {3, 3, 3, 2, 5};
        int results = WiggleSubsequence.wiggleMaxLength(nums);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 747 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0377.combination-sum-iv\CombinationSumIv.java

import java.util.HashMap;

class CombinationSumIv {
    public int combinationSum4(int[] nums, int target) {
        HashMap<Integer, Integer> dp = new HashMap<>();
        dp.put(0, 1);
        for (int i = 1; i < target + 1; i++) {
            dp.put(i, 0);
            for (int num : nums) {
                int total = dp.get(i) + dp.getOrDefault(i - num, 0);
                dp.put(i, total);
            }
        }
        return dp.get(target);
    }
}

=== Chunk 748 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0377.combination-sum-iv\CombinationSumIv2.java

import java.util.Arrays;

class CombinationSumIv2 {
    private int[] dp;

    private int helper(int[] nums, int target) {
        if (dp[target] != -1) return dp[target];
        int res = 0;
        for (int num : nums) {
            if (target >= num) {
                res += helper(nums, target - num);
            }
        }
        return dp[target] = res;
    }

    public int combinationSum4(int[] nums, int target) {
        dp = new int[target + 1];
        Arrays.fill(dp, -1);
        dp[0] = 1;
        return helper(nums, target);
    }
}

=== Chunk 749 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0377.combination-sum-iv\CombinationSumIvTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 750 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0377.combination-sum-iv\CombinationSumIvTest.java

public class CombinationSumIvTest {
    CombinationSumIv CombinationSumIv = new CombinationSumIv();
    CombinationSumIv2 CombinationSumIv2 = new CombinationSumIv2();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3};
        int target = 4;
        int results = CombinationSumIv.combinationSum4(nums, target);
        int expectedResults = 7;

        Assertions.assertEquals(expectedResults, results);

        results = CombinationSumIv2.combinationSum4(nums, target);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {9};
        int target = 3;
        int results = CombinationSumIv.combinationSum4(nums, target);
        int expectedResults = 0;

=== Chunk 751 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0377.combination-sum-iv\CombinationSumIvTest.java

int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);

        results = CombinationSumIv2.combinationSum4(nums, target);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 752 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0378.kth-smallest-element-in-a-sorted-matrix\KthSmallestElementInASortedMatrix.java

class KthSmallestElementInASortedMatrix {
    public int kthSmallest(int[][] matrix, int k) {
        int m = matrix.length, n = matrix[0].length;
        int lo = matrix[0][0], hi = matrix[m - 1][n - 1];
        while (lo <= hi) {
            int mid = lo + (hi - lo) / 2;
            int cnt = 0;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n && matrix[i][j] <= mid; j++) {
                    cnt++;
                }
            }
            if (cnt < k) lo = mid + 1;
            else hi = mid - 1;
        }
        return lo;
    }
}

=== Chunk 753 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0378.kth-smallest-element-in-a-sorted-matrix\KthSmallestElementInASortedMatrix2.java

import java.util.PriorityQueue;

class KthSmallestElementInASortedMatrix2 {
    public int kthSmallest(int[][] matrix, int k) {
        int m = matrix.length, n = matrix[0].length;
        PriorityQueue<Tuple> pq = new PriorityQueue<Tuple>();
        for (int j = 0; j < n; j++) pq.offer(new Tuple(0, j, matrix[0][j]));
        for (int i = 0; i < k - 1; i++) {
            Tuple t = pq.poll();
            if (t != null && t.x == m - 1) continue;
            if (t != null) {
                pq.offer(new Tuple(t.x + 1, t.y, matrix[t.x + 1][t. y]));
            }
        }
        return pq.poll().val;
    }
}

=== Chunk 754 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0378.kth-smallest-element-in-a-sorted-matrix\KthSmallestElementInASortedMatrix2.java

class Tuple implements Comparable<Tuple> {
    int x, y, val;
    public Tuple(int x, int y, int val) {
        this.x = x; this.y = y; this.val = val;
    }

    @Override
    public int compareTo(Tuple that) {
        return this.val - that.val;
    }
}

=== Chunk 755 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0378.kth-smallest-element-in-a-sorted-matrix\KthSmallestElementInASortedMatrixTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 756 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0378.kth-smallest-element-in-a-sorted-matrix\KthSmallestElementInASortedMatrixTest.java

public class KthSmallestElementInASortedMatrixTest {
    KthSmallestElementInASortedMatrix KthSmallestElementInASortedMatrix = new KthSmallestElementInASortedMatrix();
    KthSmallestElementInASortedMatrix2 KthSmallestElementInASortedMatrix2 = new KthSmallestElementInASortedMatrix2();

    @Test
    void Example1() {
        int[][] matrix = {{1,5,9},{10,11,13},{12,13,15}};

        int k = 8;
        int results = KthSmallestElementInASortedMatrix.kthSmallest(matrix, k);
        int expectedResults = 13;

        Assertions.assertEquals(expectedResults, results);

        results = KthSmallestElementInASortedMatrix2.kthSmallest(matrix, k);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {

=== Chunk 757 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0378.kth-smallest-element-in-a-sorted-matrix\KthSmallestElementInASortedMatrixTest.java

}

    @Test
    void Example2() {
        int[][] matrix = {{-5}};

        int k = 1;
        int results = KthSmallestElementInASortedMatrix.kthSmallest(matrix, k);
        int expectedResults = -5;

        Assertions.assertEquals(expectedResults, results);

        results = KthSmallestElementInASortedMatrix2.kthSmallest(matrix, k);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 758 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0380.insert-delete-getrandom-o1\InsertDeleteGetrandomO1.java

import java.util.*;

=== Chunk 759 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0380.insert-delete-getrandom-o1\InsertDeleteGetrandomO1.java

class RandomizedSet {
    List<Integer> nums;
    Map<Integer, Integer> indices;
    Random random;

    public RandomizedSet() {
        nums = new ArrayList<>();
        indices = new HashMap<>();
        random = new Random();
    }

    public boolean insert(int val) {
        if (indices.containsKey(val))
            return false;
        int index = nums.size();
        nums.add(val);
        indices.put(val, index);
        return true;
    }

    public boolean remove(int val) {
        if (!indices.containsKey(val))
            return false;
        int index = indices.get(val);
        int last = nums.get(nums.size() - 1);
        nums.set(index, last);
        indices.put(last, index);
        nums.remove(nums.size() - 1);

=== Chunk 760 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0380.insert-delete-getrandom-o1\InsertDeleteGetrandomO1.java

nums.remove(nums.size() - 1);
        indices.remove(val);
        return true;
    }

    public int getRandom() {
        int randomIndex = random.nextInt(nums.size());
        return nums.get(randomIndex);
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */

=== Chunk 761 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0380.insert-delete-getrandom-o1\InsertDeleteGetrandomO1Test.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;


public class InsertDeleteGetrandomO1Test {
    @Test
    void Example1() {
        RandomizedSet randomizedSet = new RandomizedSet();
        Assertions.assertTrue(randomizedSet.insert(1));
        Assertions.assertFalse(randomizedSet.remove(2));
        Assertions.assertTrue(randomizedSet.insert(2));
        int random = randomizedSet.getRandom();
        Assertions.assertTrue(random >= 1, "Error, should be 1 or 2");
        Assertions.assertTrue(random <= 2, "Error, should be 1 or 2");
        Assertions.assertTrue(randomizedSet.remove(1));
        Assertions.assertFalse(randomizedSet.insert(2));
        Assertions.assertEquals(2, randomizedSet.getRandom());
    }
}

=== Chunk 762 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0383.ransom-note\RansomNote.java

import java.util.HashMap;
import java.util.Map;

class RansomNote {
    public boolean canConstruct(String ransomNote, String magazine) {
        Map<Character, Integer> map = new HashMap<>();
        for (char c : magazine.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        for (char c : ransomNote.toCharArray()) {
            if (!map.containsKey(c) || map.get(c) == 0) {
                return false;
            }
            map.put(c, map.get(c) - 1);
        }
        return true;
    }
}

=== Chunk 763 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0383.ransom-note\RansomNoteTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 764 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0383.ransom-note\RansomNoteTest.java

public class RansomNoteTest {
    RansomNote RansomNote = new RansomNote();

    @Test
    void Example1() {
        String ransomNote = "a", magazine = "b";
        boolean results = RansomNote.canConstruct(ransomNote, magazine);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String ransomNote = "aa", magazine = "ab";
        boolean results = RansomNote.canConstruct(ransomNote, magazine);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String ransomNote = "aa", magazine = "aab";
        boolean results = RansomNote.canConstruct(ransomNote, magazine);

=== Chunk 765 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0383.ransom-note\RansomNoteTest.java

boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 766 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0387.first-unique-character-in-a-string\FirstUniqueCharacterInAString.java

class FirstUniqueCharacterInAString {
    public int firstUniqChar(String s) {
        int res = Integer.MAX_VALUE;
        for (int i = 'a'; i <= 'z'; i++) {
            int index = s.indexOf(i);
            if (index != -1 && index == s.lastIndexOf(i)) {
                res = Math.min(res, index);
            }
        }
        if (res == Integer.MAX_VALUE) return -1;
        return res;
    }
}

=== Chunk 767 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0387.first-unique-character-in-a-string\FirstUniqueCharacterInAStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 768 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0387.first-unique-character-in-a-string\FirstUniqueCharacterInAStringTest.java

public class FirstUniqueCharacterInAStringTest {
    FirstUniqueCharacterInAString FirstUniqueCharacterInAString = new FirstUniqueCharacterInAString();

    @Test
    void Example1() {
        String s = "leetcode";
        int results = FirstUniqueCharacterInAString.firstUniqChar(s);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "loveleetcode";
        int results = FirstUniqueCharacterInAString.firstUniqChar(s);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "aabb";
        int results = FirstUniqueCharacterInAString.firstUniqChar(s);

=== Chunk 769 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0387.first-unique-character-in-a-string\FirstUniqueCharacterInAStringTest.java

int expectedResults = -1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 770 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0392.is-subsequence\IsSubsequence.java

class IsSubsequence {
    public boolean isSubsequence(String s, String t) {
        int index = -1;
        for (char c : s.toCharArray()) {
            index = t.indexOf(c, index + 1);
            if (index == -1) return false;
        }
        return true;
    }
}

=== Chunk 771 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0392.is-subsequence\IsSubsequenceTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class IsSubsequenceTest {
    IsSubsequence IsSubsequence = new IsSubsequence();

    @Test
    void Example1() {
        String s = "abc", t = "ahbgdc";
        boolean results = IsSubsequence.isSubsequence(s, t);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "axc", t = "ahbgdc";
        boolean results = IsSubsequence.isSubsequence(s, t);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 772 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0393.utf-8-validation\Utf8Validation.java

class Utf8Validation {
    public boolean validUtf8(int[] data) {
        int numberOfBytesToProcess = 0;
        int mask1 = 1 << 7;
        int mask2 = 1 << 6;

        for (int datum : data) {
            if (numberOfBytesToProcess == 0) {
                int mask = 1 << 7;
                while ((mask & datum) != 0) {
                    numberOfBytesToProcess += 1;
                    mask = mask >> 1;
                }

                if (numberOfBytesToProcess == 0) {
                    continue;
                }

                if (numberOfBytesToProcess > 4 || numberOfBytesToProcess == 1) {
                    return false;
                }
            } else {
                if (!((datum & mask1) != 0 && (mask2 & datum) == 0)) {

=== Chunk 773 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0393.utf-8-validation\Utf8Validation.java

return false;
                }
            }
            numberOfBytesToProcess -= 1;
        }
        return numberOfBytesToProcess == 0;
    }
}

=== Chunk 774 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0393.utf-8-validation\Utf8ValidationTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class Utf8ValidationTest {
    Utf8Validation Utf8Validation = new Utf8Validation();

    @Test
    void Example1() {
        int[] data = {197, 130, 1};
        boolean results = Utf8Validation.validUtf8(data);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] data = {235, 140, 4};
        boolean results = Utf8Validation.validUtf8(data);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 775 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0394.decode-string\DecodeString.java

import java.util.Stack;

=== Chunk 776 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0394.decode-string\DecodeString.java

class DecodeString {
    public String decodeString(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c != ']') {
                stack.push(c);
            } else {
                StringBuilder sb = new StringBuilder();
                while (!stack.isEmpty() && Character.isLetter(stack.peek()))
                    sb.insert(0, stack.pop());
                String sub = sb.toString();
                stack.pop();
                sb = new StringBuilder();
                while (!stack.isEmpty() && Character.isDigit(stack.peek()))
                    sb.insert(0, stack.pop());
                int count = Integer.parseInt(sb.toString());
                while (count > 0) {

=== Chunk 777 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0394.decode-string\DecodeString.java

while (count > 0) {
                    for (char ch : sub.toCharArray())
                        stack.push(ch);
                    count--;
                }
            }
        }
        StringBuilder res = new StringBuilder();
        while (!stack.isEmpty())
            res.insert(0, stack.pop());
        return res.toString();
    }
}

=== Chunk 778 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0394.decode-string\DecodeStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 779 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0394.decode-string\DecodeStringTest.java

public class DecodeStringTest {
    DecodeString DecodeString = new DecodeString();

    @Test
    void Example1() {
        String s = "3[a]2[bc]";
        String results = DecodeString.decodeString(s);
        String expectedResults = "aaabcbc";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "3[a2[c]]";
        String results = DecodeString.decodeString(s);
        String expectedResults = "accaccacc";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "2[abc]3[cd]ef";
        String results = DecodeString.decodeString(s);
        String expectedResults = "abcabccdcdcdef";

=== Chunk 780 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0394.decode-string\DecodeStringTest.java

Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 781 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0404.sum-of-left-leaves\SumOfLeftLeaves.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 782 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0404.sum-of-left-leaves\SumOfLeftLeaves.java

class SumOfLeftLeaves {
    private boolean isLeaf(TreeNode root) {
        if (root == null) return false;
        return root.left == null && root.right == null;
    }

    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        if (isLeaf(root.left)) return root.left.val + sumOfLeftLeaves(root.right);
        return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
    }
}

=== Chunk 783 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0404.sum-of-left-leaves\SumOfLeftLeavesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 784 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0404.sum-of-left-leaves\SumOfLeftLeavesTest.java

public class SumOfLeftLeavesTest {
    SumOfLeftLeaves SumOfLeftLeaves = new SumOfLeftLeaves();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(9);
        TreeNode thirdNode = new TreeNode(20);
        TreeNode forthNode = new TreeNode(15);
        TreeNode fifthNode = new TreeNode(7);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        thirdNode.left = forthNode;
        thirdNode.right = fifthNode;

        int results = SumOfLeftLeaves.sumOfLeftLeaves(firstNode);
        int expectedResult = 24;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(1);

=== Chunk 785 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0404.sum-of-left-leaves\SumOfLeftLeavesTest.java

TreeNode firstNode = new TreeNode(1);

        int results = SumOfLeftLeaves.sumOfLeftLeaves(firstNode);
        int expectedResult = 0;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 786 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0406.queue-reconstruction-by-height\QueueReconstructionByHeight.java

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class QueueReconstructionByHeight {
    public int[][] reconstructQueue(int[][] people) {
        if (people == null || people.length == 0 || people[0].length == 0) {
            return new int[0][0];
        }
        Arrays.sort(people, (a, b) -> (a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]));
        List<int[]> queue = new ArrayList<>();
        for (int[] p : people) {
            queue.add(p[1], p);
        }
        return queue.toArray(new int[queue.size()][]);
    }
}

=== Chunk 787 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0406.queue-reconstruction-by-height\QueueReconstructionByHeightTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 788 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0406.queue-reconstruction-by-height\QueueReconstructionByHeightTest.java

public class QueueReconstructionByHeightTest {
    QueueReconstructionByHeight QueueReconstructionByHeight = new QueueReconstructionByHeight();

    @Test
    void Example1() {
        int[][] people = {{7, 0}, {4, 4}, {7, 1}, {5, 0}, {6, 1}, {5, 2}};
        int[][] results = QueueReconstructionByHeight.reconstructQueue(people);
        int[][] expectedResults = {{5, 0}, {7, 0}, {5, 2}, {6, 1}, {4, 4}, {7, 1}};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] people = {{6, 0}, {5, 0}, {4, 0}, {3, 2}, {2, 2}, {1, 4}};
        int[][] results = QueueReconstructionByHeight.reconstructQueue(people);
        int[][] expectedResults = {{4, 0}, {5, 0}, {2, 2}, {3, 2}, {1, 4}, {6, 0}};

=== Chunk 789 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0406.queue-reconstruction-by-height\QueueReconstructionByHeightTest.java

Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 790 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0409.longest-palindrome\LongestPalindrome.java

public class LongestPalindrome {
    public int longestPalindrome(String s) {
        int[] cnts = new int[256];
        for (char c : s.toCharArray()) {
            cnts[c]++;
        }
        int palindrome = 0;
        for (int cnt : cnts) {
            palindrome += (cnt / 2) * 2;
        }
        if (palindrome < s.length()) {
            palindrome++;
        }
        return palindrome;
    }
}

=== Chunk 791 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0409.longest-palindrome\LongestPalindromeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 792 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0409.longest-palindrome\LongestPalindromeTest.java

public class LongestPalindromeTest {
    LongestPalindrome LongestPalindrome = new LongestPalindrome();

    @Test
    void Example1() {
        String s = "abccccdd";

        int results = LongestPalindrome.longestPalindrome(s);
        int expectedResults = 7;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "a";

        int results = LongestPalindrome.longestPalindrome(s);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "bb";

        int results = LongestPalindrome.longestPalindrome(s);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);

=== Chunk 793 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0409.longest-palindrome\LongestPalindromeTest.java

}
}

=== Chunk 794 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0416.partition-equal-subset-sum\PartitionEqualSubsetSum.java

class PartitionEqualSubsetSum {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        int n = nums.length;
        for (int num : nums) sum += num;
        if (sum % 2 != 0) return false;
        sum /= 2;
        boolean[][] dp = new boolean[n + 1][sum + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= sum; j++) {
                if (i == 0 || j == 0) dp[i][j] = false;
                else if (nums[i - 1] > j) dp[i][j] = dp[i - 1][j];
                else if (nums[i - 1] == j) dp[i][j] = true;
                else dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
            }
        }
        return dp[n][sum];
    }
}

=== Chunk 795 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0416.partition-equal-subset-sum\PartitionEqualSubsetSumTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class PartitionEqualSubsetSumTest {
    PartitionEqualSubsetSum PartitionEqualSubsetSum = new PartitionEqualSubsetSum();

    @Test
    void Example1() {
        int[] nums = {1, 5, 11, 5};
        boolean results = PartitionEqualSubsetSum.canPartition(nums);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 2, 3, 5};
        boolean results = PartitionEqualSubsetSum.canPartition(nums);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 796 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0417.pacific-atlantic-water-flow\PacificAtlanticWaterFlow.java

import java.util.*;

=== Chunk 797 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0417.pacific-atlantic-water-flow\PacificAtlanticWaterFlow.java

class PacificAtlanticWaterFlow {
    private void dfs(int[][] heights, int r, int c, boolean[][] visit, int prevHeight) {
        if (r < 0 || c < 0 || r == heights.length || c == heights[0].length || visit[r][c] || heights[r][c] < prevHeight) return;
        visit[r][c] = true;
        dfs(heights, r + 1, c, visit, heights[r][c]);
        dfs(heights, r - 1, c, visit, heights[r][c]);
        dfs(heights, r, c + 1, visit, heights[r][c]);
        dfs(heights, r, c - 1, visit, heights[r][c]);
    }

    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        int rows = heights.length;
        int cols = heights[0].length;
        boolean[][] pac = new boolean[rows][cols];
        boolean[][] atl = new boolean[rows][cols];

=== Chunk 798 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0417.pacific-atlantic-water-flow\PacificAtlanticWaterFlow.java

for (int i = 0; i < cols; i++) {
            dfs(heights, 0, i, pac, heights[0][i]);
            dfs(heights, rows - 1, i, atl, heights[rows - 1][i]);
        }

        for (int i = 0; i < rows; i++) {
            dfs(heights, i, 0, pac, heights[i][0]);
            dfs(heights, i, cols - 1, atl, heights[i][cols - 1]);
        }

        List<List<Integer>> res = new ArrayList<>();
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (pac[i][j] && atl[i][j]) res.add(Arrays.asList(i, j));
            }
        }
        return res;
    }
}

=== Chunk 799 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0417.pacific-atlantic-water-flow\PacificAtlanticWaterFlowTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 800 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0417.pacific-atlantic-water-flow\PacificAtlanticWaterFlowTest.java

public class PacificAtlanticWaterFlowTest {
    PacificAtlanticWaterFlow PacificAtlanticWaterFlow = new PacificAtlanticWaterFlow();

    @Test
    void Example1() {
        int[][] heights = {{1, 2, 2, 3, 5}, {3, 2, 3, 4, 4}, {2, 4, 5, 3, 1}, {6, 7, 1, 4, 5}, {5, 1, 1, 2, 4}};
        List<List<Integer>> results = PacificAtlanticWaterFlow.pacificAtlantic(heights);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(0, 4));
        expectedResults.add(Arrays.asList(1, 3));
        expectedResults.add(Arrays.asList(1, 4));
        expectedResults.add(Arrays.asList(2, 2));
        expectedResults.add(Arrays.asList(3, 0));
        expectedResults.add(Arrays.asList(3, 1));
        expectedResults.add(Arrays.asList(4, 0));

=== Chunk 801 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0417.pacific-atlantic-water-flow\PacificAtlanticWaterFlowTest.java

Assertions.assertEquals(expectedResults,  results);
    }

    @Test
    void Example2() {
        int[][] heights = {{1}};
        List<List<Integer>> results = PacificAtlanticWaterFlow.pacificAtlantic(heights);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(0, 0));

        Assertions.assertEquals(expectedResults,  results);
    }
}

=== Chunk 802 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0424.longest-repeating-character-replacement\LongestRepeatingCharacterReplacement.java

class LongestRepeatingCharacterReplacement {
    public int characterReplacement(String s, int k) {
        int[] count = new int[26];
        int start = 0, maxCount = 0, maxLength = 0;
        for (int end = 0; end < s.length(); end++) {
            maxCount = Math.max(maxCount, ++count[s.charAt(end) - 'A']);
            while (end - start + 1 - maxCount > k) {
                count[s.charAt(start) - 'A']--;
                start++;
            }
            maxLength = Math.max(maxLength, end - start + 1);
        }
        return maxLength;
    }
}

=== Chunk 803 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0424.longest-repeating-character-replacement\LongestRepeatingCharacterReplacementTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 804 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0424.longest-repeating-character-replacement\LongestRepeatingCharacterReplacementTest.java

public class LongestRepeatingCharacterReplacementTest {
    LongestRepeatingCharacterReplacement LongestRepeatingCharacterReplacement = new LongestRepeatingCharacterReplacement();

    @Test
    void Example1() {
        String s = "ABAB";
        int k = 2;
        int results = LongestRepeatingCharacterReplacement.characterReplacement(s, k);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "AABABBA";
        int k = 1;
        int results = LongestRepeatingCharacterReplacement.characterReplacement(s, k);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 805 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0427.construct-quad-tree\ConstructQuadTree.java

/*
// Definition for a QuadTree node.

=== Chunk 806 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0427.construct-quad-tree\ConstructQuadTree.java

class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;

    
    public Node() {
        this.val = false;
        this.isLeaf = false;
        this.topLeft = null;
        this.topRight = null;
        this.bottomLeft = null;
        this.bottomRight = null;
    }
    
    public Node(boolean val, boolean isLeaf) {
        this.val = val;
        this.isLeaf = isLeaf;
        this.topLeft = null;
        this.topRight = null;
        this.bottomLeft = null;
        this.bottomRight = null;
    }
    
    public Node(boolean val, boolean isLeaf, Node topLeft, Node topRight, Node bottomLeft, Node bottomRight) {
        this.val = val;

=== Chunk 807 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0427.construct-quad-tree\ConstructQuadTree.java

this.val = val;
        this.isLeaf = isLeaf;
        this.topLeft = topLeft;
        this.topRight = topRight;
        this.bottomLeft = bottomLeft;
        this.bottomRight = bottomRight;
    }
};
*/

=== Chunk 808 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0427.construct-quad-tree\ConstructQuadTree.java

class ConstructQuadTree {
    public QuadNode construct(int[][] grid) {
        return dfs(grid, 0, 0, grid.length, grid.length);
    }

    public QuadNode dfs(int[][] grid, int r0, int c0, int r1, int c1) {
        boolean same = true;
        for (int i = r0; i < r1; i++) {
            for (int j = c0; j < c1; j++) {
                if (grid[i][j] != grid [r0][c0]) {
                    same = false;
                    break;
                }
            }
            if (!same) {
                break;
            }
        }

        if (same)
            return new QuadNode(grid[r0][c0] == 1, true);

        return new QuadNode(
                true,
                false,
                dfs(grid, r0, c0, (r0 + r1) / 2, (c0 + c1) / 2),

=== Chunk 809 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0427.construct-quad-tree\ConstructQuadTree.java

dfs(grid, r0, (c0 + c1) / 2, (r0 + r1) / 2, c1),
                dfs(grid, (r0 + r1) / 2, c0, r1, (c0 + c1) / 2),
                dfs(grid, (r0 + r1) / 2, (c0 + c1) / 2, r1, c1)
        );
    }
}

=== Chunk 810 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0427.construct-quad-tree\ConstructQuadTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 811 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0427.construct-quad-tree\ConstructQuadTreeTest.java

public class ConstructQuadTreeTest {
    ConstructQuadTree constructQuadTree = new ConstructQuadTree();

    @Test
    void Example1() {
        int[][] grid = {{0, 1}, {1, 0}};
        QuadNode root = constructQuadTree.construct(grid);

        Assertions.assertTrue(root.val);
        Assertions.assertFalse(root.isLeaf);
        Assertions.assertFalse(root.topLeft.val);
        Assertions.assertTrue(root.topLeft.isLeaf);
        Assertions.assertTrue(root.topRight.val);
        Assertions.assertTrue(root.topRight.isLeaf);
        Assertions.assertTrue(root.bottomLeft.val);
        Assertions.assertTrue(root.bottomLeft.isLeaf);
        Assertions.assertFalse(root.bottomRight.val);
        Assertions.assertTrue(root.bottomRight.isLeaf);
    }

    @Test

=== Chunk 812 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0427.construct-quad-tree\ConstructQuadTreeTest.java

}

    @Test
    void Example2() {
        int[][] grid = {{1, 1, 1, 1, 0, 0, 0, 0}, {1, 1, 1, 1, 0, 0, 0, 0}, {1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 0, 0, 0, 0}, {1, 1, 1, 1, 0, 0, 0, 0}, {1, 1, 1, 1, 0, 0, 0, 0}, {1, 1, 1, 1, 0, 0, 0, 0}};
        QuadNode root = constructQuadTree.construct(grid);

        Assertions.assertTrue(root.val);
        Assertions.assertFalse(root.isLeaf);
        Assertions.assertTrue(root.topLeft.val);
        Assertions.assertTrue(root.topLeft.isLeaf);
        Assertions.assertTrue(root.topRight.val);
        Assertions.assertFalse(root.topRight.isLeaf);
        Assertions.assertTrue(root.bottomLeft.val);
        Assertions.assertTrue(root.bottomLeft.isLeaf);
        Assertions.assertFalse(root.bottomRight.val);

=== Chunk 813 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0427.construct-quad-tree\ConstructQuadTreeTest.java

Assertions.assertTrue(root.bottomRight.isLeaf);
        Assertions.assertFalse(root.topRight.topLeft.val);
        Assertions.assertTrue(root.topRight.topLeft.isLeaf);
        Assertions.assertFalse(root.topRight.topRight.val);
        Assertions.assertTrue(root.topRight.topRight.isLeaf);
        Assertions.assertTrue(root.topRight.bottomLeft.val);
        Assertions.assertTrue(root.topRight.bottomLeft.isLeaf);
        Assertions.assertTrue(root.topRight.bottomRight.val);
        Assertions.assertTrue(root.topRight.bottomRight.isLeaf);
    }
}

=== Chunk 814 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0429.n-ary-tree-level-order-traversal\NAryTreeLevelOrderTraversal.java

/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

import java.util.ArrayList;
import java.util.List;

=== Chunk 815 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0429.n-ary-tree-level-order-traversal\NAryTreeLevelOrderTraversal.java

class NAryTreeLevelOrderTraversal {
    private final List<List<Integer>> res = new ArrayList<>();

    private void BFS(Node root, int level) {
        if (root == null) return;
        List<Integer> levelList;
        if (res.size() < level + 1) {
            levelList = new ArrayList<>();
            levelList.add(root.val);
            res.add(levelList);
        } else {
            levelList = res.get(level);
            levelList.add(root.val);
            res.remove(level);
            res.add(level, levelList);
        }
        if (root.children != null) {
            for (Node node : root.children) {
                BFS(node, level + 1);
            }
        }
    }

    public List<List<Integer>> levelOrder(Node root) {
        BFS(root, 0);

=== Chunk 816 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0429.n-ary-tree-level-order-traversal\NAryTreeLevelOrderTraversal.java

BFS(root, 0);
        return res;
    }
}

=== Chunk 817 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0429.n-ary-tree-level-order-traversal\NAryTreeLevelOrderTraversal2.java

/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

=== Chunk 818 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0429.n-ary-tree-level-order-traversal\NAryTreeLevelOrderTraversal2.java

class NAryTreeLevelOrderTraversal2 {
    public List<List<Integer>> levelOrder(Node root) {
        Queue<Node> q = new LinkedList<>();
        List<List<Integer>> res = new LinkedList<>();
        if (root == null) return res;
        q.add(root);
        while (!q.isEmpty()) {
            int n = q.size();
            List<Integer> current = new LinkedList<>();
            for (int i = 0; i < n; i++) {
                Node node = q.poll();
                current.add(node.val);
                if (node.children != null) q.addAll(node.children);
            }
            res.add(current);
        }
        return res;
    }
}

=== Chunk 819 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0429.n-ary-tree-level-order-traversal\NAryTreeLevelOrderTraversalTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 820 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0429.n-ary-tree-level-order-traversal\NAryTreeLevelOrderTraversalTest.java

public class NAryTreeLevelOrderTraversalTest {
    NAryTreeLevelOrderTraversal NAryTreeLevelOrderTraversal = new NAryTreeLevelOrderTraversal();
    NAryTreeLevelOrderTraversal2 NAryTreeLevelOrderTraversal2 = new NAryTreeLevelOrderTraversal2();

    @Test
    void Example1() {
        Node root = new Node(1);
        Node secondNode = new Node(3);
        Node thirdNode = new Node(2);
        Node forthNode = new Node(4);
        Node fifthNode = new Node(5);
        Node sixthNode = new Node(6);
        root.children = Arrays.asList(secondNode, thirdNode, forthNode);
        secondNode.children = Arrays.asList(fifthNode, sixthNode);
        List<List<Integer>> results = NAryTreeLevelOrderTraversal.levelOrder(root);

=== Chunk 821 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0429.n-ary-tree-level-order-traversal\NAryTreeLevelOrderTraversalTest.java

List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(List.of(1));
        expectedResults.add(Arrays.asList(3, 2, 4));
        expectedResults.add(Arrays.asList(5, 6));

        Assertions.assertEquals(expectedResults, results);

        results = NAryTreeLevelOrderTraversal2.levelOrder(root);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        Node root = new Node(1);
        Node secondNode = new Node(2);
        Node thirdNode = new Node(3);
        Node forthNode = new Node(4);
        Node fifthNode = new Node(5);
        Node sixthNode = new Node(6);
        Node seventhNode = new Node(7);
        Node eighthNode = new Node(8);
        Node ninthNode = new Node(9);

=== Chunk 822 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0429.n-ary-tree-level-order-traversal\NAryTreeLevelOrderTraversalTest.java

Node ninthNode = new Node(9);
        Node tenthNode = new Node(10);
        Node eleventhNode = new Node(11);
        Node twelfthNode = new Node(12);
        Node thirteenthNode = new Node(13);
        Node fourteenthNode = new Node(14);
        root.children = Arrays.asList(secondNode, thirdNode, forthNode, fifthNode);
        thirdNode.children = Arrays.asList(sixthNode, seventhNode);
        forthNode.children = List.of(eighthNode);
        fifthNode.children = Arrays.asList(ninthNode, tenthNode);
        seventhNode.children = List.of(eleventhNode);
        eighthNode.children = List.of(twelfthNode);
        ninthNode.children = List.of(thirteenthNode);
        eleventhNode.children = List.of(fourteenthNode);

=== Chunk 823 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0429.n-ary-tree-level-order-traversal\NAryTreeLevelOrderTraversalTest.java

List<List<Integer>> results = NAryTreeLevelOrderTraversal.levelOrder(root);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(List.of(1));
        expectedResults.add(Arrays.asList(2, 3, 4, 5));
        expectedResults.add(Arrays.asList(6, 7, 8, 9, 10));
        expectedResults.add(Arrays.asList(11, 12, 13));
        expectedResults.add(List.of(14));

        Assertions.assertEquals(expectedResults, results);

        results = NAryTreeLevelOrderTraversal2.levelOrder(root);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 824 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0433.minimum-genetic-mutation\MinimumGeneticMutation.java

import java.util.*;

=== Chunk 825 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0433.minimum-genetic-mutation\MinimumGeneticMutation.java

class MinimumGeneticMutation {
    public int minMutation(String start, String end, String[] bank) {
        Queue<String> queue = new LinkedList<>();
        Set<String> seen = new HashSet<>();
        queue.add(start);
        seen.add(start);

        int steps = 0;

        while (!queue.isEmpty()) {
            int nodesInQueue = queue.size();
            for (int j = 0; j < nodesInQueue; j++) {
                String node = queue.remove();
                if (node.equals(end)) return steps;
                for (char c : new char[]{'A', 'C', 'G', 'T'}) {
                    for (int i = 0; i < node.length(); i++) {
                        String neighbor = node.substring(0, i) + c + node.substring(i + 1);

=== Chunk 826 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0433.minimum-genetic-mutation\MinimumGeneticMutation.java

if (!seen.contains(neighbor) && Arrays.asList(bank).contains(neighbor)) {
                            queue.add(neighbor);
                            seen.add(neighbor);
                        }
                    }
                }
            }
            steps++;
        }

        return -1;
    }
}

=== Chunk 827 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0433.minimum-genetic-mutation\MinimumGeneticMutationTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 828 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0433.minimum-genetic-mutation\MinimumGeneticMutationTest.java

public class MinimumGeneticMutationTest {
    MinimumGeneticMutation MinimumGeneticMutation = new MinimumGeneticMutation();

    @Test
    void Example1() {
        String start = "AACCGGTT", end = "AACCGGTA";
        String[] bank = {"AACCGGTA"};
        int results = MinimumGeneticMutation.minMutation(start, end, bank);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String start = "AACCGGTT", end = "AAACGGTA";
        String[] bank = {"AACCGGTA", "AACCGCTA", "AAACGGTA"};
        int results = MinimumGeneticMutation.minMutation(start, end, bank);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test

=== Chunk 829 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0433.minimum-genetic-mutation\MinimumGeneticMutationTest.java

}

    @Test
    void Example3() {
        String start = "AAAAACCC", end = "AACCCCCC";
        String[] bank = {"AAAACCCC", "AAACCCCC", "AACCCCCC"};
        int results = MinimumGeneticMutation.minMutation(start, end, bank);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 830 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0435.non-overlapping-intervals\NonOverlappingIntervals.java

import java.util.Arrays;
import java.util.Comparator;

class NonOverlappingIntervals {
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 0) {
            return 0;
        }
        Arrays.sort(intervals, Comparator.comparingInt(o -> o[1]));
        int cnt = 1;
        int end = intervals[0][1];
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] < end) {
                continue;
            }
            end = intervals[i][1];
            cnt++;
        }
        return intervals.length - cnt;
    }
}

=== Chunk 831 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0435.non-overlapping-intervals\NonOverlappingIntervalsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 832 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0435.non-overlapping-intervals\NonOverlappingIntervalsTest.java

public class NonOverlappingIntervalsTest {
    NonOverlappingIntervals NonOverlappingIntervals = new NonOverlappingIntervals();

    @Test
    void Example1() {
        int[][] intervals = {{1, 2}, {2, 3}, {3, 4}, {1, 3}};
        int results = NonOverlappingIntervals.eraseOverlapIntervals(intervals);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] intervals = {{1, 2}, {1, 2}, {1, 2}};
        int results = NonOverlappingIntervals.eraseOverlapIntervals(intervals);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[][] intervals = {{1, 2}, {2, 3}};

=== Chunk 833 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0435.non-overlapping-intervals\NonOverlappingIntervalsTest.java

int[][] intervals = {{1, 2}, {2, 3}};
        int results = NonOverlappingIntervals.eraseOverlapIntervals(intervals);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 834 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0437.path-sum-iii\PathSumIii.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 835 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0437.path-sum-iii\PathSumIii.java

class PathSumIii {
    private int pathSumStartWithRoot(TreeNode root, long sum) {
        if (root == null) return 0;
        int ret = 0;
        if (root.val == sum) ret++;
        ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);
        return ret;
    }

    public int pathSum(TreeNode root, int targetSum) {
        if (root == null) return 0;
        return pathSumStartWithRoot(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);
    }
}

=== Chunk 836 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0437.path-sum-iii\PathSumIiiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 837 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0437.path-sum-iii\PathSumIiiTest.java

public class PathSumIiiTest {
    PathSumIii PathSumIii = new PathSumIii();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(10);
        TreeNode secondNode = new TreeNode(5);
        TreeNode thirdNode = new TreeNode(-3);
        TreeNode forthNode = new TreeNode(3);
        TreeNode fifthNode = new TreeNode(2);
        TreeNode sixthNode = new TreeNode(11);
        TreeNode seventhNode = new TreeNode(3);
        TreeNode eighthNode = new TreeNode(-2);
        TreeNode ninthNode = new TreeNode(1);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        thirdNode.right = sixthNode;
        forthNode.left = seventhNode;

=== Chunk 838 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0437.path-sum-iii\PathSumIiiTest.java

forthNode.left = seventhNode;
        forthNode.right = eighthNode;
        fifthNode.right = ninthNode;

        int targetSum = 8;
        int results = PathSumIii.pathSum(firstNode, targetSum);
        int expectedResult = 3;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(5);
        TreeNode secondNode = new TreeNode(4);
        TreeNode thirdNode = new TreeNode(8);
        TreeNode forthNode = new TreeNode(11);
        TreeNode fifthNode = new TreeNode(13);
        TreeNode sixthNode = new TreeNode(4);
        TreeNode seventhNode = new TreeNode(7);
        TreeNode eighthNode = new TreeNode(2);
        TreeNode ninthNode = new TreeNode(5);

=== Chunk 839 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0437.path-sum-iii\PathSumIiiTest.java

TreeNode ninthNode = new TreeNode(5);
        TreeNode tenthNode = new TreeNode(1);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        thirdNode.left = fifthNode;
        thirdNode.right = sixthNode;
        forthNode.left = seventhNode;
        forthNode.right = eighthNode;
        fifthNode.left = ninthNode;
        fifthNode.right = tenthNode;

        int targetSum = 22;
        int results = PathSumIii.pathSum(firstNode, targetSum);
        int expectedResult = 3;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example3() {
        TreeNode firstNode = new TreeNode(1000000000);
        TreeNode secondNode = new TreeNode(1000000000);

=== Chunk 840 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0437.path-sum-iii\PathSumIiiTest.java

TreeNode thirdNode = new TreeNode(294967296);
        TreeNode forthNode = new TreeNode(1000000000);
        TreeNode fifthNode = new TreeNode(1000000000);
        TreeNode sixthNode = new TreeNode(1000000000);

        firstNode.left = secondNode;
        secondNode.left = thirdNode;
        thirdNode.left = forthNode;
        forthNode.left = fifthNode;
        fifthNode.left = sixthNode;

        int targetSum = 0;
        int results = PathSumIii.pathSum(firstNode, targetSum);
        int expectedResult = 0;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 841 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0438.find-all-anagrams-in-a-string\FindAllAnagramsInAString.java

import java.util.*;

=== Chunk 842 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0438.find-all-anagrams-in-a-string\FindAllAnagramsInAString.java

class FindAllAnagramsInAString {
    public List<Integer> findAnagrams(String s, String p) {
        int n = s.length(), m = p.length();

        if (n < m)
            return new ArrayList<>();

        List<Integer> res = new ArrayList<>();
        int[] sCount = new int[26];
        int[] pCount = new int[26];
        for (int i = 0; i < m; i++) {
            sCount[s.charAt(i) - 'a']++;
            pCount[p.charAt(i) - 'a']++;
        }

        if (Arrays.equals(sCount, pCount))
            res.add(0);

        for (int i = 0; i < n - m; i++) {
            sCount[s.charAt(i) - 'a']--;
            sCount[s.charAt(i + m) - 'a']++;

            if (Arrays.equals(sCount, pCount))
                res.add(i + 1);
        }

        return res;
    }
}

=== Chunk 843 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0438.find-all-anagrams-in-a-string\FindAllAnagramsInAStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

=== Chunk 844 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0438.find-all-anagrams-in-a-string\FindAllAnagramsInAStringTest.java

public class FindAllAnagramsInAStringTest {
    FindAllAnagramsInAString FindAllAnagramsInAString = new FindAllAnagramsInAString();

    @Test
    void Example1() {
        String s = "cbaebabacd", p = "abc";
        List<Integer> results = FindAllAnagramsInAString.findAnagrams(s, p);
        List<Integer> expectedResults = Arrays.asList(0, 6);

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "abab", p = "ab";
        List<Integer> results = FindAllAnagramsInAString.findAnagrams(s, p);
        List<Integer> expectedResults = Arrays.asList(0, 1, 2);

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 845 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0443.string-compression\StringCompression.java

class StringCompression {
    public int compress(char[] chars) {
        int n = chars.length;
        int write = 0, left = 0;
        for (int read = 0; read < n; read++) {
            if (read == n - 1 || chars[read] != chars[read + 1]) {
                chars[write++] = chars[read];
                int cnt = read - left + 1;
                if (cnt > 1) {
                    String str = String.valueOf(cnt);
                    for (int i = 0; i < str.length(); i++) {
                        chars[write++] = str.charAt(i);
                    }
                }
                left = read + 1;
            }
        }
        return write;
    }
}

=== Chunk 846 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0443.string-compression\StringCompressionTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class StringCompressionTest {
    StringCompression stringCompression = new StringCompression();

    @Test
    void Example1() {
        char[] chars = {'a', 'a', 'b', 'b', 'c', 'c', 'c'};

        Assertions.assertEquals(6, stringCompression.compress(chars));
    }

    @Test
    void Example2() {
        char[] chars = {'a'};

        Assertions.assertEquals(1, stringCompression.compress(chars));
    }

    @Test
    void Example3() {
        char[] chars = {'a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'};

        Assertions.assertEquals(4, stringCompression.compress(chars));
    }
}

=== Chunk 847 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0445.add-two-numbers-ii\AddTwoNumbersIi.java

import java.util.Stack;

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

=== Chunk 848 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0445.add-two-numbers-ii\AddTwoNumbersIi.java

class AddTwoNumbersIi {
    private Stack<Integer> buildStack(ListNode l) {
        Stack<Integer> stack = new Stack<>();
        while (l != null) {
            stack.push(l.val);
            l = l.next;
        }
        return stack;
    }

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        Stack<Integer> l1Stack = buildStack(l1);
        Stack<Integer> l2Stack = buildStack(l2);
        ListNode head = new ListNode(-1);
        int carry = 0;
        while (!l1Stack.empty() || !l2Stack.empty() || carry != 0) {
            int x = l1Stack.isEmpty() ? 0 : l1Stack.pop();
            int y = l2Stack.isEmpty() ? 0 : l2Stack.pop();
            int sum = x + y + carry;
            ListNode node = new ListNode(sum % 10);

=== Chunk 849 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0445.add-two-numbers-ii\AddTwoNumbersIi.java

node.next = head.next;
            head.next = node;
            carry = sum / 10;
        }
        return head.next;
    }
}

=== Chunk 850 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0445.add-two-numbers-ii\AddTwoNumbersIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 851 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0445.add-two-numbers-ii\AddTwoNumbersIiTest.java

public class AddTwoNumbersIiTest {
    AddTwoNumbersIi AddTwoNumbersIi = new AddTwoNumbersIi();

    @Test
    void Example1() {
        ListNode list1FirstNode = new ListNode(7);
        ListNode list1SecondNode = new ListNode(2);
        ListNode list1ThirdNode = new ListNode(4);
        ListNode list1ForthNode = new ListNode(3);

        ListNode list2FirstNode = new ListNode(5);
        ListNode list2SecondNode = new ListNode(6);
        ListNode list2ThirdNode = new ListNode(4);

        list1FirstNode.next = list1SecondNode;
        list1SecondNode.next = list1ThirdNode;
        list1ThirdNode.next = list1ForthNode;

        list2FirstNode.next = list2SecondNode;
        list2SecondNode.next = list2ThirdNode;

=== Chunk 852 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0445.add-two-numbers-ii\AddTwoNumbersIiTest.java

list2SecondNode.next = list2ThirdNode;

        ListNode results = AddTwoNumbersIi.addTwoNumbers(list1FirstNode, list2FirstNode);

        ListNode resultFirstNode = new ListNode(7);
        ListNode resultSecondNode = new ListNode(8);
        ListNode resultThirdNode = new ListNode(0);
        ListNode resultForthNode = new ListNode(7);

        resultFirstNode.next = resultSecondNode;
        resultSecondNode.next = resultThirdNode;
        resultThirdNode.next = resultForthNode;

        ListNode expectedResultHead = resultFirstNode;
        ListNode resultsHead = results;
        while (expectedResultHead.next != null) {
            Assertions.assertEquals(expectedResultHead.val, resultsHead.val);
            expectedResultHead = expectedResultHead.next;

=== Chunk 853 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0445.add-two-numbers-ii\AddTwoNumbersIiTest.java

resultsHead = resultsHead.next;
        }
    }

    @Test
    void Example2() {
        ListNode list1FirstNode = new ListNode(2);
        ListNode list1SecondNode = new ListNode(4);
        ListNode list1ThirdNode = new ListNode(3);

        ListNode list2FirstNode = new ListNode(5);
        ListNode list2SecondNode = new ListNode(6);
        ListNode list2ThirdNode = new ListNode(4);

        list1FirstNode.next = list1SecondNode;
        list1SecondNode.next = list1ThirdNode;

        list2FirstNode.next = list2SecondNode;
        list2SecondNode.next = list2ThirdNode;

        ListNode results = AddTwoNumbersIi.addTwoNumbers(list1FirstNode, list2FirstNode);

        ListNode resultFirstNode = new ListNode(8);

=== Chunk 854 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0445.add-two-numbers-ii\AddTwoNumbersIiTest.java

ListNode resultSecondNode = new ListNode(0);
        ListNode resultThirdNode = new ListNode(7);

        resultFirstNode.next = resultSecondNode;
        resultSecondNode.next = resultThirdNode;

        ListNode expectedResultHead = resultFirstNode;
        ListNode resultsHead = results;
        while (expectedResultHead.next != null) {
            Assertions.assertEquals(expectedResultHead.val, resultsHead.val);
            expectedResultHead = expectedResultHead.next;
            resultsHead = resultsHead.next;
        }
    }

    @Test
    void Example3() {
        ListNode list1FirstNode = new ListNode(0);
        ListNode list2FirstNode = new ListNode(0);

        ListNode results = AddTwoNumbersIi.addTwoNumbers(list1FirstNode, list2FirstNode);

=== Chunk 855 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0445.add-two-numbers-ii\AddTwoNumbersIiTest.java

ListNode expectedResultHead = new ListNode(0);
        ListNode resultsHead = results;
        while (expectedResultHead.next != null) {
            Assertions.assertEquals(expectedResultHead.val, resultsHead.val);
            expectedResultHead = expectedResultHead.next;
            resultsHead = resultsHead.next;
        }
    }
}

=== Chunk 856 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0446.arithmetic-slices-ii-subsequence\ArithmeticSlicesIiSubsequence.java

import java.util.HashMap;
import java.util.Map;

class ArithmeticSlicesIiSubsequence {
    public int numberOfArithmeticSlices(int[] nums) {
        int ans = 0;
        int n = nums.length;
        Map<Long, Integer>[] f = new Map[n];
        for (int i = 0; i < n; i++) {
            f[i] = new HashMap<>();
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                long d = (long) nums[i] - nums[j];
                int cnt = f[j].getOrDefault(d, 0);
                ans += cnt;
                f[i].put(d, f[i].getOrDefault(d, 0) + cnt + 1);
            }
        }
        return ans;
    }
}

=== Chunk 857 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0446.arithmetic-slices-ii-subsequence\ArithmeticSlicesIiSubsequenceTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ArithmeticSlicesIiSubsequenceTest {
    ArithmeticSlicesIiSubsequence arithmeticSlicesIiSubsequence = new ArithmeticSlicesIiSubsequence();

    @Test
    void Example1() {
        int[] nums = {2, 4, 6, 8, 10};
        int results = arithmeticSlicesIiSubsequence.numberOfArithmeticSlices(nums);

        Assertions.assertEquals(7, results);
    }

    @Test
    void Example2() {
        int[] nums = {7, 7, 7, 7, 7};
        int results = arithmeticSlicesIiSubsequence.numberOfArithmeticSlices(nums);

        Assertions.assertEquals(16, results);
    }
}

=== Chunk 858 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0451.sort-characters-by-frequency\SortCharactersByFrequency.java

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class SortCharactersByFrequency {
    public String frequencySort(String s) {
        Map<Character, Integer> freq = new HashMap<>();
        for (char c : s.toCharArray())
            freq.put(c, freq.getOrDefault(c, 0) + 1);

        List<Character> list = new ArrayList<>(freq.keySet());
        list.sort((a, b) -> freq.get(b) - freq.get(a));
        StringBuilder sb = new StringBuilder();
        for (char c : list) {
            int frequency = freq.get(c);
            sb.append(String.valueOf(c).repeat(frequency));
        }
        return sb.toString();
    }
}

=== Chunk 859 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0451.sort-characters-by-frequency\SortCharactersByFrequency2.java

import java.util.HashMap;
import java.util.Map;

=== Chunk 860 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0451.sort-characters-by-frequency\SortCharactersByFrequency2.java

class SortCharactersByFrequency2 {
    public String frequencySort(String s) {
        Map<Character, Integer> freq = new HashMap<>();
        int maxFreq = 0;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            int frequency = freq.getOrDefault(c, 0) + 1;
            freq.put(c, frequency);
            maxFreq = Math.max(maxFreq, frequency);
        }

        StringBuilder[] buckets = new StringBuilder[maxFreq + 1];
        for (int i = 0; i <= maxFreq; i++)
            buckets[i] = new StringBuilder();

        for (Map.Entry<Character, Integer> entry : freq.entrySet()) {
            char c = entry.getKey();
            int frequency = entry.getValue();
            buckets[frequency].append(c);
        }

=== Chunk 861 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0451.sort-characters-by-frequency\SortCharactersByFrequency2.java

}

        StringBuilder sb = new StringBuilder();
        for (int i = maxFreq; i > 0; i--) {
            StringBuilder bucket = buckets[i];
            for (int j = 0; j < bucket.length(); j++) {
                for (int k = 0; k < i; k++) {
                    sb.append(bucket.charAt(j));
                }
            }
        }
        return sb.toString();
    }
}

=== Chunk 862 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0451.sort-characters-by-frequency\SortCharactersByFrequencyTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 863 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0451.sort-characters-by-frequency\SortCharactersByFrequencyTest.java

public class SortCharactersByFrequencyTest {
    SortCharactersByFrequency sortCharactersByFrequency = new SortCharactersByFrequency();
    SortCharactersByFrequency2 sortCharactersByFrequency2 = new SortCharactersByFrequency2();

    @Test
    void Example1() {
        String s = "tree";
        String results = sortCharactersByFrequency.frequencySort(s);
        String expectedResults = "eert";

        Assertions.assertEquals(expectedResults, results);

        results = sortCharactersByFrequency2.frequencySort(s);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "cccaaa";
        String results = sortCharactersByFrequency.frequencySort(s);
        String expectedResults = "aaaccc";

=== Chunk 864 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0451.sort-characters-by-frequency\SortCharactersByFrequencyTest.java

String expectedResults = "aaaccc";

        Assertions.assertEquals(expectedResults, results);

        results = sortCharactersByFrequency2.frequencySort(s);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "Aabb";
        String results = sortCharactersByFrequency.frequencySort(s);
        String expectedResults = "bbAa";

        Assertions.assertEquals(expectedResults, results);

        results = sortCharactersByFrequency2.frequencySort(s);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 865 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0452.minimum-number-of-arrows-to-burst-balloons\MinimumNumberOfArrowsToBurstBalloons.java

import java.util.Arrays;
import java.util.Comparator;

class MinimumNumberOfArrowsToBurstBalloons {
    public int findMinArrowShots(int[][] points) {
        if (points.length == 0)
            return 0;
        Arrays.sort(points, Comparator.comparingInt(p -> p[1]));
        int ans = 1, end = points[0][1];
        for (int i = 1; i < points.length; i++) {
            if (points[i][0] > end) {
                ans++;
                end = points[i][1];
            }
        }
        return ans;
    }
}

=== Chunk 866 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0452.minimum-number-of-arrows-to-burst-balloons\MinimumNumberOfArrowsToBurstBalloonsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 867 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0452.minimum-number-of-arrows-to-burst-balloons\MinimumNumberOfArrowsToBurstBalloonsTest.java

public class MinimumNumberOfArrowsToBurstBalloonsTest {
    MinimumNumberOfArrowsToBurstBalloons minimumNumberOfArrowsToBurstBalloons = new MinimumNumberOfArrowsToBurstBalloons();

    @Test
    void Example1() {
        int[][] points = {{10, 16}, {2, 8}, {1, 6}, {7, 12}};

        Assertions.assertEquals(2, minimumNumberOfArrowsToBurstBalloons.findMinArrowShots(points));
    }

    @Test
    void Example2() {
        int[][] points = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};

        Assertions.assertEquals(4, minimumNumberOfArrowsToBurstBalloons.findMinArrowShots(points));
    }

    @Test
    void Example3() {
        int[][] points = {{1, 2}, {2, 3}, {3, 4}, {4, 5}};

        Assertions.assertEquals(2, minimumNumberOfArrowsToBurstBalloons.findMinArrowShots(points));

=== Chunk 868 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0452.minimum-number-of-arrows-to-burst-balloons\MinimumNumberOfArrowsToBurstBalloonsTest.java

}
}

=== Chunk 869 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0455.assign-cookies\AssignCookies.java

import java.util.Arrays;

class AssignCookies {
    public int findContentChildren(int[] g, int[] s) {
        if (g == null || s == null) return 0;
        Arrays.sort(g);
        Arrays.sort(s);
        int gi = 0, si = 0;
        while (gi < g.length && si < s.length) {
            if (g[gi] <= s[si]) {
                gi++;
            }
            si++;
        }
        return gi;
    }
}

=== Chunk 870 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0455.assign-cookies\AssignCookiesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class AssignCookiesTest {
    AssignCookies AssignCookies = new AssignCookies();

    @Test
    void Example1() {
        int[] g = {1, 2, 3}, s = {1, 1};
        int results = AssignCookies.findContentChildren(g, s);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] g = {1, 2}, s = {1, 2, 3};
        int results = AssignCookies.findContentChildren(g, s);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 871 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0458.poor-pigs\PoorPigs.java

class PoorPigs {
    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
        int testBuckets = minutesToTest / minutesToDie;
        int pigs = 0;
        while (Math.pow(testBuckets + 1, pigs) < buckets) {
            pigs++;
        }
        return pigs;
    }
}

=== Chunk 872 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0458.poor-pigs\PoorPigsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 873 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0458.poor-pigs\PoorPigsTest.java

public class PoorPigsTest {
    PoorPigs PoorPigs = new PoorPigs();

    @Test
    void Example1() {
        int buckets = 1000, minutesToDie = 15, minutesToTest = 60;
        int results = PoorPigs.poorPigs(buckets, minutesToDie, minutesToTest);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int buckets = 4, minutesToDie = 15, minutesToTest = 15;
        int results = PoorPigs.poorPigs(buckets, minutesToDie, minutesToTest);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int buckets = 4, minutesToDie = 15, minutesToTest = 30;

=== Chunk 874 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0458.poor-pigs\PoorPigsTest.java

int results = PoorPigs.poorPigs(buckets, minutesToDie, minutesToTest);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        int buckets = 1, minutesToDie = 1, minutesToTest = 1;
        int results = PoorPigs.poorPigs(buckets, minutesToDie, minutesToTest);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 875 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0461.hamming-distance\HammingDistance.java

class HammingDistance {
    public int hammingDistance(int x, int y) {
        int z = x ^ y;
        int cnt = 0;
        while (z != 0) {
            if ((z & 1) == 1) cnt++;
            z = z >> 1;
        }
        return cnt;
    }
}

=== Chunk 876 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0461.hamming-distance\HammingDistanceTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class HammingDistanceTest {
    HammingDistance HammingDistance = new HammingDistance();

    @Test
    void Example1() {
        int x = 1, y = 4;
        int results = HammingDistance.hammingDistance(x, y);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int x = 3, y = 1;
        int results = HammingDistance.hammingDistance(x, y);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 877 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0462.minimum-moves-to-equal-array-elements-ii\MinimumMovesToEqualArrayElementsIi.java

import java.util.Arrays;

class MinimumMovesToEqualArrayElementsIi {
    public int minMoves2(int[] nums) {
        int l = nums.length;
        Arrays.sort(nums);
        int m = nums.length % 2 == 0 ? (nums[l / 2] + nums[l / 2 - 1]) / 2 : nums[l / 2];
        int steps = 0;
        for (int num : nums) {
            steps += Math.abs(num - m);
        }
        return steps;
    }
}

=== Chunk 878 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0462.minimum-moves-to-equal-array-elements-ii\MinimumMovesToEqualArrayElementsIi2.java

import java.util.Arrays;

class MinimumMovesToEqualArrayElementsIi2 {
    public int minMoves2(int[] nums) {
        Arrays.sort(nums);

        int i = 0, j = nums.length - 1;
        int steps = 0;
        while (i < j) {
            steps += (nums[j] - nums[i]);
            i++;
            j--;
        }
        return steps;
    }
}

=== Chunk 879 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0462.minimum-moves-to-equal-array-elements-ii\MinimumMovesToEqualArrayElementsIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 880 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0462.minimum-moves-to-equal-array-elements-ii\MinimumMovesToEqualArrayElementsIiTest.java

public class MinimumMovesToEqualArrayElementsIiTest {
    MinimumMovesToEqualArrayElementsIi MinimumMovesToEqualArrayElementsIi = new MinimumMovesToEqualArrayElementsIi();
    MinimumMovesToEqualArrayElementsIi2 MinimumMovesToEqualArrayElementsIi2 = new MinimumMovesToEqualArrayElementsIi2();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3};
        int results = MinimumMovesToEqualArrayElementsIi.minMoves2(nums);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);

        results = MinimumMovesToEqualArrayElementsIi2.minMoves2(nums);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 10, 2, 9};

=== Chunk 881 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0462.minimum-moves-to-equal-array-elements-ii\MinimumMovesToEqualArrayElementsIiTest.java

int[] nums = {1, 10, 2, 9};
        int results = MinimumMovesToEqualArrayElementsIi.minMoves2(nums);
        int expectedResults = 16;

        Assertions.assertEquals(expectedResults, results);

        results = MinimumMovesToEqualArrayElementsIi2.minMoves2(nums);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {1, 2};
        int results = MinimumMovesToEqualArrayElementsIi.minMoves2(nums);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);

        results = MinimumMovesToEqualArrayElementsIi2.minMoves2(nums);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 882 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0472.concatenated-words\ConcatenatedWords.java

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 883 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0472.concatenated-words\ConcatenatedWords.java

class ConcatenatedWords {
    WordTrie trie = new WordTrie();

    public List<String> findAllConcatenatedWordsInADict(String[] words) {
        List<String> ans = new ArrayList<>();
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        for (int i = 0; i < words.length; i++) {
            String word = words[i];
            if (word.length() == 0)
                continue;
            boolean[] visited = new boolean[word.length()];
            if (dfs(word, 0, visited))
                ans.add(word);
            else
                insert(word);
        }
        return ans;
    }

    private boolean dfs(String word, int start, boolean[] visited) {
        if (word.length() == start)
            return true;
        if (visited[start])

=== Chunk 884 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0472.concatenated-words\ConcatenatedWords.java

if (visited[start])
            return false;
        visited[start] = true;
        WordTrie node = trie;
        for (int i = start; i < word.length(); i++) {
            char c = word.charAt(i);
            int index = c - 'a';
            node = node.children[index];
            if (node == null)
                return false;
            if (node.isEnd)
                if (dfs(word, i + 1, visited))
                    return true;
        }
        return false;
    }

    private void insert(String word) {
        WordTrie node = trie;
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            int index = c - 'a';
            if (node.children[index] == null)

=== Chunk 885 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0472.concatenated-words\ConcatenatedWords.java

if (node.children[index] == null)
                node.children[index] = new WordTrie();
            node = node.children[index];
        }
        node. isEnd = true;
    }
}

=== Chunk 886 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0472.concatenated-words\ConcatenatedWords.java

class WordTrie {
    WordTrie[] children;
    boolean isEnd;

    public WordTrie() {
        children = new WordTrie[26];
        isEnd = false;
    }
}

=== Chunk 887 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0472.concatenated-words\ConcatenatedWordsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

=== Chunk 888 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0472.concatenated-words\ConcatenatedWordsTest.java

public class ConcatenatedWordsTest {
    ConcatenatedWords concatenatedWords = new ConcatenatedWords();

    @Test
    void Example1() {
        String[] words = {"cat", "cats", "catsdogcats", "dog", "dogcatsdog", "hippopotamuses", "rat", "ratcatdogcat"};
        List<String> expectedResults = Arrays.asList("catsdogcats", "dogcatsdog", "ratcatdogcat");

        Assertions.assertTrue(expectedResults.containsAll(concatenatedWords.findAllConcatenatedWordsInADict(words)));
    }

    @Test
    void Example2() {
        String[] words = {"cat","dog","catdog"};
        List<String> expectedResults = List.of("catdog");

        Assertions.assertTrue(expectedResults.containsAll(concatenatedWords.findAllConcatenatedWordsInADict(words)));
    }
}

=== Chunk 889 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0473.matchsticks-to-square\MatchsticksToSquare.java

import java.util.Arrays;

=== Chunk 890 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0473.matchsticks-to-square\MatchsticksToSquare.java

class MatchsticksToSquare {
    private void reverse(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int tmp = nums[left];
            nums[left] = nums[right];
            nums[right] = tmp;
            left++;
            right--;
        }
    }

    private boolean dfs(int[] nums, int[] sums, int index, int target) {
        if (index == nums.length) {
            return sums[0] == target && sums[1] == target && sums[2] == target;
        }
        for (int i = 0; i < 4; i++) {
            if (sums[i] + nums[index] > target) continue;
            sums[i] += nums[index];
            if (dfs(nums, sums, index + 1, target)) return true;
            sums[i] -= nums[index];
        }

=== Chunk 891 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0473.matchsticks-to-square\MatchsticksToSquare.java

sums[i] -= nums[index];
        }
        return false;
    }

    public boolean makesquare(int[] matchsticks) {
        if (matchsticks == null || matchsticks.length < 4) return false;
        int l = matchsticks.length;
        int perimeter = 0;
        for (int i = 0; i < l; i++) {
            perimeter += matchsticks[i];
        }
        if (perimeter % 4 != 0) return false;
        Arrays.sort(matchsticks);
        reverse(matchsticks);
        return dfs(matchsticks, new int[4], 0, perimeter / 4);
    }
}

=== Chunk 892 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0473.matchsticks-to-square\MatchsticksToSquareTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 893 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0473.matchsticks-to-square\MatchsticksToSquareTest.java

public class MatchsticksToSquareTest {
    MatchsticksToSquare MatchsticksToSquare = new MatchsticksToSquare();

    @Test
    void Example1() {
        int[] matchsticks = {1, 1, 2, 2, 2};
        boolean results = MatchsticksToSquare.makesquare(matchsticks);
        boolean expectedResult = true;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        int[] matchsticks = {3, 3, 3, 3, 4};
        boolean results = MatchsticksToSquare.makesquare(matchsticks);
        boolean expectedResult = false;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example3() {
        int[] matchsticks = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 102};

=== Chunk 894 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0473.matchsticks-to-square\MatchsticksToSquareTest.java

boolean results = MatchsticksToSquare.makesquare(matchsticks);
        boolean expectedResult = false;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 895 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0476.number-complement\NumberComplement.java

class NumberComplement {
    public int findComplement(int num) {
        if (num == 0) return 1;
        int mask = 1 << 30;
        while ((mask & num) == 0) mask >>= 1;
        mask = (mask << 1) - 1;
        return num ^ mask;
    }
}

=== Chunk 896 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0476.number-complement\NumberComplementTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class NumberComplementTest {
    NumberComplement NumberComplement = new NumberComplement();

    @Test
    void Example1() {
        int num = 5;
        int results = NumberComplement.findComplement(num);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int num = 1;
        int results = NumberComplement.findComplement(num);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 897 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0485.max-consecutive-ones\MaxConsecutiveOnes.java

class MaxConsecutiveOnes {
    public int findMaxConsecutiveOnes(int[] nums) {
        int max = 0, cur = 0;
        for (int num : nums) {
            cur = num == 0 ? 0 : cur + 1;
            max = Math.max(max, cur);
        }
        return max;
    }
}

=== Chunk 898 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0485.max-consecutive-ones\MaxConsecutiveOnesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MaxConsecutiveOnesTest {
    MaxConsecutiveOnes MaxConsecutiveOnes = new MaxConsecutiveOnes();

    @Test
    void Example1() {
        int[] nums = {1, 1, 0, 1, 1, 1};

        int results = MaxConsecutiveOnes.findMaxConsecutiveOnes(nums);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 0, 1, 1, 0, 1};

        int results = MaxConsecutiveOnes.findMaxConsecutiveOnes(nums);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 899 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0501.find-mode-in-binary-search-tree\FindModeInBinarySearchTree.java

import java.util.ArrayList;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 900 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0501.find-mode-in-binary-search-tree\FindModeInBinarySearchTree.java

class FindModeInBinarySearchTree {
    private int curCnt = 1;
    private int maxCnt = 1;
    private TreeNode preNode = null;

    private void inOrder(TreeNode node, List<Integer> nums) {
        if (node == null) return;
        inOrder(node.left, nums);
        if (preNode != null) {
            if (preNode.val == node.val) curCnt++;
            else curCnt = 1;
        }
        if (curCnt > maxCnt) {
            maxCnt = curCnt;
            nums.clear();
            nums.add(node.val);
        } else if (curCnt == maxCnt) {
            nums.add(node.val);
        }
        preNode = node;
        inOrder(node.right, nums);
    }

    public int[] findMode(TreeNode root) {
        List<Integer> maxCntNums = new ArrayList<>();

=== Chunk 901 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0501.find-mode-in-binary-search-tree\FindModeInBinarySearchTree.java

inOrder(root, maxCntNums);
        int[] ret = new int[maxCntNums.size()];
        int idx = 0;
        for (int num : maxCntNums) {
            ret[idx++] = num;
        }
        return ret;
    }
}

=== Chunk 902 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0501.find-mode-in-binary-search-tree\FindModeInBinarySearchTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 903 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0501.find-mode-in-binary-search-tree\FindModeInBinarySearchTreeTest.java

public class FindModeInBinarySearchTreeTest {
    FindModeInBinarySearchTree FindModeInBinarySearchTree = new FindModeInBinarySearchTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(2);

        firstNode.right = secondNode;
        secondNode.left = thirdNode;

        int[] results = FindModeInBinarySearchTree.findMode(firstNode);
        int[] expectedResult = {2};

        Assertions.assertArrayEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(0);

        int[] results = FindModeInBinarySearchTree.findMode(firstNode);
        int[] expectedResult = {0};

=== Chunk 904 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0501.find-mode-in-binary-search-tree\FindModeInBinarySearchTreeTest.java

int[] expectedResult = {0};

        Assertions.assertArrayEquals(expectedResult, results);
    }
}

=== Chunk 905 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0502.ipo\Ipo.java

import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;

=== Chunk 906 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0502.ipo\Ipo.java

class Ipo {
    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        int n = profits.length;
        int curr = 0;
        int[][] arr = new int[n][2];

        for (int i = 0; i < n; i++) {
            arr[i][0] = capital[i];
            arr[i][1] = profits[i];
        }
        Arrays.sort(arr, Comparator.comparingInt(a -> a[0]));

        PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> y - x);
        for (int i = 0; i < k; i++) {
            while (curr < n && arr[curr][0] <= w) {
                pq.add(arr[curr][1]);
                curr++;
            }
            if (!pq.isEmpty())
                w += pq.poll();
            else
                break;
        }
        return w;
    }
}

=== Chunk 907 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0502.ipo\IpoTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class IpoTest {
    Ipo ipo = new Ipo();

    @Test
    void Example1() {
        int k = 2, w = 0;
        int[] profits = {1, 2, 3},  capital = {0, 1, 1};

        Assertions.assertEquals(4, ipo.findMaximizedCapital(k, w, profits, capital));
    }

    @Test
    void Example2() {
        int k = 3, w = 0;
        int[] profits = {1, 2, 3},  capital = {0, 1, 2};

        Assertions.assertEquals(6, ipo.findMaximizedCapital(k, w, profits, capital));
    }
}

=== Chunk 908 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0503.next-greater-element-ii\NextGreaterElementIi.java

import java.util.Arrays;
import java.util.Stack;

class NextGreaterElementIi {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] next = new int[n];
        Arrays.fill(next, -1);
        Stack<Integer> pre = new Stack<>();
        for (int i = 0; i < 2 * n; i++) {
            int num = nums[i % n];
            while (!pre.isEmpty() && nums[pre.peek()] < num) {
                next[pre.pop()] = num;
            }
            if (i < n) {
                pre.push(i);
            }
        }
        return next;
    }
}

=== Chunk 909 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0503.next-greater-element-ii\NextGreaterElementIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class NextGreaterElementIiTest {
    NextGreaterElementIi NextGreaterElementIi = new NextGreaterElementIi();

    @Test
    void Example1() {
        int[] temperatures = {1, 2, 1};
        int[] results = NextGreaterElementIi.nextGreaterElements(temperatures);
        int[] expectedResults = {2, -1, 2};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] temperatures = {1, 2, 3, 4, 3};
        int[] results = NextGreaterElementIi.nextGreaterElements(temperatures);
        int[] expectedResults = {2, 3, 4, -1, 4};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 910 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0509.fibonacci-number\FibonacciNumber.java

class FibonacciNumber {
    public int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        return fib(n - 1) + fib(n - 2);
    }
}

=== Chunk 911 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0509.fibonacci-number\FibonacciNumber2.java

class FibonacciNumber2 {
    public int fib(int n) {
        if (n == 0) return 0;
        int[] f = new int[n + 1];
        f[0] = 0;
        f[1] = 1;
        for (int i = 2; i <= n; i++) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f[n];
    }
}

=== Chunk 912 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0509.fibonacci-number\FibonacciNumberTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 913 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0509.fibonacci-number\FibonacciNumberTest.java

public class FibonacciNumberTest {
    FibonacciNumber FibonacciNumber = new FibonacciNumber();
    FibonacciNumber2 FibonacciNumber2 = new FibonacciNumber2();

    @Test
    void Example1() {
        int n = 2;
        int results = FibonacciNumber.fib(n);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);

        results = FibonacciNumber2.fib(n);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 3;
        int results = FibonacciNumber.fib(n);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);

        results = FibonacciNumber2.fib(n);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test

=== Chunk 914 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0509.fibonacci-number\FibonacciNumberTest.java

}

    @Test
    void Example3() {
        int n = 4;
        int results = FibonacciNumber.fib(n);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);

        results = FibonacciNumber2.fib(n);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 915 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0513.find-bottom-left-tree-value\FindBottomLeftTreeValue.java

import java.util.LinkedList;
import java.util.Queue;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 916 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0513.find-bottom-left-tree-value\FindBottomLeftTreeValue.java

class FindBottomLeftTreeValue {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            root = queue.poll();
            if (root.right != null) queue.add(root.right);
            if (root.left != null) queue.add(root.left);
        }
        return root.val;
    }
}

=== Chunk 917 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0513.find-bottom-left-tree-value\FindBottomLeftTreeValueTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 918 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0513.find-bottom-left-tree-value\FindBottomLeftTreeValueTest.java

public class FindBottomLeftTreeValueTest {
    FindBottomLeftTreeValue FindBottomLeftTreeValue = new FindBottomLeftTreeValue();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(2);
        TreeNode secondNode = new TreeNode(1);
        TreeNode thirdNode = new TreeNode(3);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;

        int results = FindBottomLeftTreeValue.findBottomLeftValue(firstNode);
        int expectedResult = 1;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(3);
        TreeNode forthNode = new TreeNode(4);

=== Chunk 919 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0513.find-bottom-left-tree-value\FindBottomLeftTreeValueTest.java

TreeNode forthNode = new TreeNode(4);
        TreeNode fifthNode = new TreeNode(5);
        TreeNode sixthNode = new TreeNode(6);
        TreeNode seventhNode = new TreeNode(7);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        thirdNode.left = fifthNode;
        thirdNode.right = sixthNode;
        fifthNode.left = seventhNode;

        int results = FindBottomLeftTreeValue.findBottomLeftValue(firstNode);
        int expectedResult = 7;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 920 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0516.longest-palindromic-subsequence\LongestPalindromicSubsequence.java

class LongestPalindromicSubsequence {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];
        for (int i = n - 1; i >= 0; i--) {
            dp[i][i] = 1;
            char c1 = s.charAt(i);
            for (int j = i + 1; j < n; j++) {
                char c2 = s.charAt(j);
                if (c1 == c2) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
}

=== Chunk 921 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0516.longest-palindromic-subsequence\LongestPalindromicSubsequenceTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class LongestPalindromicSubsequenceTest {
    LongestPalindromicSubsequence longestPalindromicSubsequence = new LongestPalindromicSubsequence();

    @Test
    void Example1() {
        String s = "bbbab";

        Assertions.assertEquals(4, longestPalindromicSubsequence.longestPalindromeSubseq(s));
    }

    @Test
    void Example2() {
        String s = "cbbd";

        Assertions.assertEquals(2, longestPalindromicSubsequence.longestPalindromeSubseq(s));
    }
}

=== Chunk 922 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0520.detect-capital\DetectCapital.java

class DetectCapital {
    public boolean detectCapitalUse(String word) {
        if (word.length() >= 2 && Character.isLowerCase(word.charAt(0)) && Character.isUpperCase(word.charAt(1)))
            return false;

        for (int i = 2; i < word.length(); i++) {
            if (Character.isLowerCase(word.charAt(i)) ^ Character.isLowerCase(word.charAt(1)))
                return false;
        }

        return true;
    }
}

=== Chunk 923 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0520.detect-capital\DetectCapitalTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class DetectCapitalTest {
    DetectCapital detectCapital = new DetectCapital();

    @Test
    void Example1() {
        String word = "USA";

        Assertions.assertTrue(detectCapital.detectCapitalUse(word));
    }

    @Test
    void Example2() {
        String word = "FlaG";

        Assertions.assertFalse(detectCapital.detectCapitalUse(word));
    }

    @Test
    void Example3() {
        String word = "g";

        Assertions.assertFalse(detectCapital.detectCapitalUse(word));
    }
}

=== Chunk 924 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0523.continuous-subarray-sum\ContinuousSubarraySum.java

import java.util.HashMap;
import java.util.Map;

class ContinuousSubarraySum {
    public boolean checkSubarraySum(int[] nums, int k) {
        Map<Integer, Integer> hashMap = new HashMap<>(Map.of(0, 0));
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (!hashMap.containsKey(sum % k))
                hashMap.put(sum % k, i + 1);
            else if (hashMap.get(sum % k) < i)
                return true;
        }
        return false;
    }
}

=== Chunk 925 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0523.continuous-subarray-sum\ContinuousSubarraySumTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 926 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0523.continuous-subarray-sum\ContinuousSubarraySumTest.java

public class ContinuousSubarraySumTest {
    ContinuousSubarraySum ContinuousSubarraySum = new ContinuousSubarraySum();

    @Test
    void Example1() {
        int[] nums = {23, 2, 4, 6, 7};
        int k = 6;
        boolean results = ContinuousSubarraySum.checkSubarraySum(nums, k);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {23, 2, 6, 4, 7};
        int k = 6;
        boolean results = ContinuousSubarraySum.checkSubarraySum(nums, k);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {23, 2, 6, 4, 7};
        int k = 13;

=== Chunk 927 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0523.continuous-subarray-sum\ContinuousSubarraySumTest.java

int k = 13;
        boolean results = ContinuousSubarraySum.checkSubarraySum(nums, k);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 928 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0524.longest-word-in-dictionary-through-deleting\LongestWordInDictionaryThroughDeleting.java

import java.util.List;

=== Chunk 929 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0524.longest-word-in-dictionary-through-deleting\LongestWordInDictionaryThroughDeleting.java

class LongestWordInDictionaryThroughDeleting {
    private boolean isSubString(String s, String target) {
        int i = 0, j = 0;
        while (i < s.length() && j < target.length()) {
            if (s.charAt(i) == target.charAt(j)) {
                j++;
            }
            i++;
        }

        return j == target.length();
    }

    public String findLongestWord(String s, List<String> dictionary) {
        String longestWord = "";

        for (String target : dictionary) {
            int l1 = longestWord.length(), l2 = target.length();
            if ((l1 > l2) || (l1 == l2 && longestWord.compareTo(target) < 0)) {
                continue;
            }
            if (isSubString(s, target)) {
                longestWord = target;
            }

=== Chunk 930 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0524.longest-word-in-dictionary-through-deleting\LongestWordInDictionaryThroughDeleting.java

}
        }

        return longestWord;
    }
}

=== Chunk 931 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0524.longest-word-in-dictionary-through-deleting\LongestWordInDictionaryThroughDeletingTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

=== Chunk 932 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0524.longest-word-in-dictionary-through-deleting\LongestWordInDictionaryThroughDeletingTest.java

public class LongestWordInDictionaryThroughDeletingTest {
    LongestWordInDictionaryThroughDeleting LongestWordInDictionaryThroughDeleting = new LongestWordInDictionaryThroughDeleting();

    @Test
    void Example1() {
        String s = "abpcplea";
        List<String> dictionary = Arrays.asList("ale","apple","monkey","plea");
        String expectedResults = "apple";

        String results;

        results = LongestWordInDictionaryThroughDeleting.findLongestWord(s, dictionary);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "abpcplea";
        List<String> dictionary = Arrays.asList("a","b","c");
        String expectedResults = "a";

        String results;

=== Chunk 933 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0524.longest-word-in-dictionary-through-deleting\LongestWordInDictionaryThroughDeletingTest.java

String results;

        results = LongestWordInDictionaryThroughDeleting.findLongestWord(s, dictionary);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 934 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0530.minimum-absolute-difference-in-bst\MinimumAbsoluteDifferenceInBst.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 935 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0530.minimum-absolute-difference-in-bst\MinimumAbsoluteDifferenceInBst.java

class MinimumAbsoluteDifferenceInBst {
    private int minDiff = Integer.MAX_VALUE;
    private TreeNode preNode = null;

    private void inOrder(TreeNode node) {
        if (node == null) return;
        inOrder(node.left);
        if (preNode != null) minDiff = Math.min(minDiff, node.val - preNode.val);
        preNode = node;
        inOrder(node.right);
    }

    public int getMinimumDifference(TreeNode root) {
        inOrder(root);
        return minDiff;
    }
}

=== Chunk 936 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0530.minimum-absolute-difference-in-bst\MinimumAbsoluteDifferenceInBstTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 937 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0530.minimum-absolute-difference-in-bst\MinimumAbsoluteDifferenceInBstTest.java

public class MinimumAbsoluteDifferenceInBstTest {
    MinimumAbsoluteDifferenceInBst MinimumAbsoluteDifferenceInBst = new MinimumAbsoluteDifferenceInBst();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(4);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(6);
        TreeNode forthNode = new TreeNode(1);
        TreeNode fifthNode = new TreeNode(3);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;

        int results = MinimumAbsoluteDifferenceInBst.getMinimumDifference(firstNode);
        int expectedResult = 1;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test

=== Chunk 938 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0530.minimum-absolute-difference-in-bst\MinimumAbsoluteDifferenceInBstTest.java

}

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(0);
        TreeNode thirdNode = new TreeNode(48);
        TreeNode forthNode = new TreeNode(12);
        TreeNode fifthNode = new TreeNode(49);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        thirdNode.left = forthNode;
        thirdNode.right = fifthNode;

        int results = MinimumAbsoluteDifferenceInBst.getMinimumDifference(firstNode);
        int expectedResult = 1;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 939 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0538.convert-bst-to-greater-tree\ConvertBstToGreaterTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class ConvertBstToGreaterTree {
    private int sum = 0;

    private void traver(TreeNode node) {
        if (node == null) return;
        traver(node.right);
        sum += node.val;
        node.val = sum;
        traver(node.left);
    }

    public TreeNode convertBST(TreeNode root) {
        traver(root);
        return root;
    }
}

=== Chunk 940 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0538.convert-bst-to-greater-tree\ConvertBstToGreaterTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 941 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0538.convert-bst-to-greater-tree\ConvertBstToGreaterTreeTest.java

public class ConvertBstToGreaterTreeTest {
    ConvertBstToGreaterTree ConvertBstToGreaterTree = new ConvertBstToGreaterTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(4);
        TreeNode secondNode = new TreeNode(1);
        TreeNode thirdNode = new TreeNode(6);
        TreeNode forthNode = new TreeNode(0);
        TreeNode fifthNode = new TreeNode(2);
        TreeNode sixthNode = new TreeNode(5);
        TreeNode seventhNode = new TreeNode(7);
        TreeNode eighthNode = new TreeNode(3);
        TreeNode ninthNode = new TreeNode(8);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        thirdNode.left = sixthNode;

=== Chunk 942 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0538.convert-bst-to-greater-tree\ConvertBstToGreaterTreeTest.java

thirdNode.left = sixthNode;
        thirdNode.right = seventhNode;
        fifthNode.right =eighthNode;
        seventhNode.right = ninthNode;

        TreeNode results = ConvertBstToGreaterTree.convertBST(firstNode);
        Assertions.assertEquals(30, results.val);
        Assertions.assertEquals(36, results.left.val);
        Assertions.assertEquals(21, results.right.val);
        Assertions.assertEquals(36, results.left.left.val);
        Assertions.assertEquals(35, results.left.right.val);
        Assertions.assertEquals(26, results.right.left.val);
        Assertions.assertEquals(15, results.right.right.val);
        Assertions.assertEquals(33, results.left.right.right.val);
        Assertions.assertEquals(8, results.right.right.right.val);
    }

    @Test

=== Chunk 943 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0538.convert-bst-to-greater-tree\ConvertBstToGreaterTreeTest.java

}

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(0);
        firstNode.right = new TreeNode(1);

        TreeNode results = ConvertBstToGreaterTree.convertBST(firstNode);

        Assertions.assertEquals(1, results.val);
        Assertions.assertEquals(1, results.right.val);
    }
}

=== Chunk 944 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0540.single-element-in-a-sorted-array\SingleElementInASortedArray.java

class SingleElementInASortedArray {
    public int singleNonDuplicate(int[] nums) {
        int l = 0, h = nums.length - 1;
        while (l < h) {
            int m = l + (h - l) / 2;
            if (m % 2 == 1)
                m--;
            if (nums[m] == nums[m + 1])
                l = m + 2;
            else
                h = m;
        }
        return nums[l];
    }
}

=== Chunk 945 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0540.single-element-in-a-sorted-array\SingleElementInASortedArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SingleElementInASortedArrayTest {
    SingleElementInASortedArray SingleElementInASortedArray = new SingleElementInASortedArray();

    @Test
    void Example1() {
        int[] nums = {1, 1, 2, 3, 3, 4, 4, 8, 8};

        Assertions.assertEquals(2, SingleElementInASortedArray.singleNonDuplicate(nums));
    }

    @Test
    void Example2() {
        int[] nums = {3, 3, 7, 7, 10, 11, 11};

        Assertions.assertEquals(10, SingleElementInASortedArray.singleNonDuplicate(nums));
    }
}

=== Chunk 946 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0542.01-matrix\ZeroOneMatrix.java

import java.util.LinkedList;
import java.util.Queue;

=== Chunk 947 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0542.01-matrix\ZeroOneMatrix.java

class ZeroOneMatrix {
    public int[][] updateMatrix(int[][] mat) {
        Queue<int[]> queue = new LinkedList<>();
        for (int i = 0; i < mat.length; i++) {
            for (int j = 0; j < mat[i].length; j++) {
                if (mat[i][j] == 0) queue.add(new int[] {i, j});
                else mat[i][j] = -1;
            }
        }
        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int length = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            length++;
            while (size-- > 0 && queue.peek() != null) {
                int[] rc = queue.poll();
                for (int[] dir : dirs) {
                    int r = rc[0] + dir[0];
                    int c = rc[1] + dir[1];

=== Chunk 948 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0542.01-matrix\ZeroOneMatrix.java

int c = rc[1] + dir[1];
                    if (r < 0 || c < 0 || r >= mat.length || c >= mat[0].length || mat[r][c] != -1) continue;
                    mat[r][c] = length;
                    queue.add(new int[]{r, c});
                }
            }
        }

        return mat;
    }
}

=== Chunk 949 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0542.01-matrix\ZeroOneMatrixTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ZeroOneMatrixTest {
    ZeroOneMatrix ZeroOneMatrix = new ZeroOneMatrix();

    @Test
    void Example1() {
        int[][] mat = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};
        int[][] results = ZeroOneMatrix.updateMatrix(mat);
        int[][] expectedResults = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};
        
        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] mat = {{0, 0, 0}, {0, 1, 0}, {1, 1, 1}};
        int[][] results = ZeroOneMatrix.updateMatrix(mat);
        int[][] expectedResults = {{0, 0, 0}, {0, 1, 0}, {1, 2, 1}};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 950 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0543.diameter-of-binary-tree\DiameterOfBinaryTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 951 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0543.diameter-of-binary-tree\DiameterOfBinaryTree.java

class DiameterOfBinaryTree {
    private int max = 0;

    private int depth(TreeNode root) {
        if (root == null) return 0;
        int leftDepth = depth(root.left);
        int rightDepth = depth(root.right);
        max = Math.max(max, leftDepth + rightDepth);
        return Math.max(leftDepth, rightDepth) + 1;
    }

    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return max;
    }
}

=== Chunk 952 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0543.diameter-of-binary-tree\DiameterOfBinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 953 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0543.diameter-of-binary-tree\DiameterOfBinaryTreeTest.java

public class DiameterOfBinaryTreeTest {
    DiameterOfBinaryTree DiameterOfBinaryTree = new DiameterOfBinaryTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(3);
        TreeNode forthNode = new TreeNode(4);
        TreeNode fifthNode = new TreeNode(5);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;

        int expectedResult = 3;
        int results = DiameterOfBinaryTree.diameterOfBinaryTree(firstNode);

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {

=== Chunk 954 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0543.diameter-of-binary-tree\DiameterOfBinaryTreeTest.java

}

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(1);
        firstNode.left = new TreeNode(2);

        int expectedResult = 1;
        int results = DiameterOfBinaryTree.diameterOfBinaryTree(firstNode);

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 955 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0547.number-of-provinces\NumberOfProvinces.java

class NumberOfProvinces {
    private void dfs(int[][] isConnected, int i, boolean[] visited) {
        for (int j = 0; j < isConnected[i].length; j++) {
            if (!visited[j] && isConnected[i][j] != 0) {
                visited[i] = true;
                dfs(isConnected, j, visited);
            }
        }
    }

    public int findCircleNum(int[][] isConnected) {
        boolean[] visited = new boolean[isConnected.length];
        int count = 0;
        for (int i = 0; i < isConnected.length; i++) {
            if (!visited[i]) {
                count++;
                dfs(isConnected, i, visited);
            }
        }
        return count;
    }
}

=== Chunk 956 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0547.number-of-provinces\NumberOfProvincesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class NumberOfProvincesTest {
    NumberOfProvinces NumberOfProvinces = new NumberOfProvinces();

    @Test
    void Example1() {
        int[][] isConnected = {{1, 1, 0}, {1, 1, 0}, {0, 0, 1}};
        int results = NumberOfProvinces.findCircleNum(isConnected);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] isConnected = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
        int results = NumberOfProvinces.findCircleNum(isConnected);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 957 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0557.reverse-words-in-a-string-iii\ReverseWordsInAStringIii.java

class ReverseWordsInAStringIii {
    private void reverseWords(char[] chars, int r, int l) {
        while (l < r) {
            char temp = chars[r];
            chars[r] = chars[l];
            chars[l] = temp;
            l++;
            r--;
        }
    }

    public String reverseWords(String s) {
        char[] chars = s.toCharArray();
        int l = 0, r;
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == ' ') {
                r = i - 1;
                reverseWords(chars, r, l);
                l = i + 1;
            }
        }
        r = chars.length - 1;
        reverseWords(chars, r, l);

        return String.valueOf(chars);
    }
}

=== Chunk 958 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0557.reverse-words-in-a-string-iii\ReverseWordsInAStringIiiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ReverseWordsInAStringIiiTest {
    ReverseWordsInAStringIii ReverseWordsInAStringIii = new ReverseWordsInAStringIii();

    @Test
    void Example1() {
        String s = "Let's take LeetCode contest";
        String results = ReverseWordsInAStringIii.reverseWords(s);
        String expectedResults = "s'teL ekat edoCteeL tsetnoc";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "God Ding";
        String results = ReverseWordsInAStringIii.reverseWords(s);
        String expectedResults = "doG gniD";

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 959 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0565.array-nesting\ArrayNesting.java

class ArrayNesting {
    public int arrayNesting(int[] nums) {
        int max = 0;
        for (int i = 0; i < nums.length; i++) {
            int cnt = 0;
            for (int j = i; nums[j] != -1;) {
                cnt++;
                int t = nums[j];
                nums[j] = -1;
                j = t;
            }
            max = Math.max(max, cnt);
        }
        return max;
    }
}

=== Chunk 960 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0565.array-nesting\ArrayNestingTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ArrayNestingTest {
    ArrayNesting ArrayNesting = new ArrayNesting();

    @Test
    void Example1() {
        int[] nums = {5, 4, 0, 3, 1, 6, 2};
        int results = ArrayNesting.arrayNesting(nums);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {0, 1, 2};
        int results = ArrayNesting.arrayNesting(nums);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 961 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0566.reshape-the-matrix\ReshapeTheMatrix.java

class ReshapeTheMatrix {
    public int[][] matrixReshape(int[][] mat, int r, int c) {
        int m = mat.length, n = mat[0].length;
        if (m * n != r * c) {
            return mat;
        }
        int[][] reshapedNums = new int[r][c];
        int idx = 0;
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                reshapedNums[i][j] = mat[idx / n][idx % n];
                idx++;
            }
        }
        return reshapedNums;
    }
}

=== Chunk 962 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0566.reshape-the-matrix\ReshapeTheMatrixTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ReshapeTheMatrixTest {
    ReshapeTheMatrix ReshapeTheMatrix = new ReshapeTheMatrix();

    @Test
    void Example1() {
        int[][] mat = {{1, 2}, {3, 4}};

        int r = 1, c = 4;
        int[][] results = ReshapeTheMatrix.matrixReshape(mat, r, c);
        int[][] expectedResults = {{1, 2, 3, 4}};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] mat = {{1, 2}, {3, 4}};

        int r = 2, c = 4;
        int[][] results = ReshapeTheMatrix.matrixReshape(mat, r, c);
        int[][] expectedResults = {{1, 2}, {3, 4}};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 963 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0567.permutation-in-string\PermutationInString.java

class PermutationInString {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() > s2.length()) return false;
        int[] s1Count = new int[26];
        int[] s2Count = new int[26];
        for (int i = 0; i < s1.length(); i++) {
            s1Count[s1.charAt(i) - 'a']++;
            s2Count[s2.charAt(i) - 'a']++;
        }

        int matches = 0;
        for (int i = 0; i < 26; i++) {
            matches += s1Count[i] == s2Count[i] ? 1 : 0;
        }

        int l = 0;
        for (int r = s1.length(); r < s2.length(); r++) {
            if (matches == 26) return true;

            int index = s2.charAt(r) - 'a';
            s2Count[index]++;
            if (s1Count[index] == s2Count[index]) {
                matches++;

=== Chunk 964 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0567.permutation-in-string\PermutationInString.java

matches++;
            } else if (s1Count[index] + 1 == s2Count[index]) {
                matches--;
            }

            index = s2.charAt(l) - 'a';
            s2Count[index]--;
            if (s1Count[index] == s2Count[index]) {
                matches++;
            } else if (s1Count[index] - 1 == s2Count[index]) {
                matches--;
            }
            l++;
        }

        return matches == 26;
    }
}

=== Chunk 965 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0567.permutation-in-string\PermutationInStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class PermutationInStringTest {
    PermutationInString PermutationInString = new PermutationInString();

    @Test
    void Example1() {
        String s1 = "ab", s2 = "eidbaooo";
        boolean results = PermutationInString.checkInclusion(s1, s2);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s1 = "ab", s2 = "eidboaoo";
        boolean results = PermutationInString.checkInclusion(s1, s2);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 966 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0572.subtree-of-another-tree\SubtreeOfAnotherTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 967 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0572.subtree-of-another-tree\SubtreeOfAnotherTree.java

class SubtreeOfAnotherTree {
    private boolean isSubtreeWithRoot(TreeNode root, TreeNode subRoot) {
        if (root == null && subRoot == null) return true;
        if (root == null || subRoot == null || root.val != subRoot.val) return false;
        return isSubtreeWithRoot(root.left, subRoot.left) && isSubtreeWithRoot(root.right, subRoot.right);
    }

    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if (root == null) return false;
        return isSubtreeWithRoot(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
    }
}

=== Chunk 968 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0572.subtree-of-another-tree\SubtreeOfAnotherTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 969 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0572.subtree-of-another-tree\SubtreeOfAnotherTreeTest.java

public class SubtreeOfAnotherTreeTest {
    SubtreeOfAnotherTree SubtreeOfAnotherTree = new SubtreeOfAnotherTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(4);
        TreeNode thirdNode = new TreeNode(5);
        TreeNode forthNode = new TreeNode(1);
        TreeNode fifthNode = new TreeNode(2);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;

        TreeNode subRootFirstNode = new TreeNode(4);
        TreeNode subRootSecondNode = new TreeNode(1);
        TreeNode subRootThirdNode = new TreeNode(2);

        subRootFirstNode.left = subRootSecondNode;

=== Chunk 970 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0572.subtree-of-another-tree\SubtreeOfAnotherTreeTest.java

subRootFirstNode.right = subRootThirdNode;

        boolean results = SubtreeOfAnotherTree.isSubtree(firstNode, subRootFirstNode);
        boolean expectedResult = true;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(4);
        TreeNode thirdNode = new TreeNode(5);
        TreeNode forthNode = new TreeNode(1);
        TreeNode fifthNode = new TreeNode(2);
        TreeNode sixthNode = new TreeNode(0);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        fifthNode.left = sixthNode;

=== Chunk 971 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0572.subtree-of-another-tree\SubtreeOfAnotherTreeTest.java

fifthNode.left = sixthNode;

        TreeNode subRootFirstNode = new TreeNode(4);
        TreeNode subRootSecondNode = new TreeNode(1);
        TreeNode subRootThirdNode = new TreeNode(2);

        subRootFirstNode.left = subRootSecondNode;
        subRootFirstNode.right = subRootThirdNode;

        boolean results = SubtreeOfAnotherTree.isSubtree(firstNode, subRootFirstNode);
        boolean expectedResult = false;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 972 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0576.out-of-boundary-paths\OutOfBoundaryPaths.java

class OutOfBoundaryPaths {
    private Long[][][] memo = null;
    private final int mod = (int) Math.pow(10, 9) + 7;

    private long findPathsHelper(int m, int n, int maxMove, int row, int col) {
        if (maxMove < 0) return 0;
        if (row == m || col == n || row == -1 || col == -1) return 1;
        if (memo[row][col][maxMove] != null) return memo[row][col][maxMove];

        long leftMaxMoveReduced = findPathsHelper(m, n, maxMove - 1, row, col - 1);
        long rightMaxMoveReduced = findPathsHelper(m, n, maxMove - 1, row,col + 1);
        long upMaxMovedReduced = findPathsHelper(m, n, maxMove - 1, row - 1, col);
        long downMaxMovedReduced = findPathsHelper(m, n, maxMove - 1, row + 1, col);

=== Chunk 973 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0576.out-of-boundary-paths\OutOfBoundaryPaths.java

long total = (leftMaxMoveReduced + rightMaxMoveReduced + upMaxMovedReduced + downMaxMovedReduced) % mod;
        memo[row][col][maxMove] = total;
        return total;
    }

    public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        memo = new Long[m + 1][n + 1][maxMove + 1];
        return (int) findPathsHelper(m, n, maxMove, startRow, startColumn);
    }
}

=== Chunk 974 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0576.out-of-boundary-paths\OutOfBoundaryPathsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class OutOfBoundaryPathsTest {
    OutOfBoundaryPaths OutOfBoundaryPaths = new OutOfBoundaryPaths();

    @Test
    void Example1() {
        int m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0;

        int results = OutOfBoundaryPaths.findPaths(m, n, maxMove, startRow, startColumn);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1;

        int results = OutOfBoundaryPaths.findPaths(m, n, maxMove, startRow, startColumn);
        int expectedResults = 12;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 975 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0587.erect-the-fence\ErectTheFence.java

import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Stack;

=== Chunk 976 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0587.erect-the-fence\ErectTheFence.java

class ErectTheFence {
    public int orientation(int[] p, int[] q, int[] r) {
        return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
    }

    public int[][] outerTrees(int[][] trees) {
        Arrays.sort(trees, new Comparator<int[]>() {
            public int compare(int[] p, int[] q) {
                return q[0] - p[0] == 0 ? q[1] - p[1] : q[0] - p[0];
            }
        });
        Stack<int[]> hull = new Stack<>();
        for (int[] tree : trees) {
            while (hull.size() >= 2 && orientation(hull.get(hull.size() - 2), hull.get(hull.size() - 1), tree) > 0)
                hull.pop();
            hull.push(tree);
        }
        hull.pop();
        for (int i = trees.length - 1; i >= 0; i--) {

=== Chunk 977 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0587.erect-the-fence\ErectTheFence.java

while (hull.size() >= 2 && orientation(hull.get(hull.size() - 2), hull.get(hull.size() - 1), trees[i]) > 0)
                hull.pop();
            hull.push(trees[i]);
        }
        HashSet<int[]> ret = new HashSet<>(hull);
        return ret.toArray(new int[ret.size()][]);
    }
}

=== Chunk 978 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0587.erect-the-fence\ErectTheFenceTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

=== Chunk 979 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0587.erect-the-fence\ErectTheFenceTest.java

public class ErectTheFenceTest {
    ErectTheFence ErectTheFence = new ErectTheFence();

    @Test
    void Example1() {
        int[][] points = {{1, 1}, {2, 2}, {2, 0}, {2, 4}, {3, 3}, {4, 2}};
        int[][] results = ErectTheFence.outerTrees(points);
        int[][] expectedResults = {{1, 1}, {2, 0}, {4, 2}, {3, 3}, {2, 4}};

        List<List<Integer>> resultsList = new ArrayList<>();
        for (int[] result : results) {
            List<Integer> rList = new ArrayList<>();
            for (int r : result) {
                rList.add(r);
            }
            resultsList.add(rList);
        }
        List<List<Integer>> expectedResultsList = new ArrayList<>();
        for (int[] expectedResult : expectedResults) {

=== Chunk 980 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0587.erect-the-fence\ErectTheFenceTest.java

List<Integer> rList = new ArrayList<>();
            for (int er : expectedResult) {
                rList.add(er);
            }
            expectedResultsList.add(rList);
        }

        Assertions.assertEquals(expectedResults.length, results.length);
        Assertions.assertTrue(resultsList.containsAll(expectedResultsList));
    }

    @Test
    void Example2() {
        int[][] points = {{1, 2}, {2, 2}, {4, 2}};
        int[][] results = ErectTheFence.outerTrees(points);
        int[][] expectedResults = {{2, 2}, {4, 2}, {1, 2}};

        List<List<Integer>> resultsList = new ArrayList<>();
        for (int[] result : results) {
            List<Integer> rList = new ArrayList<>();
            for (int r : result) {
                rList.add(r);

=== Chunk 981 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0587.erect-the-fence\ErectTheFenceTest.java

rList.add(r);
            }
            resultsList.add(rList);
        }
        List<List<Integer>> expectedResultsList = new ArrayList<>();
        for (int[] expectedResult : expectedResults) {
            List<Integer> rList = new ArrayList<>();
            for (int er : expectedResult) {
                rList.add(er);
            }
            expectedResultsList.add(rList);
        }

        Assertions.assertEquals(expectedResults.length, results.length);
        Assertions.assertTrue(resultsList.containsAll(expectedResultsList));
    }
}

=== Chunk 982 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0589.n-ary-tree-preorder-traversal\NAryTreePreorderTraversal.java

/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

import java.util.ArrayList;
import java.util.List;

class NAryTreePreorderTraversal {
    private final List<Integer> res = new ArrayList<>();

    public List<Integer> preorder(Node root) {
        if (root == null) return res;
        res.add(root.val);
        if (root.children == null) return res;
        for (int i = 0; i < root.children.size(); i++) {
            preorder(root.children.get(i));
        }

        return res;
    }
}

=== Chunk 983 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0589.n-ary-tree-preorder-traversal\NAryTreePreorderTraversalTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

=== Chunk 984 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0589.n-ary-tree-preorder-traversal\NAryTreePreorderTraversalTest.java

public class NAryTreePreorderTraversalTest {
    NAryTreePreorderTraversal NAryTreePreorderTraversal = new NAryTreePreorderTraversal();

    @Test
    void Example1() {
        Node root = new Node(1);
        Node secondFirst = new Node(3);
        Node secondSecond = new Node(2);
        Node secondThird = new Node(4);
        root.children = Arrays.asList(secondFirst, secondSecond, secondThird);
        Node thirdFirst = new Node(5);
        Node thirdSecond = new Node(6);
        secondFirst.children = Arrays.asList(thirdFirst, thirdSecond);

        List<Integer> results = NAryTreePreorderTraversal.preorder(root);
        List<Integer> expectedResults = Arrays.asList(1, 3, 5, 6, 2, 4);

        Assertions.assertEquals(expectedResults, results);
    }

    @Test

=== Chunk 985 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0589.n-ary-tree-preorder-traversal\NAryTreePreorderTraversalTest.java

}

    @Test
    void Example2() {
        Node root = new Node(1);
        Node secondFirst = new Node(2);
        Node secondSecond = new Node(3);
        Node secondThird = new Node(4);
        Node secondForth = new Node(5);
        root.children = Arrays.asList(secondFirst, secondSecond, secondThird, secondForth);
        Node thirdFirst = new Node(6);
        Node thirdSecond = new Node(7);
        Node thirdThird = new Node(8);
        Node thirdForth = new Node(9);
        Node thirdFifth = new Node(10);
        secondSecond.children = Arrays.asList(thirdFirst, thirdSecond);
        secondThird.children = List.of(thirdThird);
        secondForth.children = Arrays.asList(thirdForth, thirdFifth);
        Node forthFirst = new Node(11);

=== Chunk 986 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0589.n-ary-tree-preorder-traversal\NAryTreePreorderTraversalTest.java

Node forthFirst = new Node(11);
        Node forthSecond = new Node(12);
        Node forthThird = new Node(13);
        thirdSecond.children = List.of(forthFirst);
        thirdThird.children = List.of(forthSecond);
        thirdForth.children = List.of(forthThird);
        Node fifthFirst = new Node(14);
        forthFirst.children = List.of(fifthFirst);

        List<Integer> results = NAryTreePreorderTraversal.preorder(root);
        List<Integer> expectedResults = Arrays.asList(1, 2, 3, 6, 7, 11, 14, 4, 8, 12, 5, 9, 13, 10);

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 987 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0594.longest-harmonious-subsequence\LongestHarmoniousSubsequence.java

import java.util.HashMap;
import java.util.Map;

class LongestHarmoniousSubsequence {
    public int findLHS(int[] nums) {
        Map<Integer, Integer> countForNum = new HashMap<>();
        for (int num : nums) {
            countForNum.put(num, countForNum.getOrDefault(num, 0) + 1);
        }
        int longest = 0;
        for (int num : countForNum.keySet()) {
            if (countForNum.containsKey(num + 1)) {
                longest = Math.max(longest, countForNum.get(num + 1) + countForNum.get(num));
            }
        }
        return longest;
    }
}

=== Chunk 988 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0594.longest-harmonious-subsequence\LongestHarmoniousSubsequenceTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 989 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0594.longest-harmonious-subsequence\LongestHarmoniousSubsequenceTest.java

public class LongestHarmoniousSubsequenceTest {
    LongestHarmoniousSubsequence LongestHarmoniousSubsequence = new LongestHarmoniousSubsequence();

    @Test
    void Example1() {
        int[] nums = {1, 3, 2, 2, 5, 2, 3, 7};

        int results = LongestHarmoniousSubsequence.findLHS(nums);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 2, 3, 4};

        int results = LongestHarmoniousSubsequence.findLHS(nums);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {1, 1, 1, 1};

        int results = LongestHarmoniousSubsequence.findLHS(nums);

=== Chunk 990 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0594.longest-harmonious-subsequence\LongestHarmoniousSubsequenceTest.java

int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 991 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0605.can-place-flowers\CanPlaceFlowers.java

class CanPlaceFlowers {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int count = 0, m = flowerbed.length, prev = -1;
        for (int i = 0; i < m; i++) {
            if (flowerbed[i] == 1) {
                if (prev < 0) {
                    count += i / 2;
                } else {
                    count += (i - prev - 2) / 2;
                }
                if (count >= n) {
                    return true;
                }
                prev = i;
            }
        }
        if (prev < 0) {
            count += (m + 1) / 2;
        } else {
            count += (m - prev - 1) / 2;
        }
        return count >= n;
    }
}

=== Chunk 992 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0605.can-place-flowers\CanPlaceFlowersTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class CanPlaceFlowersTest {
    CanPlaceFlowers CanPlaceFlowers = new CanPlaceFlowers();

    @Test
    void Example1() {
        int[] flowerbed = {1, 0, 0, 0, 1};
        int n = 1;
        boolean results = CanPlaceFlowers.canPlaceFlowers(flowerbed, n);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] flowerbed = {1, 0, 0, 0, 1};
        int n = 2;
        boolean results = CanPlaceFlowers.canPlaceFlowers(flowerbed, n);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 993 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0606.construct-string-from-binary-tree\ConstructStringFromBinaryTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class ConstructStringFromBinaryTree {
    public String tree2str(TreeNode root) {
        if (root == null) return "";
        if (root.left == null && root.right == null) {
            return root.val + "";
        }
        if (root.right == null) return root.val + "(" + tree2str(root.left) + ")";
        return root.val + "(" + tree2str(root.left) + ")(" + tree2str(root.right) + ")";
    }
}

=== Chunk 994 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0606.construct-string-from-binary-tree\ConstructStringFromBinaryTree2.java

import java.util.HashSet;
import java.util.Set;
import java.util.Stack;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 995 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0606.construct-string-from-binary-tree\ConstructStringFromBinaryTree2.java

class ConstructStringFromBinaryTree2 {
    public String tree2str(TreeNode root) {
        if (root == null) return "";
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        Set<TreeNode> visited = new HashSet<>();
        StringBuilder s = new StringBuilder();
        while (!stack.empty()) {
            root = stack.peek();
            if (visited.contains(root)) {
                stack.pop();
                s.append(")");
            } else {
                visited.add(root);
                s.append("(" + root.val);
                if (root.left == null && root.right != null) s.append("()");
                if (root.right != null) stack.push(root.right);
                if (root.left != null) stack.push(root.left);
            }

=== Chunk 996 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0606.construct-string-from-binary-tree\ConstructStringFromBinaryTree2.java

}
        }
        return s.substring(1, s.length() - 1);
    }
}

=== Chunk 997 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0606.construct-string-from-binary-tree\ConstructStringFromBinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 998 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0606.construct-string-from-binary-tree\ConstructStringFromBinaryTreeTest.java

public class ConstructStringFromBinaryTreeTest {
    ConstructStringFromBinaryTree ConstructStringFromBinaryTree = new ConstructStringFromBinaryTree();
    ConstructStringFromBinaryTree2 ConstructStringFromBinaryTree2 = new ConstructStringFromBinaryTree2();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.left.left = new TreeNode(4);
        root.right = new TreeNode(3);
        String results = ConstructStringFromBinaryTree.tree2str(root);
        String expectedResults = "1(2(4))(3)";

        Assertions.assertEquals(expectedResults, results);

        results = ConstructStringFromBinaryTree2.tree2str(root);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test

=== Chunk 999 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0606.construct-string-from-binary-tree\ConstructStringFromBinaryTreeTest.java

}

    @Test
    void Example2() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.left.right = new TreeNode(4);
        root.right = new TreeNode(3);
        String results = ConstructStringFromBinaryTree.tree2str(root);
        String expectedResults = "1(2()(4))(3)";

        Assertions.assertEquals(expectedResults, results);

        results = ConstructStringFromBinaryTree2.tree2str(root);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1000 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0609.find-duplicate-file-in-system\FindDuplicateFileInSystem.java

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

=== Chunk 1001 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0609.find-duplicate-file-in-system\FindDuplicateFileInSystem.java

class FindDuplicateFileInSystem {
    public List<List<String>> findDuplicate(String[] paths) {
        HashMap<String, List<String>> map = new HashMap<>();
        for (String path : paths) {
            String[] values = path.split(" ");
            for (int i = 1; i < values.length; i++) {
                String[] nameCont = values[i].split("\\(");
                nameCont[1] = nameCont[1].replace(")", "");
                List<String> list = map.getOrDefault(nameCont[1], new ArrayList<>());
                list.add(values[0] + "/" + nameCont[0]);
                map.put(nameCont[1], list);
            }
        }
        List<List<String>> res = new ArrayList<>();
        for (String key : map.keySet()) {
            if (map.get(key).size() > 1) {

=== Chunk 1002 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0609.find-duplicate-file-in-system\FindDuplicateFileInSystem.java

if (map.get(key).size() > 1) {
                res.add(map.get(key));
            }
        }
        return res;
    }
}

=== Chunk 1003 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0609.find-duplicate-file-in-system\FindDuplicateFileInSystemTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 1004 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0609.find-duplicate-file-in-system\FindDuplicateFileInSystemTest.java

public class FindDuplicateFileInSystemTest {
    FindDuplicateFileInSystem FindDuplicateFileInSystem = new FindDuplicateFileInSystem();

    @Test
    void Example1() {
        String[] paths = {"root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"};
        List<List<String>> results = FindDuplicateFileInSystem.findDuplicate(paths);
        List<List<String>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList("root/a/2.txt", "root/c/d/4.txt", "root/4.txt"));
        expectedResults.add(Arrays.asList("root/a/1.txt", "root/c/3.txt"));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {

=== Chunk 1005 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0609.find-duplicate-file-in-system\FindDuplicateFileInSystemTest.java

}

    @Test
    void Example2() {
        String[] paths = {"root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)"};
        List<List<String>> results = FindDuplicateFileInSystem.findDuplicate(paths);
        List<List<String>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList("root/a/2.txt", "root/c/d/4.txt"));
        expectedResults.add(Arrays.asList("root/a/1.txt", "root/c/3.txt"));

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1006 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0617.merge-two-binary-trees\MergeTwoBinaryTrees.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1007 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0617.merge-two-binary-trees\MergeTwoBinaryTrees.java

class MergeTwoBinaryTrees {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) return null;
        if (root1 == null) return root2;
        if (root2 == null) return root1;
        TreeNode root = new TreeNode(root1.val + root2.val);
        root.left = mergeTrees(root1.left, root2.left);
        root.right = mergeTrees(root1.right, root2.right);
        return root;
    }
}

=== Chunk 1008 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0617.merge-two-binary-trees\MergeTwoBinaryTreesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1009 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0617.merge-two-binary-trees\MergeTwoBinaryTreesTest.java

public class MergeTwoBinaryTreesTest {
    MergeTwoBinaryTrees MergeTwoBinaryTrees = new MergeTwoBinaryTrees();

    @Test
    void Example1() {
        TreeNode root1FirstNode = new TreeNode(1);
        TreeNode root1SecondNode = new TreeNode(3);
        TreeNode root1ThirdNode = new TreeNode(2);
        TreeNode root1ForthNode = new TreeNode(5);

        root1FirstNode.left = root1SecondNode;
        root1FirstNode.right = root1ThirdNode;
        root1SecondNode.left = root1ForthNode;

        TreeNode root2FirstNode = new TreeNode(2);
        TreeNode root2SecondNode = new TreeNode(1);
        TreeNode root2ThirdNode = new TreeNode(3);
        TreeNode root2ForthNode = new TreeNode(4);
        TreeNode root2FifthNode = new TreeNode(7);

=== Chunk 1010 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0617.merge-two-binary-trees\MergeTwoBinaryTreesTest.java

root2FirstNode.left = root2SecondNode;
        root2FirstNode.right = root2ThirdNode;
        root2SecondNode.right = root2ForthNode;
        root2ThirdNode.right = root2FifthNode;

        TreeNode results = MergeTwoBinaryTrees.mergeTrees(root1FirstNode, root2FirstNode);

        Assertions.assertEquals(3, results.val);
        Assertions.assertEquals(4, results.left.val);
        Assertions.assertEquals(5, results.right.val);
        Assertions.assertEquals(5, results.left.left.val);
        Assertions.assertEquals(4, results.left.right.val);
        Assertions.assertNull(results.right.left);
        Assertions.assertEquals(7, results.right.right.val);
    }

    @Test
    void Example2() {
        TreeNode root1FirstNode = new TreeNode(1);

=== Chunk 1011 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0617.merge-two-binary-trees\MergeTwoBinaryTreesTest.java

TreeNode root2FirstNode = new TreeNode(1);
        root2FirstNode.left = new TreeNode(2);

        TreeNode results = MergeTwoBinaryTrees.mergeTrees(root1FirstNode, root2FirstNode);

        Assertions.assertEquals(2, results.val);
        Assertions.assertEquals(2, results.left.val);
    }
}

=== Chunk 1012 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0621.task-scheduler\TaskScheduler.java

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

=== Chunk 1013 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0621.task-scheduler\TaskScheduler.java

class TaskScheduler {
    public int leastInterval(char[] tasks, int n) {
        if (n == 0) return tasks.length;
        Map<Character, Integer> map = new HashMap<>();
        for (char task : tasks) {
            map.put(task, map.getOrDefault(task, 0) + 1);
        }

        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        pq.addAll(map.values());
        int maxFreq = pq.poll();
        int totalIdleTime = (maxFreq - 1) * n;
        while (!pq.isEmpty()) {
            int currentFreq = pq.poll();
            totalIdleTime -= currentFreq;
            if (currentFreq == maxFreq) {
                totalIdleTime += 1;
            }
        }

        if (totalIdleTime > 0) return totalIdleTime + tasks.length;

=== Chunk 1014 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0621.task-scheduler\TaskScheduler.java

else return tasks.length;
    }
}

=== Chunk 1015 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0621.task-scheduler\TaskSchedulerTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1016 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0621.task-scheduler\TaskSchedulerTest.java

public class TaskSchedulerTest {
    TaskScheduler TaskScheduler = new TaskScheduler();

    @Test
    void Example1() {
        char[] tasks = {'A', 'A', 'A', 'B', 'B', 'B'};
        int n = 2;
        int results = TaskScheduler.leastInterval(tasks,  n);
        int expectedResults = 8;

        Assertions.assertEquals(expectedResults,  results);
    }

    @Test
    void Example2() {
        char[] tasks = {'A', 'A', 'A', 'B', 'B', 'B'};
        int n = 0;
        int results = TaskScheduler.leastInterval(tasks,  n);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults,  results);
    }

    @Test
    void Example3() {
        char[] tasks = {'A', 'A', 'A', 'A', 'A', 'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        int n = 2;

=== Chunk 1017 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0621.task-scheduler\TaskSchedulerTest.java

int n = 2;
        int results = TaskScheduler.leastInterval(tasks,  n);
        int expectedResults = 16;

        Assertions.assertEquals(expectedResults,  results);
    }
}

=== Chunk 1018 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0622.design-circular-queue\DesignCircularQueue.java

class MyCircularQueue {
    private final int maxSize;
    private int size = 0;
    private ListNode head = null, tail = null;

    public MyCircularQueue(int k) {
        maxSize = k;
    }
    
    public boolean enQueue(int value) {
        if (isFull()) return false;
        ListNode newNode = new ListNode(value);
        if (isEmpty()) head = tail = newNode;
        else {
            tail.next = newNode;
            tail = tail.next;
        }
        size++;
        return true;
    }
    
    public boolean deQueue() {
        if (isEmpty()) return false;
        head = head.next;
        size--;
        return true;
    }
    
    public int Front() {
        return isEmpty() ? -1 : head.val;
    }
    
    public int Rear() {

=== Chunk 1019 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0622.design-circular-queue\DesignCircularQueue.java

}
    
    public int Rear() {
        return isEmpty() ? -1 : tail.val;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return maxSize == size;
    }
}

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */

=== Chunk 1020 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0622.design-circular-queue\DesignCircularQueueTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class DesignCircularQueueTest {
    @Test
    void Example1() {
        MyCircularQueue myCircularQueue = new MyCircularQueue(3);
        Assertions.assertTrue(myCircularQueue.enQueue(1));
        Assertions.assertTrue(myCircularQueue.enQueue(2));
        Assertions.assertTrue(myCircularQueue.enQueue(3));
        Assertions.assertFalse(myCircularQueue.enQueue(4));
        Assertions.assertEquals(3, myCircularQueue.Rear());
        Assertions.assertTrue(myCircularQueue.isFull());
        Assertions.assertTrue(myCircularQueue.deQueue());
        Assertions.assertTrue(myCircularQueue.enQueue(4));
        Assertions.assertEquals(4, myCircularQueue.Rear());
    }
}

=== Chunk 1021 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0623.add-one-row-to-tree\AddOneRowToTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1022 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0623.add-one-row-to-tree\AddOneRowToTree.java

class AddOneRowToTree {
    private void InsertRow(TreeNode root, int val, int depth) {
        if (root == null) return;
        if (depth == 0) {
            TreeNode leftNode = root.left;
            TreeNode rightNode = root.right;
            root.left = new TreeNode(val);
            root.right = new TreeNode(val);
            root.left.left = leftNode;
            root.right.right = rightNode;
        } else {
            InsertRow(root.left, val, depth - 1);
            InsertRow(root.right, val, depth - 1);
        }
    }

    public TreeNode addOneRow(TreeNode root, int val, int depth) {
        if (depth == 1) {
            TreeNode res = new TreeNode(val);
            res.left = root;
            return res;
        }

=== Chunk 1023 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0623.add-one-row-to-tree\AddOneRowToTree.java

return res;
        }
        InsertRow(root, val, depth - 2);
        return root;
    }
}

=== Chunk 1024 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0623.add-one-row-to-tree\AddOneRowToTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1025 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0623.add-one-row-to-tree\AddOneRowToTreeTest.java

public class AddOneRowToTreeTest {
    AddOneRowToTree AddOneRowToTree = new AddOneRowToTree();

    @Test
    void Example1() {
        int val = 1, depth = 2;
        TreeNode root = new TreeNode(4);
        root.left = new TreeNode(2);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(1);
        root.right = new TreeNode(6);
        root.right.left = new TreeNode(5);
        TreeNode results = AddOneRowToTree.addOneRow(root, val, depth);

        Assertions.assertEquals(1, results.left.val);
        Assertions.assertEquals(1, results.right.val);
    }

    @Test
    void Example2() {
        int val = 1, depth = 3;
        TreeNode root = new TreeNode(4);
        root.left = new TreeNode(2);

=== Chunk 1026 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0623.add-one-row-to-tree\AddOneRowToTreeTest.java

root.left = new TreeNode(2);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(1);
        TreeNode results = AddOneRowToTree.addOneRow(root, val, depth);

        Assertions.assertEquals(1, results.left.left.val);
        Assertions.assertEquals(1, results.left.right.val);
    }
}

=== Chunk 1027 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0629.k-inverse-pairs-array\KInversePairsArray.java

class KInversePairsArray {
    private final int mod = (int) Math.pow(10, 9) + 7;

    public int kInversePairs(int n, int k) {
        // n numbers can generate at most n * (n - 1) / 2 inverse pairs
        if (k > n * (n - 1) / 2) return 0;
        if (k == n * (n - 1) / 2 || k == 0) return 1;

        int[][] dp = new int[n + 1][k + 1];

        for (int i = 1; i < n + 1; i++) {
            // deal with j = 0
            dp[i][0] = 1;
            for (int j = 1; j < Math.min(k, i * (i - 1) / 2) + 1; j++) {
                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j] - (j >= i ? dp[i - 1][j - i] : 0)) % mod;
                // all dp[i][j] modulo 10^9 + 7
                // so dp[i - 1][j - 1] might bigger than dp[i][j - 1] + dp[i - 1][j]
                if (dp[i][j] < 0)

=== Chunk 1028 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0629.k-inverse-pairs-array\KInversePairsArray.java

if (dp[i][j] < 0)
                    dp[i][j] += mod;
            }
        }

        return dp[n][k];
    }
}

=== Chunk 1029 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0629.k-inverse-pairs-array\KInversePairsArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class KInversePairsArrayTest {
    KInversePairsArray KInversePairsArray = new KInversePairsArray();

    @Test
    void Example1() {
        int n = 3, k = 0;
        int results = KInversePairsArray.kInversePairs(n, k);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 3, k = 1;
        int results = KInversePairsArray.kInversePairs(n, k);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1030 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0630.course-schedule-iii\CourseScheduleIii.java

import java.util.Arrays;
import java.util.PriorityQueue;

=== Chunk 1031 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0630.course-schedule-iii\CourseScheduleIii.java

class CourseScheduleIii {
    public int scheduleCourse(int[][] courses) {
        Arrays.sort(courses, (a, b) -> a[1] - b[1]);
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
        int time = 0;
        for (int[] course : courses) {
            if (course[0] <= course[1]) {
                if (course[0] + time <= course[1]) {
                    pq.offer(course[0]);
                    time += course[0];
                } else {
                    if (pq.peek() > course[0]) {
                        time -= pq.poll();
                        time += course[0];
                        pq.offer(course[0]);
                    }
                }
            }
        }
        return pq.size();
    }
}

=== Chunk 1032 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0630.course-schedule-iii\CourseScheduleIiiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1033 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0630.course-schedule-iii\CourseScheduleIiiTest.java

public class CourseScheduleIiiTest {
    CourseScheduleIii CourseScheduleIii = new CourseScheduleIii();

    @Test
    void Example1() {
        int[][] courses = {{100, 200}, {200, 1300}, {1000, 1250}, {2000, 3200}};
        int results = CourseScheduleIii.scheduleCourse(courses);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] courses = {{1, 2}};
        int results = CourseScheduleIii.scheduleCourse(courses);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[][] courses = {{3, 2}, {4, 3}};
        int results = CourseScheduleIii.scheduleCourse(courses);

=== Chunk 1034 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0630.course-schedule-iii\CourseScheduleIiiTest.java

int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        int[][] courses = {{5, 5}, {4, 6}, {2, 6}};
        int results = CourseScheduleIii.scheduleCourse(courses);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1035 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0633.sum-of-square-numbers\SumOfSquareNumbers.java

class SumOfSquareNumbers {
    public boolean judgeSquareSum(int c) {
        if (c < 0) return false;

        int i = 0, j = (int) Math.sqrt(c);
        while (i <= j) {
            long sum = ((long) i * i) + ((long) j * j);
            if (sum == c) {
                return true;
            } else if (sum > c) {
                j--;
            } else {
                i++;
            }
        }

        return false;
    }
}

=== Chunk 1036 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0633.sum-of-square-numbers\SumOfSquareNumbersTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1037 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0633.sum-of-square-numbers\SumOfSquareNumbersTest.java

public class SumOfSquareNumbersTest {
    SumOfSquareNumbers sumOfSquareNumbers = new SumOfSquareNumbers();

    @Test
    void Example1() {
        int c = 5;
        boolean expectedResults = true;

        boolean results;

        results = sumOfSquareNumbers.judgeSquareSum(c);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int c = 3;
        boolean expectedResults = false;

        boolean results;

        results = sumOfSquareNumbers.judgeSquareSum(c);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int c = 2;
        boolean expectedResults = true;

        boolean results;

        results = sumOfSquareNumbers.judgeSquareSum(c);

=== Chunk 1038 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0633.sum-of-square-numbers\SumOfSquareNumbersTest.java

Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        int c = 2147483600;
        boolean expectedResults = true;

        boolean results;

        results = sumOfSquareNumbers.judgeSquareSum(c);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1039 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0637.average-of-levels-in-binary-tree\AverageOfLevelsInBinaryTree.java

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1040 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0637.average-of-levels-in-binary-tree\AverageOfLevelsInBinaryTree.java

class AverageOfLevelsInBinaryTree {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> ret = new ArrayList<>();
        if (root == null) return ret;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int cnt = queue.size();
            double sum = 0;
            for (int i = 0; i < cnt; i++) {
                TreeNode node = queue.poll();
                sum += node != null ? node.val : 0;
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
            }
            ret.add(sum / cnt);
        }
        return ret;
    }
}

=== Chunk 1041 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0637.average-of-levels-in-binary-tree\AverageOfLevelsInBinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

=== Chunk 1042 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0637.average-of-levels-in-binary-tree\AverageOfLevelsInBinaryTreeTest.java

public class AverageOfLevelsInBinaryTreeTest {
    AverageOfLevelsInBinaryTree AverageOfLevelsInBinaryTree = new AverageOfLevelsInBinaryTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(9);
        TreeNode thirdNode = new TreeNode(20);
        TreeNode forthNode = new TreeNode(15);
        TreeNode fifthNode = new TreeNode(7);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        thirdNode.left = forthNode;
        thirdNode.right = fifthNode;

        List<Double> results = AverageOfLevelsInBinaryTree.averageOfLevels(firstNode);
        List<Double> expectedResult = new ArrayList<>();
        expectedResult.add(3.0);
        expectedResult.add(14.5);

=== Chunk 1043 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0637.average-of-levels-in-binary-tree\AverageOfLevelsInBinaryTreeTest.java

expectedResult.add(14.5);
        expectedResult.add(11.0);

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(9);
        TreeNode thirdNode = new TreeNode(20);
        TreeNode forthNode = new TreeNode(15);
        TreeNode fifthNode = new TreeNode(7);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;

        List<Double> results = AverageOfLevelsInBinaryTree.averageOfLevels(firstNode);
        List<Double> expectedResult = new ArrayList<>();
        expectedResult.add(3.0);
        expectedResult.add(14.5);

=== Chunk 1044 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0637.average-of-levels-in-binary-tree\AverageOfLevelsInBinaryTreeTest.java

expectedResult.add(14.5);
        expectedResult.add(11.0);

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 1045 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0645.set-mismatch\SetMismatch.java

class SetMismatch {
    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

    public int[] findErrorNums(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            while (nums[i] != i + 1 && nums[nums[i] - 1] != nums[i]) {
                swap(nums, i, nums[i] - 1);
            }
        }
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != i + 1) {
                return new int[]{nums[i], i + 1};
            }
        }
        return null;
    }
}

=== Chunk 1046 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0645.set-mismatch\SetMismatchTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SetMismatchTest {
    SetMismatch SetMismatch = new SetMismatch();

    @Test
    void Example1() {
        int[] nums = {1, 2, 2, 4};

        int[] results = SetMismatch.findErrorNums(nums);
        int[] expectedResults = {2, 3};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 1};

        int[] results = SetMismatch.findErrorNums(nums);
        int[] expectedResults = {1, 2};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 1047 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0647.palindromic-substrings\PalindromicSubstrings.java

class PalindromicSubstrings {
    private int cnt = 0;

    public void extendSubstrings(String s, int start, int end) {
        while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)) {
            start--;
            end++;
            cnt++;
        }
    }

    public int countSubstrings(String s) {
        for (int i = 0; i < s.length(); i++) {
            extendSubstrings(s, i, i);
            extendSubstrings(s, i, i + 1);
        }
        return cnt;
    }
}

=== Chunk 1048 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0647.palindromic-substrings\PalindromicSubstringsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class PalindromicSubstringsTest {
    PalindromicSubstrings PalindromicSubstrings = new PalindromicSubstrings();

    @Test
    void Example1() {
        String s = "abc";

        int results = PalindromicSubstrings.countSubstrings(s);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "aaa";

        int results = PalindromicSubstrings.countSubstrings(s);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1049 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0649.dota2-senate\Dota2Senate.java

import java.util.LinkedList;
import java.util.Queue;

=== Chunk 1050 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0649.dota2-senate\Dota2Senate.java

class Dota2Senate {
    public String predictPartyVictory(String senate) {
        int n = senate.length();
        Queue<Integer> radiant = new LinkedList<>();
        Queue<Integer> dire = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            if (senate.charAt(i) == 'R') {
                radiant.offer(i);
            } else {
                dire.offer(i);
            }
        }
        while (!radiant.isEmpty() && !dire.isEmpty()) {
            int radiantIndex = radiant.poll(), direIndex = dire.poll();
            if (radiantIndex < direIndex) {
                radiant.offer(radiantIndex + n);
            } else {
                dire.offer(direIndex + n);
            }
        }
        return !radiant.isEmpty() ? "Radiant" : "Dire";
    }
}

=== Chunk 1051 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0649.dota2-senate\Dota2SenateTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class Dota2SenateTest {
    Dota2Senate dota2Senate = new Dota2Senate();

    @Test
    void Example1() {
        String senate = "RD";

        Assertions.assertEquals("Radiant", dota2Senate.predictPartyVictory(senate));
    }

    @Test
    void Example2() {
        String senate = "RDD";

        Assertions.assertEquals("Dire", dota2Senate.predictPartyVictory(senate));
    }
}

=== Chunk 1052 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0652.find-duplicate-subtrees\FindDuplicateSubtrees.java

import java.util.*;


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1053 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0652.find-duplicate-subtrees\FindDuplicateSubtrees.java

class FindDuplicateSubtrees {
    Map<String, Pair<TreeNode, Integer>> seen = new HashMap<>();
    Set<TreeNode> repeat = new HashSet<>();
    int idx = 0;

    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        dfs(root);
        return new ArrayList<>(repeat);
    }

    private int dfs(TreeNode node) {
        if (node == null)
            return 0;

        int[] tri = {node.val, dfs(node.left), dfs(node.right)};
        String hash = Arrays.toString(tri);
        if (seen.containsKey(hash)) {
            Pair<TreeNode, Integer> pair = seen.get(hash);
            repeat.add(pair.getKey());
            return pair.getValue();
        } else {
            seen.put(hash, new Pair<>(node, ++idx));
            return idx;
        }
    }
}

=== Chunk 1054 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0652.find-duplicate-subtrees\FindDuplicateSubtreesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.List;

=== Chunk 1055 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0652.find-duplicate-subtrees\FindDuplicateSubtreesTest.java

public class FindDuplicateSubtreesTest {
    FindDuplicateSubtrees findDuplicateSubtrees = new FindDuplicateSubtrees();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.left.left = new TreeNode(4);
        root.right = new TreeNode(3);
        root.right.left = new TreeNode(2);
        root.right.left.left = new TreeNode(4);
        root.right.right = new TreeNode(4);

        List<TreeNode> results = findDuplicateSubtrees.findDuplicateSubtrees(root);

        Assertions.assertEquals(4, results.get(0).val);
        Assertions.assertEquals(2, results.get(1).val);
        Assertions.assertEquals(4, results.get(1).left.val);
    }

    @Test
    void Example2() {

=== Chunk 1056 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0652.find-duplicate-subtrees\FindDuplicateSubtreesTest.java

}

    @Test
    void Example2() {
        TreeNode root = new TreeNode(2);
        root.left = new TreeNode(1);
        root.right = new TreeNode(1);

        List<TreeNode> results = findDuplicateSubtrees.findDuplicateSubtrees(root);

        Assertions.assertEquals(1, results.get(0).val);
    }

    @Test
    void Example3() {
        TreeNode root = new TreeNode(2);
        root.left = new TreeNode(2);
        root.left.left = new TreeNode(3);
        root.right = new TreeNode(2);
        root.right.left = new TreeNode(3);

        List<TreeNode> results = findDuplicateSubtrees.findDuplicateSubtrees(root);

        Assertions.assertEquals(3, results.get(0).val);
        Assertions.assertEquals(2, results.get(1).val);

=== Chunk 1057 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0652.find-duplicate-subtrees\FindDuplicateSubtreesTest.java

Assertions.assertEquals(3, results.get(1).left.val);
    }
}

=== Chunk 1058 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0653.two-sum-iv-input-is-a-bst\TwoSumIvInputIsABst.java

import java.util.ArrayList;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1059 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0653.two-sum-iv-input-is-a-bst\TwoSumIvInputIsABst.java

class TwoSumIvInputIsABst {
    private void inOrder(TreeNode root, List<Integer> nums) {
        if (root == null) return;
        inOrder(root.left, nums);
        nums.add(root.val);
        inOrder(root.right, nums);
    }

    public boolean findTarget(TreeNode root, int k) {
        List<Integer> nums = new ArrayList<>();
        inOrder(root, nums);
        int i = 0, j = nums.size() - 1;
        while (i < j) {
            int sum = nums.get(i) + nums.get(j);
            if (sum == k) return true;
            if (sum < k) i++;
            else j--;
        }
        return false;
    }
}

=== Chunk 1060 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0653.two-sum-iv-input-is-a-bst\TwoSumIvInputIsABstTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1061 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0653.two-sum-iv-input-is-a-bst\TwoSumIvInputIsABstTest.java

public class TwoSumIvInputIsABstTest {
    TwoSumIvInputIsABst TwoSumIvInputIsABst = new TwoSumIvInputIsABst();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(5);
        TreeNode secondNode = new TreeNode(3);
        TreeNode thirdNode = new TreeNode(6);
        TreeNode forthNode = new TreeNode(2);
        TreeNode fifthNode = new TreeNode(4);
        TreeNode sixthNode = new TreeNode(7);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        thirdNode.right = sixthNode;

        int k = 9;
        boolean results = TwoSumIvInputIsABst.findTarget(firstNode, k);
        boolean expectedResult = true;

=== Chunk 1062 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0653.two-sum-iv-input-is-a-bst\TwoSumIvInputIsABstTest.java

boolean expectedResult = true;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(5);
        TreeNode secondNode = new TreeNode(3);
        TreeNode thirdNode = new TreeNode(6);
        TreeNode forthNode = new TreeNode(2);
        TreeNode fifthNode = new TreeNode(4);
        TreeNode sixthNode = new TreeNode(7);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        thirdNode.right = sixthNode;

        int k = 28;
        boolean results = TwoSumIvInputIsABst.findTarget(firstNode, k);
        boolean expectedResult = false;

=== Chunk 1063 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0653.two-sum-iv-input-is-a-bst\TwoSumIvInputIsABstTest.java

boolean expectedResult = false;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 1064 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0658.find-k-closest-elements\FindKClosestElements.java

import java.util.ArrayList;
import java.util.List;

class FindKClosestElements {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        List<Integer> res = new ArrayList<>();
        int low = 0, high = arr.length - 1;
        while (high - low >= k) {
            int diffLow = Math.abs(arr[low] - x);
            int diffHigh = Math.abs(arr[high] - x);
            if (diffLow <= diffHigh) high--;
            else low++;
        }
        while (low <= high) res.add(arr[low++]);
        return res;
    }
}

=== Chunk 1065 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0658.find-k-closest-elements\FindKClosestElementsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 1066 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0658.find-k-closest-elements\FindKClosestElementsTest.java

public class FindKClosestElementsTest {
    FindKClosestElements FindKClosestElements = new FindKClosestElements();

    @Test
    void Example1() {
        int[] arr = {1, 2, 3, 4, 5};
        int k = 4, x = 3;
        List<Integer> results = FindKClosestElements.findClosestElements(arr, k, x);
        List<Integer> expectedResults = Arrays.asList(1, 2, 3, 4);

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] arr = {1, 2, 3, 4, 5};
        int k = 4, x = -1;
        List<Integer> results = FindKClosestElements.findClosestElements(arr, k, x);
        List<Integer> expectedResults = Arrays.asList(1, 2, 3, 4);

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1067 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0659.split-array-into-consecutive-subsequences\SplitArrayIntoConsecutiveSubsequences.java

import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

=== Chunk 1068 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0659.split-array-into-consecutive-subsequences\SplitArrayIntoConsecutiveSubsequences.java

class SplitArrayIntoConsecutiveSubsequences {
    public boolean isPossible(int[] nums) {
        if (nums.length < 3) return false;
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        PriorityQueue<Integer> pq = new PriorityQueue<>(map.keySet().size());
        pq.addAll(map.keySet());

        while (!pq.isEmpty()) {
            int min = pq.peek();
            int count = 0;
            while (true) {
                if (!map.containsKey(min)) {
                    if (count < 3) return false;
                    break;
                }
                map.put(min, map.get(min) - 1);
                count++;
                if (map.get(min) == 0) {

=== Chunk 1069 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0659.split-array-into-consecutive-subsequences\SplitArrayIntoConsecutiveSubsequences.java

if (map.get(min) == 0) {
                    if (pq.peek() != null && min != pq.peek()) return false;
                    pq.poll();
                }
                if (map.containsKey(min + 1) && map.get(min) + 1 > map.get(min + 1)) {
                    if (count < 3) return false;
                    break;
                }
                min++;
            }
        }
        return true;
    }
}

=== Chunk 1070 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0659.split-array-into-consecutive-subsequences\SplitArrayIntoConsecutiveSubsequencesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1071 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0659.split-array-into-consecutive-subsequences\SplitArrayIntoConsecutiveSubsequencesTest.java

public class SplitArrayIntoConsecutiveSubsequencesTest {
    SplitArrayIntoConsecutiveSubsequences SplitArrayIntoConsecutiveSubsequences = new SplitArrayIntoConsecutiveSubsequences();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3, 3, 4, 5};
        boolean results = SplitArrayIntoConsecutiveSubsequences.isPossible(nums);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 2, 3, 3, 4, 4, 5, 5};
        boolean results = SplitArrayIntoConsecutiveSubsequences.isPossible(nums);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 1072 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0659.split-array-into-consecutive-subsequences\SplitArrayIntoConsecutiveSubsequencesTest.java

}

    @Test
    void Example3() {
        int[] nums = {1, 2, 3, 4, 4, 5};
        boolean results = SplitArrayIntoConsecutiveSubsequences.isPossible(nums);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1073 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0662.maximum-width-of-binary-tree\MaximumWidthOfBinaryTree.java

import java.util.HashMap;
import java.util.Map;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1074 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0662.maximum-width-of-binary-tree\MaximumWidthOfBinaryTree.java

class MaximumWidthOfBinaryTree {
    Map<Integer, Integer> levelMin = new HashMap<>();

    public int widthOfBinaryTree(TreeNode root) {
        return dfs(root, 1, 1);
    }

    private int dfs(TreeNode node, int depth, int index) {
        if (node == null) {
            return 0;
        }
        levelMin.putIfAbsent(depth, index);
        return Math.max(index - levelMin.get(depth) + 1, Math.max(dfs(node.left, depth + 1, index * 2), dfs(node.right, depth + 1, index * 2 + 1)));
    }
}

=== Chunk 1075 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0662.maximum-width-of-binary-tree\MaximumWidthOfBinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1076 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0662.maximum-width-of-binary-tree\MaximumWidthOfBinaryTreeTest.java

public class MaximumWidthOfBinaryTreeTest {
    MaximumWidthOfBinaryTree maximumWidthOfBinaryTree = new MaximumWidthOfBinaryTree();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(3);
        root.right = new TreeNode(2);
        root.left.left = new TreeNode(5);
        root.left.right = new TreeNode(3);
        root.right.right = new TreeNode(9);

        Assertions.assertEquals(4, maximumWidthOfBinaryTree.widthOfBinaryTree(root));
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(3);
        root.right = new TreeNode(2);
        root.left.left = new TreeNode(5);
        root.right.right = new TreeNode(9);

=== Chunk 1077 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0662.maximum-width-of-binary-tree\MaximumWidthOfBinaryTreeTest.java

root.right.right = new TreeNode(9);
        root.left.left.left = new TreeNode(6);
        root.right.right.left = new TreeNode(7);

        Assertions.assertEquals(7, maximumWidthOfBinaryTree.widthOfBinaryTree(root));
    }

    @Test
    void Example3() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(3);
        root.right = new TreeNode(2);
        root.left.left = new TreeNode(5);

        Assertions.assertEquals(2, maximumWidthOfBinaryTree.widthOfBinaryTree(root));
    }
}

=== Chunk 1078 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0665.non-decreasing-array\NonDecreasingArray.java

class NonDecreasingArray {
    public boolean checkPossibility(int[] nums) {
        int cnt = 0;
        for (int i = 1; i < nums.length && cnt < 2; i++) {
            if (nums[i] >= nums[i - 1]) continue;
            cnt++;
            if (i - 2 >= 0 && nums[i - 2] > nums[i]) {
                nums[i] = nums[i - 1];
            } else {
                nums[i - 1] = nums[i];
            }
        }
        return cnt <= 1;
    }
}

=== Chunk 1079 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0665.non-decreasing-array\NonDecreasingArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class NonDecreasingArrayTest {
    NonDecreasingArray NonDecreasingArray = new NonDecreasingArray();

    @Test
    void Example1() {
        int[] nums = {4, 2, 3};
        boolean results = NonDecreasingArray.checkPossibility(nums);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {4, 2, 1};
        boolean results = NonDecreasingArray.checkPossibility(nums);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1080 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0667.beautiful-arrangement-ii\BeautifulArrangementIi.java

class BeautifulArrangementIi {
    public int[] constructArray(int n, int k) {
        int[] ret = new int[n];
        ret[0] = 1;
        for (int i = 1, interval = k; i <= k; i++, interval--) {
            ret[i] = i % 2 == 1 ? ret[i - 1] + interval : ret[i - 1] - interval;
        }
        for (int i = k + 1; i < n; i++) {
            ret[i] = i + 1;
        }
        return ret;
    }
}

=== Chunk 1081 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0667.beautiful-arrangement-ii\BeautifulArrangementIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class BeautifulArrangementIiTest {
    BeautifulArrangementIi BeautifulArrangementIi = new BeautifulArrangementIi();

    @Test
    void Example1() {
        int n = 3, k = 1;
        int[] results = BeautifulArrangementIi.constructArray(n, k);
        int[] expectedResults = {1, 2, 3};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 3, k = 2;
        int[] results = BeautifulArrangementIi.constructArray(n, k);
        int[] expectedResults = {1, 3, 2};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 1082 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0669.trim-a-binary-search-tree\TrimABinarySearchTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class TrimABinarySearchTree {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null) return root;
        if (root.val > high) return trimBST(root.left, low, high);
        if (root.val < low) return trimBST(root.right, low, high);
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        return root;
    }
}

=== Chunk 1083 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0669.trim-a-binary-search-tree\TrimABinarySearchTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1084 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0669.trim-a-binary-search-tree\TrimABinarySearchTreeTest.java

public class TrimABinarySearchTreeTest {
    TrimABinarySearchTree TrimABinarySearchTree = new TrimABinarySearchTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(0);
        TreeNode thirdNode = new TreeNode(2);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;

        int low = 1;
        int high = 2;
        TreeNode results = TrimABinarySearchTree.trimBST(firstNode, low, high);

        firstNode.left = null;

        Assertions.assertEquals(firstNode, results);
    }

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(3);
        TreeNode secondNode = new TreeNode(0);
        TreeNode thirdNode = new TreeNode(4);

=== Chunk 1085 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0669.trim-a-binary-search-tree\TrimABinarySearchTreeTest.java

TreeNode thirdNode = new TreeNode(4);
        TreeNode forthNode = new TreeNode(2);
        TreeNode fifthNode = new TreeNode(1);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.right = forthNode;
        forthNode.left = fifthNode;

        int low = 1;
        int high = 3;
        TreeNode results = TrimABinarySearchTree.trimBST(firstNode, low, high);

        firstNode.left = forthNode;
        firstNode.right = null;

        Assertions.assertEquals(firstNode, results);
    }
}

=== Chunk 1086 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0671.second-minimum-node-in-a-binary-tree\SecondMinimumNodeInABinaryTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1087 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0671.second-minimum-node-in-a-binary-tree\SecondMinimumNodeInABinaryTree.java

class SecondMinimumNodeInABinaryTree {
    public int findSecondMinimumValue(TreeNode root) {
        if (root == null) return -1;
        if (root.left == null && root.right == null) return -1;
        int leftVal = root.left != null ? root.left.val : 0;
        int rightVal = root.right != null ? root.right.val : 0;
        if (leftVal == root.val) leftVal= findSecondMinimumValue(root.left);
        if (rightVal == root.val) rightVal = findSecondMinimumValue(root.right);
        if (leftVal != -1 && rightVal != -1) return Math.min(leftVal, rightVal);
        if (leftVal != -1) return leftVal;
        return rightVal;
    }
}

=== Chunk 1088 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0671.second-minimum-node-in-a-binary-tree\SecondMinimumNodeInABinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1089 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0671.second-minimum-node-in-a-binary-tree\SecondMinimumNodeInABinaryTreeTest.java

public class SecondMinimumNodeInABinaryTreeTest {
    SecondMinimumNodeInABinaryTree SecondMinimumNodeInABinaryTree = new SecondMinimumNodeInABinaryTree();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(2);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(5);
        TreeNode forthNode = new TreeNode(5);
        TreeNode fifthNode = new TreeNode(7);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        thirdNode.left = forthNode;
        thirdNode.right = fifthNode;

        int results = SecondMinimumNodeInABinaryTree.findSecondMinimumValue(firstNode);
        int expectedResult = 5;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test

=== Chunk 1090 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0671.second-minimum-node-in-a-binary-tree\SecondMinimumNodeInABinaryTreeTest.java

}

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(2);
        TreeNode secondNode = new TreeNode(2);
        TreeNode thirdNode = new TreeNode(2);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;

        int results = SecondMinimumNodeInABinaryTree.findSecondMinimumValue(firstNode);
        int expectedResult = -1;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 1091 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0677.map-sum-pairs\MapSumPairs.java

class MapSum {
    private class Node {
        Node[] childs = new Node[26];
        int value;
    }

    private Node root = new Node();

    private int indexForChar(char c) {
        return c - 'a';
    }

    public MapSum() {

    }

    private void insert(String key, Node node, int val) {
        if (node == null) return;
        if (key.length() == 0) {
            node.value = val;
            return;
        }
        int index = indexForChar(key.charAt(0));
        if (node.childs[index] == null) {
            node.childs[index] = new Node();
        }
        insert(key.substring(1), node.childs[index], val);
    }
    
    public void insert(String key, int val) {
        insert(key, root, val);
    }

=== Chunk 1092 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0677.map-sum-pairs\MapSumPairs.java

insert(key, root, val);
    }

    private int sum(String prefix, Node node) {
        if (node == null) return 0;
        if (prefix.length() != 0) {
            int index = indexForChar(prefix.charAt(0));
            return sum(prefix.substring(1), node.childs[index]);
        }
        int sum = node.value;
        for (Node child : node.childs) {
            sum += sum(prefix, child);
        }
        return sum;
    }
    
    public int sum(String prefix) {
        return sum(prefix, root);
    }
}

/**
 * Your MapSum object will be instantiated and called as such:
 * MapSum obj = new MapSum();
 * obj.insert(key,val);
 * int param_2 = obj.sum(prefix);
 */

=== Chunk 1093 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0677.map-sum-pairs\MapSumPairsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MapSumPairsTest {
    @Test
    void Example1() {
        MapSum mapSum = new MapSum();
        mapSum.insert("apple", 3);
        Assertions.assertEquals(3, mapSum.sum("ap"));
        mapSum.insert("app", 2);
        Assertions.assertEquals(5, mapSum.sum("ap"));
    }
}

=== Chunk 1094 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0680.valid-palindrome-ii\ValidPalindromeIi.java

class ValidPalindromeIi {
    private boolean isPalindrome(String s, int i, int j) {
        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }
        return true;
    }

    public boolean validPalindrome(String s) {
        int i = 0, j = s.length() - 1;
        while (i < j) {
            if (s.charAt(i) != s.charAt(j)) {
                return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);
            }
            i++;
            j--;
        }

        return true;
    }
}

=== Chunk 1095 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0680.valid-palindrome-ii\ValidPalindromeIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1096 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0680.valid-palindrome-ii\ValidPalindromeIiTest.java

public class ValidPalindromeIiTest {
    ValidPalindromeIi ValidPalindromeIi = new ValidPalindromeIi();

    @Test
    void Example1() {
        String s = "aba";
        boolean expectedResults = true;

        boolean results;

        results = ValidPalindromeIi.validPalindrome(s);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "abca";
        boolean expectedResults = true;

        boolean results;

        results = ValidPalindromeIi.validPalindrome(s);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "abc";
        boolean expectedResults = false;

        boolean results;

=== Chunk 1097 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0680.valid-palindrome-ii\ValidPalindromeIiTest.java

boolean results;

        results = ValidPalindromeIi.validPalindrome(s);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1098 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0684.redundant-connection\RedundantConnection.java

class RedundantConnection {
    private class UF {
        private int[] id;

        UF(int N) {
            id = new int[N + 1];
            for (int i = 0; i < id.length; i++) {
                id[i] = i;
            }
        }

        int find (int p) {
            return id[p];
        }

        void union(int u, int v) {
            int uID = find(u);
            int vID = find(v);
            if (uID == vID) {
                return;
            }
            for (int i = 0; i < id.length; i++) {
                if (id[i] == uID) {
                    id[i] = vID;
                }
            }
        }

        boolean connect(int u, int v) {
            return find(u) == find(v);
        }
    }

=== Chunk 1099 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0684.redundant-connection\RedundantConnection.java

}
    }

    public int[] findRedundantConnection(int[][] edges) {
        int N = edges.length;
        UF uf = new UF(N);
        for (int[] e : edges) {
            int u = e[0], v = e[1];
            if (uf.connect(u, v)) {
                return e;
            }
            uf.union(u, v);
        }
        return new int[]{-1, -1};
    }
}

=== Chunk 1100 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0684.redundant-connection\RedundantConnectionTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class RedundantConnectionTest {
    RedundantConnection RedundantConnection = new RedundantConnection();

    @Test
    void Example1() {
        int[][] edges = {{1, 2}, {1, 3}, {2, 3}};
        int[] results = RedundantConnection.findRedundantConnection(edges);
        int[] expectedResults = {2, 3};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] edges = {{1, 2}, {2, 3}, {3, 4}, {1, 4}, {1, 5}};
        int[] results = RedundantConnection.findRedundantConnection(edges);
        int[] expectedResults = {1, 4};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 1101 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0687.longest-univalue-path\LongestUnivaluePath.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1102 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0687.longest-univalue-path\LongestUnivaluePath.java

class LongestUnivaluePath {
    private int path = 0;

    private int dfs(TreeNode root) {
        if (root == null) return 0;
        int left = dfs(root.left);
        int right = dfs(root.right);
        int leftPath = root.left != null && root.left.val == root.val ? left + 1 : 0;
        int rightPath = root.right != null && root.right.val == root.val ? right + 1 : 0;
        path = Math.max(path, leftPath + rightPath);
        return Math.max(leftPath, rightPath);
    }

    public int longestUnivaluePath(TreeNode root) {
        dfs(root);
        return path;
    }
}

=== Chunk 1103 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0687.longest-univalue-path\LongestUnivaluePathTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1104 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0687.longest-univalue-path\LongestUnivaluePathTest.java

public class LongestUnivaluePathTest {
    LongestUnivaluePath LongestUnivaluePath = new LongestUnivaluePath();

    @Test
    void Example1() {
        TreeNode firstNode = new TreeNode(5);
        TreeNode secondNode = new TreeNode(4);
        TreeNode thirdNode = new TreeNode(5);
        TreeNode forthNode = new TreeNode(1);
        TreeNode fifthNode = new TreeNode(1);
        TreeNode sixthNode = new TreeNode(5);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        thirdNode.right = sixthNode;

        int results = LongestUnivaluePath.longestUnivaluePath(firstNode);
        int expectedResult = 2;

        Assertions.assertEquals(expectedResult, results);

=== Chunk 1105 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0687.longest-univalue-path\LongestUnivaluePathTest.java

}

    @Test
    void Example2() {
        TreeNode firstNode = new TreeNode(1);
        TreeNode secondNode = new TreeNode(4);
        TreeNode thirdNode = new TreeNode(5);
        TreeNode forthNode = new TreeNode(4);
        TreeNode fifthNode = new TreeNode(4);
        TreeNode sixthNode = new TreeNode(5);

        firstNode.left = secondNode;
        firstNode.right = thirdNode;
        secondNode.left = forthNode;
        secondNode.right = fifthNode;
        thirdNode.right = sixthNode;

        int results = LongestUnivaluePath.longestUnivaluePath(firstNode);
        int expectedResult = 2;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 1106 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0692.top-k-frequent-words\TopKFrequentWords.java

import java.util.*;

class TopKFrequentWords {
    public List<String> topKFrequent(String[] words, int k) {
        Map<String, Integer> map = new HashMap<>();
        for (String word : words) {
            map.put(word, map.getOrDefault(word, 0) + 1);
        }

        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(new MyComparator());

        for (Map.Entry<String, Integer> e : map.entrySet()) {
            pq.offer(e);
        }

        List<String> res = new LinkedList<>();
        for (int i = 0; i < k; i++) {
            res.add(Objects.requireNonNull(pq.poll()).getKey());
        }
        return res;
    }
}

=== Chunk 1107 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0692.top-k-frequent-words\TopKFrequentWords.java

class MyComparator implements Comparator<Map.Entry<String, Integer>> {
    public int compare(Map.Entry<String, Integer> e1, Map.Entry<String, Integer> e2){
        String word1 = e1.getKey();
        int freq1 = e1.getValue();
        String word2 = e2.getKey();
        int freq2 = e2.getValue();
        if (freq1 != freq2) return freq2-freq1;
        else return word1.compareTo(word2);
    }
}

=== Chunk 1108 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0692.top-k-frequent-words\TopKFrequentWordsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

=== Chunk 1109 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0692.top-k-frequent-words\TopKFrequentWordsTest.java

public class TopKFrequentWordsTest {
    TopKFrequentWords TopKFrequentWords = new TopKFrequentWords();

    @Test
    void Example1() {
        String[] words = {"i", "love", "leetcode", "i", "love", "coding"};
        int k = 2;
        List<String> results = TopKFrequentWords.topKFrequent(words, k);
        List<String> expectedResults = Arrays.asList("i", "love");

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String[] words = {"the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"};
        int k = 4;
        List<String> results = TopKFrequentWords.topKFrequent(words, k);
        List<String> expectedResults = Arrays.asList("the", "is", "sunny", "day");

=== Chunk 1110 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0692.top-k-frequent-words\TopKFrequentWordsTest.java

Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1111 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0693.binary-number-with-alternating-bits\BinaryNumberWithAlternatingBits.java

class BinaryNumberWithAlternatingBits {
    public boolean hasAlternatingBits(int n) {
        int a = (n ^ (n >> 1));
        return (a & (a + 1)) == 0;
    }
}

=== Chunk 1112 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0693.binary-number-with-alternating-bits\BinaryNumberWithAlternatingBitsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1113 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0693.binary-number-with-alternating-bits\BinaryNumberWithAlternatingBitsTest.java

public class BinaryNumberWithAlternatingBitsTest {
    BinaryNumberWithAlternatingBits BinaryNumberWithAlternatingBits = new BinaryNumberWithAlternatingBits();

    @Test
    void Example1() {
        int n = 5;
        boolean results = BinaryNumberWithAlternatingBits.hasAlternatingBits(n);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 7;
        boolean results = BinaryNumberWithAlternatingBits.hasAlternatingBits(n);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int n = 11;
        boolean results = BinaryNumberWithAlternatingBits.hasAlternatingBits(n);

=== Chunk 1114 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0693.binary-number-with-alternating-bits\BinaryNumberWithAlternatingBitsTest.java

boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1115 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0695.max-area-of-island\MaxAreaOfIsland.java

class MaxAreaOfIsland {
    private int maxAreaOfIslandHelper(int r, int c, int[][] grid) {
        if (r < 0 || r == grid.length || c < 0 || c == grid[0].length || grid[r][c] == 0) return 0;
        grid[r][c] = 0;
        return 1 + maxAreaOfIslandHelper(r + 1, c, grid)
                + maxAreaOfIslandHelper(r - 1, c , grid)
                + maxAreaOfIslandHelper(r, c + 1, grid)
                + maxAreaOfIslandHelper(r, c - 1, grid);
    }

    public int maxAreaOfIsland(int[][] grid) {
        int maxArea = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    int area = maxAreaOfIslandHelper(i, j, grid);

=== Chunk 1116 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0695.max-area-of-island\MaxAreaOfIsland.java

if (area > maxArea) maxArea = area;
                }
            }
        }
        return maxArea;
    }
}

=== Chunk 1117 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0695.max-area-of-island\MaxAreaOfIslandTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1118 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0695.max-area-of-island\MaxAreaOfIslandTest.java

public class MaxAreaOfIslandTest {
    MaxAreaOfIsland MaxAreaOfIsland = new MaxAreaOfIsland();

    @Test
    void Example1() {
        int[][] grid = {{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0}, {0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0}, {0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}};

        int results = MaxAreaOfIsland.maxAreaOfIsland(grid);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] grid = {{0, 0, 0, 0, 0, 0, 0, 0}};

=== Chunk 1119 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0695.max-area-of-island\MaxAreaOfIslandTest.java

int results = MaxAreaOfIsland.maxAreaOfIsland(grid);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1120 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0696.count-binary-substrings\CountBinarySubstrings.java

class CountBinarySubstrings {
    public int countBinarySubstrings(String s) {
        int preLen = 0, curLen = 1, count = 0;
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == s.charAt(i - 1)) {
                curLen++;
            } else {
                preLen = curLen;
                curLen = 1;
            }

            if (preLen >= curLen) {
                count++;
            }
        }
        return count;
    }
}

=== Chunk 1121 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0696.count-binary-substrings\CountBinarySubstringsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class CountBinarySubstringsTest {
    CountBinarySubstrings CountBinarySubstrings = new CountBinarySubstrings();

    @Test
    void Example1() {
        String s = "00110011";

        int results = CountBinarySubstrings.countBinarySubstrings(s);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "10101";

        int results = CountBinarySubstrings.countBinarySubstrings(s);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1122 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0697.degree-of-an-array\DegreeOfAnArray.java

import java.util.HashMap;
import java.util.Map;

=== Chunk 1123 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0697.degree-of-an-array\DegreeOfAnArray.java

class DegreeOfAnArray {
    public int findShortestSubArray(int[] nums) {
        Map<Integer, Integer> numsCnt = new HashMap<>();
        Map<Integer, Integer> numsLastIndex = new HashMap<>();
        Map<Integer, Integer> numsFirstIndex = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            numsCnt.put(num, numsCnt.getOrDefault(num, 0) + 1);
            numsLastIndex.put(num, i);
            if (!numsFirstIndex.containsKey(num)) {
                numsFirstIndex.put(num, i);
            }
        }
        int maxCnt = 0;
        for (int num : nums) {
            maxCnt = Math.max(maxCnt, numsCnt.get(num));
        }
        int ret = nums.length;
        for (int i = 0; i < nums.length; i++) {

=== Chunk 1124 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0697.degree-of-an-array\DegreeOfAnArray.java

for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            int cnt = numsCnt.get(num);
            if (cnt != maxCnt) continue;
            ret = Math.min(ret, numsLastIndex.get(num) - numsFirstIndex.get(num) + 1);
        }
        return ret;
    }
}

=== Chunk 1125 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0697.degree-of-an-array\DegreeOfAnArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class DegreeOfAnArrayTest {
    DegreeOfAnArray DegreeOfAnArray = new DegreeOfAnArray();

    @Test
    void Example1() {
        int[] nums = {1, 2, 2, 3, 1};
        int results = DegreeOfAnArray.findShortestSubArray(nums);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 2, 2, 3, 1, 4, 2};
        int results = DegreeOfAnArray.findShortestSubArray(nums);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1126 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0704.binary-search\BinarySearch.java

class BinarySearch {
    public int search(int[] nums, int target) {
        int l = 0, h = nums.length - 1;
        int m;
        while (l <= h) {
            m = (l + h) / 2;
            if (nums[m] > target) {
                h = m - 1;
            } else if (nums[m] < target) {
                l = m + 1;
            } else {
                return m;
            }
        }
        return -1;
    }
}

=== Chunk 1127 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0704.binary-search\BinarySearchTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1128 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0704.binary-search\BinarySearchTest.java

public class BinarySearchTest {
    BinarySearch BinarySearch = new BinarySearch();

    @Test
    void Example1() {
        int[] nums = {-1, 0, 3, 5, 9, 12};
        int target = 9;
        int results = BinarySearch.search(nums, target);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {-1, 0, 3, 5, 9, 12};
        int target = 2;
        int results = BinarySearch.search(nums, target);
        int expectedResults = -1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {5};
        int target = 5;
        int results = BinarySearch.search(nums, target);
        int expectedResults = 0;

=== Chunk 1129 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0704.binary-search\BinarySearchTest.java

int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1130 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0713.subarray-product-less-than-k\SubarrayProductLessThanK.java

class SubarrayProductLessThanK {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if (k <= 1) return 0;
        int prod = 1, left = 0, res = 0;
        for (int right = 0; right < nums.length; right++) {
            prod = prod * nums[right];
            while (prod >= k) prod /= nums[left++];
            res += right - left + 1;
        }
        return res;
    }
}

=== Chunk 1131 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0713.subarray-product-less-than-k\SubarrayProductLessThanKTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SubarrayProductLessThanKTest {
    SubarrayProductLessThanK SubarrayProductLessThanK = new SubarrayProductLessThanK();

    @Test
    void Example1() {
        int[] nums = {10, 5, 2, 6};
        int k = 100;
        int results = SubarrayProductLessThanK.numSubarrayProductLessThanK(nums, k);
        int expectedResults = 8;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 2, 3};
        int k = 0;
        int results = SubarrayProductLessThanK.numSubarrayProductLessThanK(nums, k);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1132 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0718.maximum-length-of-repeated-subarray\MaximumLengthOfRepeatedSubarray.java

class MaximumLengthOfRepeatedSubarray {
    public int findLength(int[] nums1, int[] nums2) {
        int res = 0;
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        for (int i = nums1.length - 1; i >= 0; i--) {
            for (int j = nums2.length - 1; j >= 0; j--) {
                if (nums1[i] == nums2[j]) {
                    dp[i][j] = dp[i + 1][j + 1] + 1;
                    if (dp[i][j] > res) res = dp[i][j];
                }
            }
        }
        return res;
    }
}

=== Chunk 1133 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0718.maximum-length-of-repeated-subarray\MaximumLengthOfRepeatedSubarrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1134 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0718.maximum-length-of-repeated-subarray\MaximumLengthOfRepeatedSubarrayTest.java

public class MaximumLengthOfRepeatedSubarrayTest {
    MaximumLengthOfRepeatedSubarray MaximumLengthOfRepeatedSubarray = new MaximumLengthOfRepeatedSubarray();

    @Test
    void Example1() {
        int[] nums1 = {1, 2, 3, 2, 1}, nums2 = {3, 2, 1, 4, 7};
        int results = MaximumLengthOfRepeatedSubarray.findLength(nums1, nums2);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums1 = {0, 0, 0, 0, 0}, nums2 = {0, 0, 0, 0, 0};
        int results = MaximumLengthOfRepeatedSubarray.findLength(nums1, nums2);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1135 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0724.find-pivot-index\FindPivotIndex.java

import java.util.Arrays;

class FindPivotIndex {
    public int pivotIndex(int[] nums) {
        if (nums.length == 0) return -1;

        int sum = 0, leftSum = 0;
        for (int n : nums) sum += n;
        for (int i = 0; i < nums.length; i++) {
            if (leftSum == sum - leftSum - nums[i]) return i;
            leftSum += nums[i];
        }
        return -1;
    }
}

=== Chunk 1136 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0724.find-pivot-index\FindPivotIndexTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1137 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0724.find-pivot-index\FindPivotIndexTest.java

public class FindPivotIndexTest {
    FindPivotIndex FindPivotIndex = new FindPivotIndex();

    @Test
    void Example1() {
        int[] nums = {1, 7, 3, 6, 5, 6};
        int results = FindPivotIndex.pivotIndex(nums);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 2, 3};
        int results = FindPivotIndex.pivotIndex(nums);
        int expectedResults = -1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {2, 1, -1};
        int results = FindPivotIndex.pivotIndex(nums);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1138 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0725.split-linked-list-in-parts\SplitLinkedListInParts.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

=== Chunk 1139 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0725.split-linked-list-in-parts\SplitLinkedListInParts.java

class SplitLinkedListInParts {
    public ListNode[] splitListToParts(ListNode head, int k) {
        int n = 0;
        ListNode cur = head;
        while (cur != null) {
            n++;
            cur = cur.next;
        }
        int mod = n % k;
        int size = n / k;
        ListNode[] ret = new ListNode[k];
        cur = head;
        for (int i = 0; cur != null && i < k; i++) {
            ret[i] = cur;
            int curSize = size + (mod-- > 0 ? 1 : 0);
            for (int j = 0; j < curSize - 1; j++) {
                cur = cur.next;
            }
            ListNode next = cur.next;
            cur.next = null;
            cur = next;
        }
        return ret;
    }
}

=== Chunk 1140 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0725.split-linked-list-in-parts\SplitLinkedListInPartsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1141 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0725.split-linked-list-in-parts\SplitLinkedListInPartsTest.java

public class SplitLinkedListInPartsTest {
    SplitLinkedListInParts SplitLinkedListInParts = new SplitLinkedListInParts();

    @Test
    void Example1() {
        ListNode firstNode = new ListNode(1);
        ListNode secondNode = new ListNode(2);
        ListNode thirdNode = new ListNode(3);

        firstNode.next = secondNode;
        secondNode.next = thirdNode;

        int k = 5;

        ListNode[] results = SplitLinkedListInParts.splitListToParts(firstNode, k);

        ListNode[] expectedResult = new ListNode[k];
        firstNode.next = null;
        secondNode.next = null;
        thirdNode.next = null;
        expectedResult[0] = firstNode;
        expectedResult[1] = secondNode;
        expectedResult[2] = thirdNode;

=== Chunk 1142 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0725.split-linked-list-in-parts\SplitLinkedListInPartsTest.java

expectedResult[2] = thirdNode;

        for (int i = 0; i < k; i++) {
            Assertions.assertEquals(expectedResult[i], results[i]);
        }
    }

    @Test
    void Example2() {
        ListNode firstNode = new ListNode(1);
        ListNode secondNode = new ListNode(2);
        ListNode thirdNode = new ListNode(3);
        ListNode forthNode = new ListNode(4);
        ListNode fifthNode = new ListNode(5);
        ListNode sixthNode = new ListNode(6);
        ListNode seventhNode = new ListNode(7);
        ListNode eighthNode = new ListNode(8);
        ListNode ninthNode = new ListNode(9);
        ListNode tenthNode = new ListNode(10);

        firstNode.next = secondNode;
        secondNode.next = thirdNode;
        thirdNode.next = forthNode;

=== Chunk 1143 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0725.split-linked-list-in-parts\SplitLinkedListInPartsTest.java

thirdNode.next = forthNode;
        forthNode.next = fifthNode;
        fifthNode.next = sixthNode;
        sixthNode.next = seventhNode;
        seventhNode.next = eighthNode;
        eighthNode.next = ninthNode;
        ninthNode.next = tenthNode;

        int k = 3;

        ListNode[] results = SplitLinkedListInParts.splitListToParts(firstNode, k);

        forthNode.next = null;
        seventhNode.next = null;

        ListNode[] expectedResult = new ListNode[k];
        expectedResult[0] = firstNode;
        expectedResult[1] = fifthNode;
        expectedResult[2] = eighthNode;

        for (int i = 0; i < k; i++) {
            Assertions.assertEquals(expectedResult[i], results[i]);
        }
    }
}

=== Chunk 1144 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0729.my-calendar-i\MyCalendarI.java

import java.util.TreeMap;

class MyCalendar {
    private final TreeMap<Integer, Integer> booked;

    public MyCalendar() {
        booked = new TreeMap<>();
    }
    
    public boolean book(int start, int end) {
        Integer lb = booked.floorKey(start);
        if (lb != null && booked.get(lb) > start) return false;
        Integer ub = booked.ceilingKey(start);
        if (ub != null && ub < end) return false;

        booked.put(start, end);
        return true;
    }
}

/**
 * Your MyCalendar object will be instantiated and called as such:
 * MyCalendar obj = new MyCalendar();
 * boolean param_1 = obj.book(start,end);
 */

=== Chunk 1145 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0729.my-calendar-i\MyCalendarITest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MyCalendarITest {
    @Test
    void Example1() {
        MyCalendar myCalendar = new MyCalendar();
        boolean result = myCalendar.book(10, 20);
        Assertions.assertTrue(result);

        result = myCalendar.book(15, 25);
        Assertions.assertFalse(result);

        result = myCalendar.book(20, 30);
        Assertions.assertTrue(result);
    }
}

=== Chunk 1146 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0732.my-calendar-iii\MyCalendarIii.java

import java.util.Map;
import java.util.TreeMap;

class MyCalendarThree {
    private Map<Integer, Integer> diff;

    public MyCalendarThree() {
        diff = new TreeMap<>();
    }
    
    public int book(int start, int end) {
        diff.put(start, diff.getOrDefault(start, 0) + 1);
        diff.put(end, diff.getOrDefault(end, 0) - 1);
        int res = 0, cur = 0;
        for (int delta : diff.values()) {
            cur += delta;
            res = Math.max(res, cur);
        }
        return res;
    }
}

/**
 * Your MyCalendarThree object will be instantiated and called as such:
 * MyCalendarThree obj = new MyCalendarThree();
 * int param_1 = obj.book(start,end);
 */

=== Chunk 1147 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0732.my-calendar-iii\MyCalendarThreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MyCalendarThreeTest {
    @Test
    void Example1() {
        MyCalendarThree myCalendarThree = new MyCalendarThree();
        Assertions.assertEquals(1, myCalendarThree.book(10, 20));
        Assertions.assertEquals(1, myCalendarThree.book(50, 60));
        Assertions.assertEquals(2, myCalendarThree.book(10, 40));
        Assertions.assertEquals(3, myCalendarThree.book(5, 15));
        Assertions.assertEquals(3, myCalendarThree.book(5, 10));
        Assertions.assertEquals(3, myCalendarThree.book(25, 55));
    }
}

=== Chunk 1148 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0733.flood-fill\FloodFill.java

class FloodFill {
    private int[][] floodFill(int[][] image, int cr, int cc, int curColor, int color) {
        if (cr == -1 || cr > image.length - 1 || cc == -1 || cc > image[0].length - 1 || image[cr][cc] != curColor) return image;
        image[cr][cc] = color;
        floodFill(image, cr - 1, cc, curColor, color);
        floodFill(image, cr, cc - 1, curColor, color);
        floodFill(image, cr + 1, cc, curColor, color);
        floodFill(image, cr, cc + 1, curColor, color);
        return image;
    }

    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        int curColor = image[sr][sc];
        if (curColor == color) return image;
        return floodFill(image, sr, sc, curColor, color);
    }
}

=== Chunk 1149 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0733.flood-fill\FloodFillTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1150 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0733.flood-fill\FloodFillTest.java

public class FloodFillTest {
    FloodFill FloodFill = new FloodFill();

    @Test
    void Example1() {
        int[][] image = {{1, 1, 1}, {1, 1, 0}, {1, 0, 1}};
        int sr = 1, sc = 1, color = 2;
        int[][] results = FloodFill.floodFill(image, sr, sc, color);
        int[][] expectedResults = {{2, 2, 2}, {2, 2, 0}, {2, 0, 1}};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] image = {{0, 0, 0}, {0, 0, 0}};
        int sr = 0, sc = 0, color = 0;
        int[][] results = FloodFill.floodFill(image, sr, sc, color);
        int[][] expectedResults = {{0, 0, 0}, {0, 0, 0}};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 1151 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0735.asteroid-collision\AsteroidCollision.java

import java.util.Stack;

=== Chunk 1152 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0735.asteroid-collision\AsteroidCollision.java

class AsteroidCollision {
    public int[] asteroidCollision(int[] asteroids) {
        Stack<Integer> stack =  new Stack<>();
        for (int ast : asteroids) {
            collision: {
                while (!stack.isEmpty() && ast < 0 && stack.peek() > 0) {
                    if (stack.peek() < -ast) {
                        stack.pop();
                        continue;
                    } else if (stack.peek() == -ast) {
                        stack.pop();
                    }
                    break collision;
                }
                stack.push(ast);
            }
        }

        int[] res = new int[stack.size()];
        for (int i = res.length - 1; i >= 0; i--) {
            res[i] = stack.pop();
        }
        return res;
    }
}

=== Chunk 1153 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0735.asteroid-collision\AsteroidCollisionTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1154 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0735.asteroid-collision\AsteroidCollisionTest.java

public class AsteroidCollisionTest {
    AsteroidCollision AsteroidCollision = new AsteroidCollision();

    @Test
    void Example1() {
        int[] asteroids = {5, 10, -5};
        int[] results = AsteroidCollision.asteroidCollision(asteroids);
        int[] expectedResults = {5, 10};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] asteroids = {8, -8};
        int[] results = AsteroidCollision.asteroidCollision(asteroids);
        int[] expectedResults = {};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] asteroids = {10, 2, -5};
        int[] results = AsteroidCollision.asteroidCollision(asteroids);

=== Chunk 1155 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0735.asteroid-collision\AsteroidCollisionTest.java

int[] expectedResults = {10};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 1156 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0739.daily-temperatures\DailyTemperatures.java

import java.util.Stack;

class DailyTemperatures {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] ans = new int[n];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                int preIndex = stack.pop();
                ans[preIndex] = i - preIndex;
            }
            stack.push(i);
        }
        return ans;
    }
}

=== Chunk 1157 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0739.daily-temperatures\DailyTemperaturesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1158 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0739.daily-temperatures\DailyTemperaturesTest.java

public class DailyTemperaturesTest {
    DailyTemperatures dailyTemperatures = new DailyTemperatures();

    @Test
    void Example1() {
        int[] temperatures = {73, 74, 75, 71, 69, 72, 76, 73};

        Assertions.assertArrayEquals(new int []{1, 1, 4, 2, 1, 1, 0, 0}, dailyTemperatures.dailyTemperatures(temperatures));
    }

    @Test
    void Example2() {
        int[] temperatures = {30, 40, 50, 60};

        Assertions.assertArrayEquals(new int []{1, 1, 1, 0}, dailyTemperatures.dailyTemperatures(temperatures));
    }

    @Test
    void Example3() {
        int[] temperatures = {30, 60, 90};

        Assertions.assertArrayEquals(new int []{1, 1, 0}, dailyTemperatures.dailyTemperatures(temperatures));
    }
}

=== Chunk 1159 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0744.find-smallest-letter-greater-than-target\FindSmallestLetterGreaterThanTarget.java

class FindSmallestLetterGreaterThanTarget {
    public char nextGreatestLetter(char[] letters, char target) {
        int n = letters.length;
        int l = 0, h = n - 1;
        while (l <= h) {
            int m = l + (h - l) / 2;
            if (letters[m] <= target) {
                l = m + 1;
            } else {
                h = m - 1;
            }
        }
        return l < n ? letters[l] : letters[0];
    }
}

=== Chunk 1160 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0744.find-smallest-letter-greater-than-target\FindSmallestLetterGreaterThanTargetTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1161 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0744.find-smallest-letter-greater-than-target\FindSmallestLetterGreaterThanTargetTest.java

public class FindSmallestLetterGreaterThanTargetTest {
    FindSmallestLetterGreaterThanTarget FindSmallestLetterGreaterThanTarget = new FindSmallestLetterGreaterThanTarget();

    @Test
    void Example1() {
        char[] letters = {'c', 'f', 'j'};
        char target = 'a';
        char results = FindSmallestLetterGreaterThanTarget.nextGreatestLetter(letters, target);
        char expectedResults = 'c';

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        char[] letters = {'c', 'f', 'j'};
        char target = 'c';
        char results = FindSmallestLetterGreaterThanTarget.nextGreatestLetter(letters, target);
        char expectedResults = 'f';

        Assertions.assertEquals(expectedResults, results);
    }

=== Chunk 1162 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0744.find-smallest-letter-greater-than-target\FindSmallestLetterGreaterThanTargetTest.java

}

    @Test
    void Example3() {
        char[] letters = {'c', 'f', 'j'};
        char target = 'd';
        char results = FindSmallestLetterGreaterThanTarget.nextGreatestLetter(letters, target);
        char expectedResults = 'f';

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1163 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0746.min-cost-climbing-stairs\MinCostClimbingStairs.java

class MinCostClimbingStairs {
    public int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[cost.length];
        dp[0] = cost[0];
        dp[1] = cost[1];
        for (int i = 2; i < cost.length; i++) {
            dp[i] = cost[i] + Math.min(dp[i -1], dp[i - 2]);
        }
        return Math.min(dp[cost.length - 1], dp[cost.length - 2]);
    }
}

=== Chunk 1164 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0746.min-cost-climbing-stairs\MinCostClimbingStairsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MinCostClimbingStairsTest {
    MinCostClimbingStairs MinCostClimbingStairs = new MinCostClimbingStairs();

    @Test
    void Example1() {
        int[] cost = {10, 15, 20};
        int results = MinCostClimbingStairs.minCostClimbingStairs(cost);
        int expectedResults = 15;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] cost = {1, 100, 1, 1, 1, 100, 1, 1, 100, 1};
        int results = MinCostClimbingStairs.minCostClimbingStairs(cost);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1165 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0763.partition-labels\PartitionLabels.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 1166 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0763.partition-labels\PartitionLabels.java

class PartitionLabels {
    private int char2Index(char c) {
        return c - 'a';
    }

    public List<Integer> partitionLabels(String s) {
        int[] lastIndexesOfChar = new int[26];
        for (int i = 0; i < s.length(); i++) {
            lastIndexesOfChar[char2Index(s.charAt(i))] = i;
        }
        List<Integer> partitions = new ArrayList<>();
        int firstIndex = 0;
        while (firstIndex < s.length()) {
            int lastIndex = firstIndex;
            for (int i = firstIndex; i < s.length() && i <= lastIndex; i++) {
                int index = lastIndexesOfChar[char2Index(s.charAt(i))];
                if (index > lastIndex) {
                    lastIndex = index;
                }
            }

=== Chunk 1167 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0763.partition-labels\PartitionLabels.java

}
            }
            partitions.add(lastIndex - firstIndex + 1);
            firstIndex = lastIndex + 1;
        }
        return partitions;
    }
}

=== Chunk 1168 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0763.partition-labels\PartitionLabelsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

=== Chunk 1169 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0763.partition-labels\PartitionLabelsTest.java

public class PartitionLabelsTest {
    PartitionLabels PartitionLabels = new PartitionLabels();

    @Test
    void Example1() {
        String s = "ababcbacadefegdehijhklij";
        List<Integer> results = PartitionLabels.partitionLabels(s);
        List<Integer> expectedResults = new ArrayList<>();;
        expectedResults.add(9);
        expectedResults.add(7);
        expectedResults.add(8);

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "eccbbbbdec";
        List<Integer> results = PartitionLabels.partitionLabels(s);
        List<Integer> expectedResults = new ArrayList<>();;
        expectedResults.add(10);

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1170 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0766.toeplitz-matrix\ToeplitzMatrix.java

class ToeplitzMatrix {
    private boolean check(int[][] matrix, int expectValue, int row, int col) {
        if (row >= matrix.length || col >= matrix[0].length) {
            return true;
        }
        if (matrix[row][col] != expectValue) {
            return false;
        }
        return check(matrix, expectValue, row + 1, col + 1);
    }

    public boolean isToeplitzMatrix(int[][] matrix) {
        for (int i = 0; i < matrix[0].length; i++) {
            if (!check(matrix, matrix[0][i], 0, i)) {
                return false;
            }
        }
        for (int i = 1; i < matrix.length; i++) {
            if (!check(matrix, matrix[i][0], i, 0)) {
                return false;
            }
        }
        return true;
    }
}

=== Chunk 1171 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0766.toeplitz-matrix\ToeplitzMatrixTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ToeplitzMatrixTest {
    ToeplitzMatrix ToeplitzMatrix = new ToeplitzMatrix();

    @Test
    void Example1() {
        int[][] matrix = {{1,2,3,4},{5,1,2,3},{9,5,1,2}};
        boolean results = ToeplitzMatrix.isToeplitzMatrix(matrix);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] matrix = {{1,2},{2,2}};
        boolean results = ToeplitzMatrix.isToeplitzMatrix(matrix);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1172 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0769.max-chunks-to-make-sorted\MaxChunksToMakeSorted.java

class MaxChunksToMakeSorted {
    public int maxChunksToSorted(int[] arr) {
        if (arr == null) return 0;
        int ret = 0;
        int right = arr[0];
        for (int i = 0; i < arr.length; i++) {
            right = Math.max(right, arr[i]);
            if (i == right) ret++;
        }
        return ret;
    }
}

=== Chunk 1173 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0769.max-chunks-to-make-sorted\MaxChunksToMakeSortedTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1174 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0769.max-chunks-to-make-sorted\MaxChunksToMakeSortedTest.java

public class MaxChunksToMakeSortedTest {
    MaxChunksToMakeSorted MaxChunksToMakeSorted = new MaxChunksToMakeSorted();

    @Test
    void Example1() {
        int[] nums = {4, 3, 2, 1, 0};
        int results = MaxChunksToMakeSorted.maxChunksToSorted(nums);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 0, 2, 3, 4};
        int results = MaxChunksToMakeSorted.maxChunksToSorted(nums);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {1, 2, 0, 3};
        int results = MaxChunksToMakeSorted.maxChunksToSorted(nums);
        int expectedResults = 2;

=== Chunk 1175 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0769.max-chunks-to-make-sorted\MaxChunksToMakeSortedTest.java

int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1176 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0783.minimum-distance-between-bst-nodes\MinimumDistanceBetweenBstNodes.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1177 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0783.minimum-distance-between-bst-nodes\MinimumDistanceBetweenBstNodes.java

class MinimumDistanceBetweenBstNodes {
    int ans, pre;

    public int minDiffInBST(TreeNode root) {
        ans = Integer.MAX_VALUE;
        pre = -1;
        dfs(root);
        return ans;
    }

    private void dfs(TreeNode root) {
        if (root == null)
            return;

        dfs(root.left);
        if (pre != -1) {
            ans = Math.min(ans, root.val - pre);
        }
        pre = root.val;
        dfs(root.right);
    }
}

=== Chunk 1178 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0783.minimum-distance-between-bst-nodes\MinimumDistanceBetweenBstNodesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1179 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0783.minimum-distance-between-bst-nodes\MinimumDistanceBetweenBstNodesTest.java

public class MinimumDistanceBetweenBstNodesTest {
    MinimumDistanceBetweenBstNodes minimumDistanceBetweenBstNodes = new MinimumDistanceBetweenBstNodes();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(4);
        root.left = new TreeNode(2);
        root.right = new TreeNode(6);
        root.left.left = new TreeNode(1);
        root.left.right = new TreeNode(3);

        Assertions.assertEquals(1, minimumDistanceBetweenBstNodes.minDiffInBST(root));
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(0);
        root.right = new TreeNode(48);
        root.right.left = new TreeNode(12);
        root.right.right = new TreeNode(49);

=== Chunk 1180 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0783.minimum-distance-between-bst-nodes\MinimumDistanceBetweenBstNodesTest.java

root.right.right = new TreeNode(49);

        Assertions.assertEquals(1, minimumDistanceBetweenBstNodes.minDiffInBST(root));
    }
}

=== Chunk 1181 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0784.letter-case-permutation\LetterCasePermutation.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 1182 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0784.letter-case-permutation\LetterCasePermutation.java

class LetterCasePermutation {
    private void backtrack(char[] str, int pos, List<String> res) {
        if (pos == str.length) {
            res.add(new String(str));
            return;
        }

        if (Character.isLetter(str[pos])) {
            if (Character.isUpperCase(str[pos])) {
                str[pos] = Character.toLowerCase(str[pos]);
                backtrack(str, pos + 1, res);
                str[pos] = Character.toUpperCase(str[pos]);
            } else {
                str[pos] = Character.toUpperCase(str[pos]);
                backtrack(str, pos + 1, res);
                str[pos] = Character.toLowerCase(str[pos]);
            }
        }
        backtrack(str, pos + 1, res);
    }

    public List<String> letterCasePermutation(String s) {

=== Chunk 1183 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0784.letter-case-permutation\LetterCasePermutation.java

List<String> res = new ArrayList<>();
        backtrack(s.toCharArray(), 0, res);
        return res;
    }
}

=== Chunk 1184 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0784.letter-case-permutation\LetterCasePermutationTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

=== Chunk 1185 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0784.letter-case-permutation\LetterCasePermutationTest.java

public class LetterCasePermutationTest {
    LetterCasePermutation LetterCasePermutation = new LetterCasePermutation();

    @Test
    void Example1() {
        String s = "a1b2";
        List<String> results = LetterCasePermutation.letterCasePermutation(s);
        List<String> expectedResults = Arrays.asList("A1B2", "A1b2", "a1B2", "a1b2");

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "3z4";
        List<String> results = LetterCasePermutation.letterCasePermutation(s);
        List<String> expectedResults = Arrays.asList("3Z4", "3z4");

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1186 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0785.is-graph-bipartite\IsGraphBipartite.java

import java.util.Arrays;

=== Chunk 1187 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0785.is-graph-bipartite\IsGraphBipartite.java

class IsGraphBipartite {
    private boolean isBipartite(int curNode, int curColor, int[] colors, int[][] graph) {
        if (colors[curNode] != -1) {
            return colors[curNode] == curColor;
        }
        colors[curNode] = curColor;
        for (int nextNode : graph[curNode]) {
            if (!isBipartite(nextNode, 1 - curColor, colors, graph)) {
                return false;
            }
        }
        return true;
    }

    public boolean isBipartite(int[][] graph) {
        int[] colors = new int[graph.length];
        Arrays.fill(colors, -1);
        for (int i = 0; i < graph.length; i++) {
            if (colors[i] == -1 && !isBipartite(i, 0, colors, graph)) {
                return false;
            }
        }
        return true;
    }
}

=== Chunk 1188 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0785.is-graph-bipartite\IsGraphBipartiteTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class IsGraphBipartiteTest {
    IsGraphBipartite IsGraphBipartite = new IsGraphBipartite();

    @Test
    void Example1() {
        int[][] graph = {{1,2,3},{0,2},{0,1,3},{0,2}};
        boolean results = IsGraphBipartite.isBipartite(graph);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] graph = {{1,3},{0,2},{1,3},{0,2}};
        boolean results = IsGraphBipartite.isBipartite(graph);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1189 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0787.cheapest-flights-within-k-stops\CheapestFlightsWithinKStops.java

import java.util.Arrays;

class CheapestFlightsWithinKStops {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        final int inf = 10000 * 101 + 1;
        int[][] f = new int[k + 2][n];
        for (int i = 0; i < k + 2; i++)
            Arrays.fill(f[i], inf);
        f[0][src] = 0;
        for (int t = 1; t <= k + 1; t++) {
            for (int[] flight : flights) {
                int j = flight[0], i = flight[1], cost = flight[2];
                f[t][i] = Math.min(f[t][i], f[t - 1][j] + cost);
            }
        }
        int ans = inf;
        for (int t = 1; t <= k + 1; t++)
            ans = Math.min(ans, f[t][dst]);

        return ans == inf ? -1 : ans;
    }
}

=== Chunk 1190 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0787.cheapest-flights-within-k-stops\CheapestFlightsWithinKStopsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1191 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0787.cheapest-flights-within-k-stops\CheapestFlightsWithinKStopsTest.java

public class CheapestFlightsWithinKStopsTest {
    CheapestFlightsWithinKStops cheapestFlightsWithinKStops = new CheapestFlightsWithinKStops();

    @Test
    void Example1() {
        int n = 4;
        int[][] flights = {{0, 1, 100}, {1, 2, 100}, {2, 0, 100}, {1, 3, 600}, {2, 3, 200}};
        int src = 0, dst = 3, k = 1;

        Assertions.assertEquals(700, cheapestFlightsWithinKStops.findCheapestPrice(n, flights, src, dst, k));
    }

    @Test
    void Example2() {
        int n = 3;
        int[][] flights = {{0, 1, 100}, {1, 2, 100}, {0, 2, 500}};
        int src = 0, dst = 2, k = 1;

        Assertions.assertEquals(200, cheapestFlightsWithinKStops.findCheapestPrice(n, flights, src, dst, k));
    }

    @Test
    void Example3() {
        int n = 3;

=== Chunk 1192 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0787.cheapest-flights-within-k-stops\CheapestFlightsWithinKStopsTest.java

void Example3() {
        int n = 3;
        int[][] flights = {{0, 1, 100}, {1, 2, 100}, {0, 2, 500}};
        int src = 0, dst = 2, k = 0;

        Assertions.assertEquals(500, cheapestFlightsWithinKStops.findCheapestPrice(n, flights, src, dst, k));
    }
}

=== Chunk 1193 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0790.domino-and-tromino-tiling\DominoAndTrominoTiling.java

class DominoAndTrominoTiling {
    static final int modulo = 1000000007;

    public int numTilings(int n) {
        int[][] dp = new int[n + 1][4];
        dp[0][3] = 1;
        for (int i = 1; i <= n; i++) {
            dp[i][0] = dp[i - 1][3];
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % modulo;
            dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % modulo;
            dp[i][3] = (((dp[i - 1][0] + dp[i - 1][1]) % modulo + dp[i - 1][2]) % modulo + dp[i - 1][3]) % modulo;
        }
        return dp[n][3];
    }
}

=== Chunk 1194 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0790.domino-and-tromino-tiling\DominoAndTrominoTilingTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class DominoAndTrominoTilingTest {
    DominoAndTrominoTiling dominoAndTrominoTiling = new DominoAndTrominoTiling();

    @Test
    void Example1() {
        int n = 3;

        Assertions.assertEquals(5, dominoAndTrominoTiling.numTilings(n));
    }

    @Test
    void Example2() {
        int n = 1;

        Assertions.assertEquals(1, dominoAndTrominoTiling.numTilings(n));
    }
}

=== Chunk 1195 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0792.number-of-matching-subsequences\NumberOfMatchingSubsequences.java

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;

=== Chunk 1196 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0792.number-of-matching-subsequences\NumberOfMatchingSubsequences.java

class NumberOfMatchingSubsequences {
    public int numMatchingSubseq(String s, String[] words) {
        Map<Character, Queue<String>> map = new HashMap<>();
        int ans = 0;

        for (int i = 0; i < s.length(); i++) {
            map.putIfAbsent(s.charAt(i), new LinkedList<>());
        }

        for (String word : words) {
            char startChar = word.charAt(0);
            if (map.containsKey(startChar)) {
                map.get(startChar).offer(word);
            }
        }

        for (int i = 0; i < s.length(); i++) {
            char startChar = s.charAt(i);
            Queue<String> q = map.get(startChar);
            int size = q.size();
            for (int j = 0; j < size; j++) {
                String str = q.poll();

=== Chunk 1197 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0792.number-of-matching-subsequences\NumberOfMatchingSubsequences.java

String str = q.poll();
                if (str != null) {
                    if (str.substring(1).length() == 0) ans++;
                    else {
                        if (map.containsKey(str.charAt(1))) {
                            map.get(str.charAt(1)).add(str.substring(1));
                        }
                    }
                }
            }
        }
        return ans;
    }
}

=== Chunk 1198 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0792.number-of-matching-subsequences\NumberOfMatchingSubsequences2.java

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

=== Chunk 1199 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0792.number-of-matching-subsequences\NumberOfMatchingSubsequences2.java

class NumberOfMatchingSubsequences2 {
    private List<List<Integer>> pos;
    private boolean isMatch(String word) {
        int l = -1;
        for (char c : word.toCharArray()) {
            List<Integer> p = pos.get(c);
            int index = Collections.binarySearch(p, l + 1);
            if (index < 0) index = -index - 1;
            if (index >= p.size()) return false;
            l = p.get(index);
        }
        return true;
    }

    public int numMatchingSubseq(String s, String[] words) {
        pos = new ArrayList<>();
        for (int i = 0; i < 128; i++) {
            pos.add(new ArrayList<>());
        }
        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            pos.get(chars[i]).add(i);
        }

=== Chunk 1200 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0792.number-of-matching-subsequences\NumberOfMatchingSubsequences2.java

pos.get(chars[i]).add(i);
        }
        int ans = 0;
        for (String word : words) {
            if (isMatch(word)) ans++;
        }
        return ans;
    }
}

=== Chunk 1201 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0792.number-of-matching-subsequences\NumberOfMatchingSubsequencesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1202 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0792.number-of-matching-subsequences\NumberOfMatchingSubsequencesTest.java

public class NumberOfMatchingSubsequencesTest {
    NumberOfMatchingSubsequences NumberOfMatchingSubsequences = new NumberOfMatchingSubsequences();
    NumberOfMatchingSubsequences2 NumberOfMatchingSubsequences2 = new NumberOfMatchingSubsequences2();

    @Test
    void Example1() {
        String s = "abcde";
        String[] words = {"a", "bb", "acd", "ace"};
        int results = NumberOfMatchingSubsequences.numMatchingSubseq(s, words);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);

        results = NumberOfMatchingSubsequences2.numMatchingSubseq(s, words);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "dsahjpjauf";

=== Chunk 1203 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0792.number-of-matching-subsequences\NumberOfMatchingSubsequencesTest.java

String s = "dsahjpjauf";
        String[] words = {"ahjpjau", "ja", "ahbwzgqnuk", "tnmlanowax"};
        int results = NumberOfMatchingSubsequences.numMatchingSubseq(s, words);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);

        results = NumberOfMatchingSubsequences2.numMatchingSubseq(s, words);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1204 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0797.all-paths-from-source-to-target\AllPathsFromSourceToTarget.java

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

class AllPathsFromSourceToTarget {
    List<List<Integer>> ans = new ArrayList<>();
    Deque<Integer> stack = new ArrayDeque<>();

    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        stack.offerLast(0);
        dfs(graph, 0, graph.length - 1);
        return ans;
    }

    private void dfs(int[][] graph, int x, int n) {
        if (x == n) {
            ans.add(new ArrayList<>(stack));
            return;
        }
        for (int y : graph[x]) {
            stack.offerLast(y);
            dfs(graph, y, n);
            stack.pollLast();
        }
    }
}

=== Chunk 1205 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0797.all-paths-from-source-to-target\AllPathsFromSourceToTargetTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 1206 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0797.all-paths-from-source-to-target\AllPathsFromSourceToTargetTest.java

public class AllPathsFromSourceToTargetTest {
    AllPathsFromSourceToTarget AllPathsFromSourceToTarget = new AllPathsFromSourceToTarget();

    @Test
    void Example1() {
        int[][] graph = {{1, 2}, {3}, {3}, {}};
        List<List<Integer>> results = AllPathsFromSourceToTarget.allPathsSourceTarget(graph);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(0, 1, 3));
        expectedResults.add(Arrays.asList(0, 2, 3));

        Assertions.assertTrue(expectedResults.containsAll(results));
    }

    @Test
    void Example2() {
        int[][] graph = {{4, 3, 1}, {3, 2, 4}, {3}, {4}, {}};
        List<List<Integer>> results = AllPathsFromSourceToTarget.allPathsSourceTarget(graph);

=== Chunk 1207 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0797.all-paths-from-source-to-target\AllPathsFromSourceToTargetTest.java

List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(0, 4));
        expectedResults.add(Arrays.asList(0, 3, 4));
        expectedResults.add(Arrays.asList(0, 1, 4));
        expectedResults.add(Arrays.asList(0, 1, 3, 4));
        expectedResults.add(Arrays.asList(0, 1, 2, 3, 4));

        Assertions.assertTrue(expectedResults.containsAll(results));
    }
}

=== Chunk 1208 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0804.unique-morse-code-words\UniqueMorseCodeWords.java

import java.util.HashSet;
import java.util.Set;

class UniqueMorseCodeWords {
    public int uniqueMorseRepresentations(String[] words) {
        Set<String> codeSet = new HashSet<>();
        String[] codes = {".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."};
        int res = 0;
        for (String word : words) {
            String morseCode = "";
            for (char c : word.toCharArray()) {
                morseCode = morseCode.concat(codes[c - 'a']);
            }
            if (!codeSet.contains(morseCode)) {
                codeSet.add(morseCode);
                res++;
            }
        }
        return res;
    }
}

=== Chunk 1209 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0804.unique-morse-code-words\UniqueMorseCodeWordsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class UniqueMorseCodeWordsTest {
    UniqueMorseCodeWords UniqueMorseCodeWords = new UniqueMorseCodeWords();

    @Test
    void Example1() {
        String[] words = {"gin","zen","gig","msg"};
        int results = UniqueMorseCodeWords.uniqueMorseRepresentations(words);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String[] words = {"a"};
        int results = UniqueMorseCodeWords.uniqueMorseRepresentations(words);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1210 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0814.binary-tree-pruning\BinaryTreePruning.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1211 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0814.binary-tree-pruning\BinaryTreePruning.java

class BinaryTreePruning {
    private boolean containsOne(TreeNode node) {
        if (node == null) return false;

        boolean leftContainsOne = containsOne(node.left);
        boolean rightContainsOne = containsOne(node.right);

        if (!leftContainsOne) node.left = null;
        if (!rightContainsOne) node.right = null;

        return node.val == 1 || leftContainsOne || rightContainsOne;
    }

    public TreeNode pruneTree(TreeNode root) {
        return containsOne(root) ? root : null;
    }
}

=== Chunk 1212 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0814.binary-tree-pruning\BinaryTreePruningTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1213 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0814.binary-tree-pruning\BinaryTreePruningTest.java

public class BinaryTreePruningTest {
    BinaryTreePruning BinaryTreePruning = new BinaryTreePruning();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(1);
        root.right = new TreeNode(0);
        root.right.left = new TreeNode(0);
        root.right.right = new TreeNode(1);
        TreeNode results = BinaryTreePruning.pruneTree(root);

        Assertions.assertNull(results.right.left);
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(0);
        root.left.left = new TreeNode(0);
        root.left.right = new TreeNode(0);
        root.right = new TreeNode(1);
        root.right.left = new TreeNode(0);
        root.right.right = new TreeNode(1);

=== Chunk 1214 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0814.binary-tree-pruning\BinaryTreePruningTest.java

root.right.right = new TreeNode(1);
        TreeNode results = BinaryTreePruning.pruneTree(root);

        Assertions.assertNull(results.left);
        Assertions.assertNull(results.right.left);
    }

    @Test
    void Example3() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(1);
        root.left.left = new TreeNode(1);
        root.left.left.left = new TreeNode(0);
        root.left.right = new TreeNode(1);
        root.right = new TreeNode(0);
        root.right.left = new TreeNode(0);
        root.right.right = new TreeNode(1);
        TreeNode results = BinaryTreePruning.pruneTree(root);

        Assertions.assertNull(results.left.left.left);
        Assertions.assertNull(results.right.left);
    }
}

=== Chunk 1215 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0815.bus-routes\BusRoutes.java

import java.awt.*;
import java.util.*;
import java.util.List;

=== Chunk 1216 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0815.bus-routes\BusRoutes.java

class BusRoutes {
    private boolean intersect(int[] a, int[] b) {
        int i = 0, j = 0;
        while (i < a.length && j < b.length) {
            if (a[i] == b[j]) return true;
            if (a[i] < b[j]) i++;
            else j++;
        }
        return false;
    }

    public int numBusesToDestination(int[][] routes, int source, int target) {
        if (source == target) return 0;
        int n = routes.length;

        List<List<Integer>> graph = new ArrayList<>();
        for (int[] route : routes) {
            Arrays.sort(route);
            graph.add(new ArrayList<>());
        }
        Set<Integer> seen = new HashSet<>();
        Set<Integer> targets = new HashSet<>();
        Queue<Point> queue = new ArrayDeque<>();

=== Chunk 1217 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0815.bus-routes\BusRoutes.java

for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (intersect(routes[i], routes[j])) {
                    graph.get(i).add(j);
                    graph.get(j).add(i);
                }
            }
        }

        for (int i = 0; i < n; i++) {
            if (Arrays.binarySearch(routes[i], source) >= 0) {
                seen.add(i);
                queue.offer(new Point(i, 0));
            }
            if (Arrays.binarySearch(routes[i], target) >= 0) {
                targets.add(i);
            }
        }

        while (!queue.isEmpty()) {
            Point info = queue.poll();
            int node = info.x, depth = info.y;
            if (targets.contains(node)) return depth + 1;

=== Chunk 1218 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0815.bus-routes\BusRoutes.java

for (Integer nei : graph.get(node)) {
                if (!seen.contains(nei)) {
                    seen.add(nei);
                    queue.offer(new Point(nei, depth + 1));
                }
            }
        }

        return -1;
    }
}

=== Chunk 1219 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0815.bus-routes\BusRoutesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class BusRoutesTest {
    BusRoutes BusRoutes = new BusRoutes();

    @Test
    void Example1() {
        int[][] routes = {{1, 2, 7}, {3, 6, 7}};
        int source = 1, target = 6;
        int results = BusRoutes.numBusesToDestination(routes, source, target);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] routes = {{7, 12}, {4, 5, 15}, {6}, {15, 19}, {9, 12, 13}};
        int source = 15, target = 12;
        int results = BusRoutes.numBusesToDestination(routes, source, target);
        int expectedResults = -1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1220 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0820.short-encoding-of-words\ShortEncodingOfWords.java

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

class ShortEncodingOfWords {
    public int minimumLengthEncoding(String[] words) {
        Set<String> wordSet = new HashSet<>(Arrays.asList(words));
        for (String s : words) {
            for (int i = 1; i < s.length(); i++) {
                wordSet.remove(s.substring(i));
            }
        }

        int length = 0;
        for (String s : wordSet) {
            length += s.length() + 1;
        }
        return length;
    }
}

=== Chunk 1221 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0820.short-encoding-of-words\ShortEncodingOfWordsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ShortEncodingOfWordsTest {
    ShortEncodingOfWords ShortEncodingOfWords = new ShortEncodingOfWords();

    @Test
    void Example1() {
        String[] words = {"time", "me", "bell"};
        int results = ShortEncodingOfWords.minimumLengthEncoding(words);
        int expectedResults = 10;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String[] words = {"t"};
        int results = ShortEncodingOfWords.minimumLengthEncoding(words);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1222 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0823.binary-trees-with-factors\BinaryTreesWithFactors.java

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

=== Chunk 1223 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0823.binary-trees-with-factors\BinaryTreesWithFactors.java

class BinaryTreesWithFactors {
    private final int mod = (int) (Math.pow(10, 9) + 7);

    public int numFactoredBinaryTrees(int[] arr) {
        if (arr.length == 0) return 0;

        Arrays.sort(arr);
        Map<Integer, Long> map = new HashMap<>();

        for (int i = 0; i < arr.length; i++) {
            long count = 1L;
            for (int j = 0; j < i; j++) {
                if (arr[i] % arr[j] == 0 && map.containsKey(arr[i] / arr[j])) {
                    count += map.get(arr[j]) * map.get(arr[i] / arr[j]);
                }
            }
            map.put(arr[i], count);
        }

        long totalCount = 0L;
        for (Map.Entry<Integer, Long> entry : map.entrySet()) {
            totalCount += entry.getValue();
        }

=== Chunk 1224 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0823.binary-trees-with-factors\BinaryTreesWithFactors.java

}

        return (int) (totalCount % mod);
    }
}

=== Chunk 1225 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0823.binary-trees-with-factors\BinaryTreesWithFactorsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1226 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0823.binary-trees-with-factors\BinaryTreesWithFactorsTest.java

public class BinaryTreesWithFactorsTest {
    BinaryTreesWithFactors BinaryTreesWithFactors = new BinaryTreesWithFactors();

    @Test
    void Example1() {
        int[] arr = {2, 4};
        int results = BinaryTreesWithFactors.numFactoredBinaryTrees(arr);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] arr = {2, 4, 5, 10};
        int results = BinaryTreesWithFactors.numFactoredBinaryTrees(arr);
        int expectedResults = 7;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 1227 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0823.binary-trees-with-factors\BinaryTreesWithFactorsTest.java

}

    @Test
    void Example3() {
        int[] arr = {46, 144, 5040, 4488, 544, 380, 4410, 34, 11, 5, 3063808, 5550, 34496, 12, 540, 28, 18, 13, 2, 1056, 32710656, 31, 91872, 23, 26, 240, 18720, 33, 49, 4, 38, 37, 1457, 3, 799, 557568, 32, 1400, 47, 10, 20774, 1296, 9, 21, 92928, 8704, 29, 2162, 22, 1883700, 49588, 1078, 36, 44, 352, 546, 19, 523370496, 476, 24, 6000, 42, 30, 8, 16262400, 61600, 41, 24150, 1968, 7056, 7, 35, 16, 87, 20, 2730, 11616, 10912, 690, 150, 25, 6, 14, 1689120, 43, 3128, 27, 197472, 45, 15, 585, 21645, 39, 40, 2205, 17, 48, 136};
        int results = BinaryTreesWithFactors.numFactoredBinaryTrees(arr);
        int expectedResults = 509730797;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1228 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0834.sum-of-distances-in-tree\SumOfDistancesInTree.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 1229 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0834.sum-of-distances-in-tree\SumOfDistancesInTree.java

class SumOfDistancesInTree {
    int[] ans, size, dp;
    List<List<Integer>> graph;

    public int[] sumOfDistancesInTree(int n, int[][] edges) {
        ans = new int[n];
        size = new int[n];
        dp = new int[n];
        graph = new ArrayList<>();
        for (int i = 0; i < n; i++)
            graph.add(new ArrayList<>());
        for (int[] edge : edges) {
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }
        dfs(0, -1);
        dfs2(0, -1);
        return ans;
    }

    public void dfs(int u, int f) {
        size[u] = 1;
        dp[u] = 0;
        for (int v : graph.get(u)) {
            if (v == f) continue;
            dfs(v, u);
            dp[u] += dp[v] + size[v];

=== Chunk 1230 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0834.sum-of-distances-in-tree\SumOfDistancesInTree.java

dp[u] += dp[v] + size[v];
            size[u] += size[v];
        }
    }

    public void dfs2(int u, int f) {
        ans[u] = dp[u];
        for (int v : graph.get(u)) {
            if (v == f) continue;
            int parentU = dp[u], parentV = dp[v];
            int childU = size[u], childV = size[v];

            dp[u] -= dp[v] + size[v];
            size[u] -= size[v];
            dp[v] += dp[u] + size[u];
            size[v] += size[u];

            dfs2(v, u);

            dp[u] = parentU;
            dp[v] = parentV;
            size[u] = childU;
            size[v] = childV;
        }
    }
}

=== Chunk 1231 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0834.sum-of-distances-in-tree\SumOfDistancesInTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1232 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0834.sum-of-distances-in-tree\SumOfDistancesInTreeTest.java

public class SumOfDistancesInTreeTest {
    SumOfDistancesInTree sumOfDistancesInTree = new SumOfDistancesInTree();

    @Test
    void Example1() {
        int n = 6;
        int[][] edges = {{0,1},{0,2},{2,3},{2,4},{2,5}};

        Assertions.assertArrayEquals(new int[]{8,12,6,10,10,10}, sumOfDistancesInTree.sumOfDistancesInTree(n, edges));
    }

    @Test
    void Example2() {
        int n = 1;
        int[][] edges = {};

        Assertions.assertArrayEquals(new int[]{0}, sumOfDistancesInTree.sumOfDistancesInTree(n, edges));
    }

    @Test
    void Example3() {
        int n = 2;
        int[][] edges = {{1, 0}};

        Assertions.assertArrayEquals(new int[]{1, 1}, sumOfDistancesInTree.sumOfDistancesInTree(n, edges));
    }
}

=== Chunk 1233 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0835.image-overlap\ImageOverlap.java

class ImageOverlap {
    private int shiftAndCount(int xShift, int yShift, int[][] matrix, int[][] reference) {
        int leftShiftCount = 0, rightShiftCount = 0;
        int rRow = 0;
        for (int mRow = yShift; mRow < matrix.length; mRow++) {
            int rCol = 0;
            for (int mCol = xShift; mCol < matrix.length; mCol++) {
                if (matrix[mRow][mCol] == 1 && matrix[mRow][mCol] == reference[rRow][rCol])
                    leftShiftCount += 1;
                if (matrix[mRow][rCol] == 1 && matrix[mRow][rCol] == reference[rRow][mCol])
                    rightShiftCount += 1;
                rCol += 1;
            }
            rRow += 1;
        }
        return Math.max(leftShiftCount, rightShiftCount);
    }

=== Chunk 1234 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0835.image-overlap\ImageOverlap.java

}

    public int largestOverlap(int[][] img1, int[][] img2) {
        int maxOverlaps = 0;
        for (int yShift = 0; yShift < img1.length; yShift++) {
            for (int xShift = 0; xShift < img1.length; xShift++) {
                maxOverlaps = Math.max(maxOverlaps, shiftAndCount(xShift, yShift, img1, img2));
                maxOverlaps = Math.max(maxOverlaps, shiftAndCount(xShift, yShift, img2, img1));
            }
        }
        return maxOverlaps;
    }
}

=== Chunk 1235 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0835.image-overlap\ImageOverlapTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1236 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0835.image-overlap\ImageOverlapTest.java

public class ImageOverlapTest {
    ImageOverlap ImageOverlap = new ImageOverlap();

    @Test
    void Example1() {
        int[][] img1 = {{1, 1, 0}, {0, 1, 0}, {0, 1, 0}},  img2 = {{0, 0, 0}, {0, 1, 1}, {0, 0, 1}};
        int results = ImageOverlap.largestOverlap(img1, img2);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] img1 = {{1}}, img2 = {{1}};
        int results = ImageOverlap.largestOverlap(img1, img2);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[][] img1 = {{0}}, img2 = {{0}};
        int results = ImageOverlap.largestOverlap(img1, img2);

=== Chunk 1237 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0835.image-overlap\ImageOverlapTest.java

int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        int[][] img1 = {{0, 1, 1, 1}, {0, 1, 1, 1}, {0, 1, 1, 1}, {0, 0, 0, 0}},  img2 = {{0, 0, 0, 0}, {1, 1, 1, 0}, {1, 1, 1, 0}, {1, 1, 1, 0}};
        int results = ImageOverlap.largestOverlap(img1, img2);
        int expectedResults = 9;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1238 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0838.push-dominoes\PushDominoes.java

class PushDominoes {
    public String pushDominoes(String dominoes) {
        int n = dominoes.length();
        int[] indexes = new int[n + 2];
        char[] symbols = new char[n + 2];
        int len = 1;
        indexes[0] = -1;
        symbols[0] = 'L';

        for (int i = 0; i < n; i++) {
            if (dominoes.charAt(i) != '.') {
                indexes[len] = i;
                symbols[len++] = dominoes.charAt(i);
            }
        }

        indexes[len] = n;
        symbols[len++] = 'R';

        char[] res = dominoes.toCharArray();
        for (int index = 0; index < len - 1; index++) {
            int i = indexes[index], j = indexes[index + 1];
            char x = symbols[index], y = symbols[index + 1];
            if (x == y) {

=== Chunk 1239 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0838.push-dominoes\PushDominoes.java

if (x == y) {
                for (int k = i + 1; k < j; k++) {
                    res[k] = x;
                }
            } else if (x > y) {
                for (int k = i + 1; k < j; k++) {
                    res[k] = k - i == j - k ? '.' : k - i < j - k ? 'R' : 'L';
                }
            }
        }
        return String.valueOf(res);
    }
}

=== Chunk 1240 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0838.push-dominoes\PushDominoesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class PushDominoesTest {
    PushDominoes PushDominoes = new PushDominoes();

    @Test
    void Example1() {
        String dominoes = "RR.L";
        String results = PushDominoes.pushDominoes(dominoes);
        String expectedResults = "RR.L";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String dominoes = ".L.R...LR..L..";
        String results = PushDominoes.pushDominoes(dominoes);
        String expectedResults = "LL.RR.LLRRLL..";

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1241 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0841.keys-and-rooms\KeysAndRooms.java

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

class KeysAndRooms {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size(), num = 0;
        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(0);
        visited[0] = true;
        while (!queue.isEmpty()) {
            int roomNumber = queue.poll();
            num++;
            for (int key : rooms.get(roomNumber)) {
                if (!visited[key]) {
                    visited[key] = true;
                    queue.offer(key);
                }
            }
        }
        return num == n;
    }
}

=== Chunk 1242 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0841.keys-and-rooms\KeysAndRooms2.java

import java.util.List;

class KeysAndRooms2 {
    boolean[] visited;
    int num;

    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();
        num = 0;
        visited = new boolean[n];
        dfs(rooms, 0);
        return num == n;
    }

    private void dfs(List<List<Integer>> rooms, int room) {
        visited[room] = true;
        num++;
        for (int key : rooms.get(room)) {
            if (!visited[key])
                dfs(rooms, key);
        }
    }
}

=== Chunk 1243 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0841.keys-and-rooms\KeysAndRoomsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 1244 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0841.keys-and-rooms\KeysAndRoomsTest.java

public class KeysAndRoomsTest {
    KeysAndRooms keysAndRooms = new KeysAndRooms();
    KeysAndRooms2 keysAndRooms2 = new KeysAndRooms2();

    @Test
    void Example1() {
        List<List<Integer>> rooms = new ArrayList<>();
        rooms.add(List.of(1));
        rooms.add(List.of(2));
        rooms.add(List.of(3));
        rooms.add(List.of());

        Assertions.assertTrue(keysAndRooms.canVisitAllRooms(rooms));
        Assertions.assertTrue(keysAndRooms2.canVisitAllRooms(rooms));
    }

    @Test
    void Example2() {
        List<List<Integer>> rooms = new ArrayList<>();
        rooms.add(Arrays.asList(1, 3));
        rooms.add(Arrays.asList(3, 0, 1));
        rooms.add(List.of(2));
        rooms.add(List.of(0));

=== Chunk 1245 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0841.keys-and-rooms\KeysAndRoomsTest.java

rooms.add(List.of(0));

        Assertions.assertFalse(keysAndRooms.canVisitAllRooms(rooms));
        Assertions.assertFalse(keysAndRooms2.canVisitAllRooms(rooms));
    }
}

=== Chunk 1246 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0844.backspace-string-compare\BackspaceStringCompare.java

import java.util.Stack;

=== Chunk 1247 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0844.backspace-string-compare\BackspaceStringCompare.java

class BackspaceStringCompare {
    private String filterString(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            stack.push(c);
        }
        StringBuilder res = new StringBuilder();
        int popCount = 0;
        while (!stack.isEmpty()) {
            if (stack.peek() == '#') {
                popCount++;
                stack.pop();
            } else if (popCount != 0) {
                stack.pop();
                popCount--;
            } else {
                res.append(stack.pop());
            }
        }
        return res.toString();
    }

    public boolean backspaceCompare(String s, String t) {
        String newS = filterString(s);
        String newT = filterString(t);

=== Chunk 1248 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0844.backspace-string-compare\BackspaceStringCompare.java

String newT = filterString(t);
        return newS.equals(newT);
    }
}

=== Chunk 1249 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0844.backspace-string-compare\BackspaceStringCompareTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1250 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0844.backspace-string-compare\BackspaceStringCompareTest.java

public class BackspaceStringCompareTest {
    BackspaceStringCompare BackspaceStringCompare = new BackspaceStringCompare();

    @Test
    void Example1() {
        String s = "ab#c", t = "ad#c";
        boolean results = BackspaceStringCompare.backspaceCompare(s, t);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "ab##", t = "c#d#";
        boolean results = BackspaceStringCompare.backspaceCompare(s, t);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "a#c", t = "b";
        boolean results = BackspaceStringCompare.backspaceCompare(s, t);

=== Chunk 1251 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0844.backspace-string-compare\BackspaceStringCompareTest.java

boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        String s = "a##c", t = "#a#c";
        boolean results = BackspaceStringCompare.backspaceCompare(s, t);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example5() {
        String s = "bxj##tw", t = "bxo#j##tw";
        boolean results = BackspaceStringCompare.backspaceCompare(s, t);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example6() {
        String s = "xywrrmp", t = "xywrrmu#p";
        boolean results = BackspaceStringCompare.backspaceCompare(s, t);

=== Chunk 1252 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0844.backspace-string-compare\BackspaceStringCompareTest.java

boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1253 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0858.mirror-reflection\MirrorReflection.java

class MirrorReflection {
    public int mirrorReflection(int p, int q) {
        while (p % 2 == 0 && q % 2 == 0) {
            p /= 2;
            q /= 2;
        }
        if (p % 2 == 0) return 2;
        if (q % 2 == 0) return 0;
        return 1;
    }
}

=== Chunk 1254 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0858.mirror-reflection\MirrorReflectionTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MirrorReflectionTest {
    MirrorReflection MirrorReflection = new MirrorReflection();

    @Test
    void Example1() {
        int p = 2, q = 1;
        int results = MirrorReflection.mirrorReflection(p, q);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int p = 3, q = 1;
        int results = MirrorReflection.mirrorReflection(p, q);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1255 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0869.reordered-power-of-2\ReorderedPowerOf2.java

import java.util.Arrays;

class ReorderedPowerOf2 {
    private int[] count(int n) {
        int[] res = new int[10];
        while (n > 0) {
            res[n % 10]++;
            n /= 10;
        }
        return res;
    }

    public boolean reorderedPowerOf2(int n) {
        int[] arrays = count(n);
        for (int i = 0; i < 31; i++) {
            if (Arrays.equals(arrays, count(1 << i))) {
                return true;
            }
        }
        return false;
    }
}

=== Chunk 1256 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0869.reordered-power-of-2\ReorderedPowerOf2Test.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ReorderedPowerOf2Test {
    ReorderedPowerOf2 ReorderedPowerOf2 = new ReorderedPowerOf2();

    @Test
    void Example1() {
        int n = 1;
        boolean results = ReorderedPowerOf2.reorderedPowerOf2(n);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 10;
        boolean results = ReorderedPowerOf2.reorderedPowerOf2(n);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1257 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0871.minimum-number-of-refueling-stops\MinimumNumberOfRefuelingStops.java

class MinimumNumberOfRefuelingStops {
    public int minRefuelStops(int target, int startFuel, int[][] stations) {
        long[] dp = new long[stations.length + 1];
        dp[0] = startFuel;

        for (int i = 0; i < stations.length; i++) {
            for (int refill = i; refill >= 0 && dp[refill] >= stations[i][0]; refill--) {
                dp[refill + 1] = Math.max(dp[refill + 1], dp[refill] + stations[i][1]);
            }
        }

        for (int i = 0; i <= stations.length; i++) {
            if (dp[i] >= target) return i;
        }

        return -1;
    }
}

=== Chunk 1258 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0871.minimum-number-of-refueling-stops\MinimumNumberOfRefuelingStopsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1259 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0871.minimum-number-of-refueling-stops\MinimumNumberOfRefuelingStopsTest.java

public class MinimumNumberOfRefuelingStopsTest {
    MinimumNumberOfRefuelingStops MinimumNumberOfRefuelingStops = new MinimumNumberOfRefuelingStops();

    @Test
    void Example1() {
        int target = 1, startFuel = 1;
        int[][] stations = {};
        int results = MinimumNumberOfRefuelingStops.minRefuelStops(target, startFuel, stations);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int target = 100, startFuel = 1;
        int[][] stations = {{10, 100}};
        int results = MinimumNumberOfRefuelingStops.minRefuelStops(target, startFuel, stations);
        int expectedResults = -1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test

=== Chunk 1260 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0871.minimum-number-of-refueling-stops\MinimumNumberOfRefuelingStopsTest.java

}

    @Test
    void Example3() {
        int target = 100, startFuel = 10;
        int[][] stations = {{10, 60}, {20, 30}, {30, 30}, {60, 40}};
        int results = MinimumNumberOfRefuelingStops.minRefuelStops(target, startFuel, stations);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1261 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0872.leaf-similar-trees\LeafSimilarTrees.java

import java.util.ArrayList;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1262 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0872.leaf-similar-trees\LeafSimilarTrees.java

class LeafSimilarTrees {
    private void dfs(TreeNode root, List<Integer> seq) {
        if (root.left == null && root.right == null)
            seq.add(root.val);
        else {
            if (root.left != null)
                dfs(root.left, seq);
            if (root.right != null)
                dfs(root.right, seq);
        }
    }

    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        List<Integer> seq1 = new ArrayList<>();
        if (root1 != null)
            dfs(root1, seq1);

        List<Integer> seq2 = new ArrayList<>();
        if (root2 != null)
            dfs(root2, seq2);

        return seq1.equals(seq2);
    }
}

=== Chunk 1263 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0872.leaf-similar-trees\LeafSimilarTreesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1264 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0872.leaf-similar-trees\LeafSimilarTreesTest.java

public class LeafSimilarTreesTest {
    LeafSimilarTrees leafSimilarTrees = new LeafSimilarTrees();

    @Test
    void Example1() {
        TreeNode root1 = new TreeNode(3);
        root1.left = new TreeNode(5);
        root1.left.left = new TreeNode(6);
        root1.left.right = new TreeNode(2);
        root1.left.right.left = new TreeNode(7);
        root1.left.right.right = new TreeNode(4);
        root1.right = new TreeNode(1);
        root1.right.left = new TreeNode(9);
        root1.right.right = new TreeNode(8);

        TreeNode root2 = new TreeNode(3);
        root2.left = new TreeNode(5);
        root2.left.left = new TreeNode(6);
        root2.left.right = new TreeNode(7);
        root2.right = new TreeNode(1);
        root2.right.left = new TreeNode(4);

=== Chunk 1265 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0872.leaf-similar-trees\LeafSimilarTreesTest.java

root2.right.left = new TreeNode(4);
        root2.right.right = new TreeNode(2);
        root2.right.right.left = new TreeNode(9);
        root2.right.right.right = new TreeNode(8);

        Assertions.assertTrue(leafSimilarTrees.leafSimilar(root1, root2));
    }

    @Test
    void Example2() {
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(3);

        TreeNode root2 = new TreeNode(1);
        root2.left = new TreeNode(3);
        root2.right = new TreeNode(2);

        Assertions.assertFalse(leafSimilarTrees.leafSimilar(root1, root2));
    }
}

=== Chunk 1266 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0876.middle-of-the-linked-list\MiddleOfTheLinkedList.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class MiddleOfTheLinkedList {
    public ListNode middleNode(ListNode head) {
        ListNode[] a = new ListNode[100];
        int cnt = 0;
        while (head != null) {
            a[cnt++] = head;
            head = head.next;
        }
        return a[cnt / 2];
    }
}

=== Chunk 1267 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0876.middle-of-the-linked-list\MiddleOfTheLinkedList2.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class MiddleOfTheLinkedList2 {
    public ListNode middleNode(ListNode head) {
        int cnt = 0;
        ListNode curr = head;
        while (curr != null) {
            cnt++;
            curr = curr.next;
        }
        int i = 0;
        curr = head;
        while (i < cnt / 2) {
            i++;
            curr = curr.next;
        }
        return curr;
    }
}

=== Chunk 1268 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0876.middle-of-the-linked-list\MiddleOfTheLinkedList3.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class MiddleOfTheLinkedList3 {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}

=== Chunk 1269 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0876.middle-of-the-linked-list\MiddleOfTheLinkedListTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1270 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0876.middle-of-the-linked-list\MiddleOfTheLinkedListTest.java

public class MiddleOfTheLinkedListTest {
    MiddleOfTheLinkedList middleOfTheLinkedList = new MiddleOfTheLinkedList();
    MiddleOfTheLinkedList2 middleOfTheLinkedList2 = new MiddleOfTheLinkedList2();
    MiddleOfTheLinkedList3 middleOfTheLinkedList3 = new MiddleOfTheLinkedList3();

    @Test
    void Example1() {
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);

        ListNode result = middleOfTheLinkedList.middleNode(head);

        Assertions.assertEquals(3, result.val);
        Assertions.assertEquals(4, result.next.val);
        Assertions.assertEquals(5, result.next.next.val);

=== Chunk 1271 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0876.middle-of-the-linked-list\MiddleOfTheLinkedListTest.java

result = middleOfTheLinkedList2.middleNode(head);

        Assertions.assertEquals(3, result.val);
        Assertions.assertEquals(4, result.next.val);
        Assertions.assertEquals(5, result.next.next.val);

        result = middleOfTheLinkedList3.middleNode(head);

        Assertions.assertEquals(3, result.val);
        Assertions.assertEquals(4, result.next.val);
        Assertions.assertEquals(5, result.next.next.val);
    }

    @Test
    void Example2() {
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);
        head.next.next.next.next.next = new ListNode(6);

=== Chunk 1272 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0876.middle-of-the-linked-list\MiddleOfTheLinkedListTest.java

ListNode result = middleOfTheLinkedList.middleNode(head);

        Assertions.assertEquals(4, result.val);
        Assertions.assertEquals(5, result.next.val);
        Assertions.assertEquals(6, result.next.next.val);

        result = middleOfTheLinkedList2.middleNode(head);

        Assertions.assertEquals(4, result.val);
        Assertions.assertEquals(5, result.next.val);
        Assertions.assertEquals(6, result.next.next.val);

        result = middleOfTheLinkedList3.middleNode(head);

        Assertions.assertEquals(4, result.val);
        Assertions.assertEquals(5, result.next.val);
        Assertions.assertEquals(6, result.next.next.val);
    }
}

=== Chunk 1273 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0881.boats-to-save-people\BoatsToSavePeople.java

import java.util.Arrays;

class BoatsToSavePeople {
    public int numRescueBoats(int[] people, int limit) {
        Arrays.sort(people);
        int res = 0;
        int l = 0, r = people.length - 1;
        while (l <= r) {
            if (people[l] + people[r] <= limit) {
                l++;
            }
            r--;
            res++;
        }
        return res;
    }
}

=== Chunk 1274 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0881.boats-to-save-people\BoatsToSavePeopleTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class BoatsToSavePeopleTest {
    BoatsToSavePeople boatsToSavePeople = new BoatsToSavePeople();

    @Test
    void Example1() {
        int[] people = {1, 2};
        int limit = 3;

        Assertions.assertEquals(1, boatsToSavePeople.numRescueBoats(people, limit));
    }

    @Test
    void Example2() {
        int[] people = {3, 2, 2, 1};
        int limit = 3;

        Assertions.assertEquals(3, boatsToSavePeople.numRescueBoats(people, limit));
    }

    @Test
    void Example3() {
        int[] people = {3, 5, 3, 4};
        int limit = 5;

        Assertions.assertEquals(4, boatsToSavePeople.numRescueBoats(people, limit));
    }
}

=== Chunk 1275 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0886.possible-bipartition\PossibleBipartition.java

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;

=== Chunk 1276 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0886.possible-bipartition\PossibleBipartition.java

class PossibleBipartition {
    public boolean possibleBipartition(int n, int[][] dislikes) {
       int[] color = new int[n + 1];
       List<Integer>[] graph = new List[n + 1];
       for (int i = 0; i <= n; i++)
           graph[i] = new ArrayList<>();
       for (int[] edge : dislikes) {
           graph[edge[0]].add(edge[1]);
           graph[edge[1]].add(edge[0]);
       }
       for (int i = 1; i <= n; i++) {
           if (color[i] == 0) {
               Queue<Integer> queue = new ArrayDeque<>();
               queue.offer(i);
               color[i] = 1;
               while (!queue.isEmpty()) {
                   int curr = queue.poll();
                   for (int next : graph[curr]) {
                       if (color[next] > 0 && color[next] == color[curr])

=== Chunk 1277 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0886.possible-bipartition\PossibleBipartition.java

return false;
                       if (color[next] == 0) {
                           color[next] = 3 ^ color[curr];
                           queue.offer(next);
                       }
                   }
               }
           }
       }
       return true;
    }
}

=== Chunk 1278 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0886.possible-bipartition\PossibleBipartition2.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 1279 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0886.possible-bipartition\PossibleBipartition2.java

class PossibleBipartition2 {
    public boolean possibleBipartition(int n, int[][] dislikes) {
       int[] color = new int[n + 1];
       List<Integer>[] graph = new List[n + 1];
       for (int i = 0; i <= n; i++)
           graph[i] = new ArrayList<>();
       for (int[] edges : dislikes) {
           graph[edges[0]].add(edges[1]);
           graph[edges[1]].add(edges[0]);
       }
       for (int i = 1; i <= n; i++) {
           if (color[i] == 0 && !dfs(i, 1, color, graph))
               return false;
       }
       return true;
    }

    private boolean dfs(int curr, int currColor, int[] color, List<Integer>[] graph) {
        color[curr] = currColor;
        for (int next : graph[curr]) {
            if (color[next] != 0 && color[next] == color[curr])

=== Chunk 1280 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0886.possible-bipartition\PossibleBipartition2.java

return false;
            if (color[next] == 0 && !dfs(next, 3 ^ currColor, color, graph))
                return false;
        }
        return true;
    }
}

=== Chunk 1281 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0886.possible-bipartition\PossibleBipartitionTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1282 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0886.possible-bipartition\PossibleBipartitionTest.java

public class PossibleBipartitionTest {
    PossibleBipartition possibleBipartition = new PossibleBipartition();
    PossibleBipartition2 possibleBipartition2 = new PossibleBipartition2();

    @Test
    void Example1() {
        int n = 4;
        int[][] dislikes = {{1, 2}, {1, 3}, {2, 4}};

        Assertions.assertTrue(possibleBipartition.possibleBipartition(n, dislikes));
        Assertions.assertTrue(possibleBipartition2.possibleBipartition(n, dislikes));
    }

    @Test
    void Example2() {
        int n = 3;
        int[][] dislikes = {{1, 2}, {1, 3}, {2, 3}};

        Assertions.assertFalse(possibleBipartition.possibleBipartition(n, dislikes));
        Assertions.assertFalse(possibleBipartition2.possibleBipartition(n, dislikes));
    }

    @Test

=== Chunk 1283 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0886.possible-bipartition\PossibleBipartitionTest.java

}

    @Test
    void Example3() {
        int n = 5;
        int[][] dislikes = {{1, 2}, {2, 3}, {3, 4}, {4, 5}, {1, 5}};

        Assertions.assertFalse(possibleBipartition.possibleBipartition(n, dislikes));
        Assertions.assertFalse(possibleBipartition2.possibleBipartition(n, dislikes));
    }
}

=== Chunk 1284 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0890.find-and-replace-pattern\FindAndReplacePattern.java

import java.util.LinkedList;
import java.util.List;

class FindAndReplacePattern {
    public List<String> findAndReplacePattern(String[] words, String pattern) {
        List<String> ans = new LinkedList<>();
        for (String w : words) {
            int[] p = new int[26], s = new int[26];
            boolean same = true;
            for (int i = 0; i < w.length(); i++) {
                if (s[w.charAt(i) - 'a'] != p[pattern.charAt(i) - 'a']) {
                    same = false;
                    break;
                } else {
                    s[w.charAt(i) - 'a'] = p[pattern.charAt(i) - 'a'] = i + 1;
                }
            }
            if (same) ans.add(w);
        }
        return ans;
    }
}

=== Chunk 1285 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0890.find-and-replace-pattern\FindAndReplacePatternTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

=== Chunk 1286 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0890.find-and-replace-pattern\FindAndReplacePatternTest.java

public class FindAndReplacePatternTest {
    FindAndReplacePattern FindAndReplacePattern = new FindAndReplacePattern();

    @Test
    void Example1() {
        String[] words = {"abc", "deq", "mee", "aqq", "dkd", "ccc"};
        String pattern = "abb";
        List<String> result = FindAndReplacePattern.findAndReplacePattern(words, pattern);
        List<String> expectedResults = Arrays.asList("mee", "aqq");

        Assertions.assertEquals(expectedResults, result);
    }

    @Test
    void Example2() {
        String[] words = {"a", "b", "c"};
        String pattern = "a";
        List<String> result = FindAndReplacePattern.findAndReplacePattern(words, pattern);
        List<String> expectedResults = Arrays.asList("a", "b",  "c");

=== Chunk 1287 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0890.find-and-replace-pattern\FindAndReplacePatternTest.java

Assertions.assertEquals(expectedResults, result);
    }
}

=== Chunk 1288 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0901.online-stock-span\OnlineStockSpan.java

import java.util.Stack;

class StockSpanner {
    Stack<int[]> stack = new Stack<>();

    public StockSpanner() {

    }
    
    public int next(int price) {
        int res = 1;
        while (!stack.isEmpty() && stack.peek()[0] <= price) {
            res += stack.pop()[1];
        }
        stack.push(new int[]{price, res});
        return res;
    }
}

/**
 * Your StockSpanner object will be instantiated and called as such:
 * StockSpanner obj = new StockSpanner();
 * int param_1 = obj.next(price);
 */

=== Chunk 1289 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0901.online-stock-span\OnlineStockSpanTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class OnlineStockSpanTest {
    @Test
    void Example1() {
        StockSpanner stockSpanner = new StockSpanner();
        Assertions.assertEquals(1, stockSpanner.next(100));
        Assertions.assertEquals(1, stockSpanner.next(80));
        Assertions.assertEquals(1, stockSpanner.next(60));
        Assertions.assertEquals(2, stockSpanner.next(70));
        Assertions.assertEquals(1, stockSpanner.next(60));
        Assertions.assertEquals(4, stockSpanner.next(75));
        Assertions.assertEquals(6, stockSpanner.next(85));
    }
}

=== Chunk 1290 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0904.fruit-into-baskets\FruitIntoBaskets.java

import java.util.HashMap;
import java.util.Map;

class FruitIntoBaskets {
    public int totalFruit(int[] fruits) {
        int n = fruits.length;
        Map<Integer, Integer> cnt = new HashMap<>();

        int left = 0, res = 0;
        for (int right = 0; right < n; right++) {
            cnt.put(fruits[right], cnt.getOrDefault(fruits[right], 0) + 1);
            while (cnt.size() > 2) {
                cnt.put(fruits[left], cnt.get(fruits[left]) - 1);
                if (cnt.get(fruits[left]) == 0)
                    cnt.remove(fruits[left]);
                left++;
            }
            res = Math.max(res, right - left + 1);
        }
        return res;
    }
}

=== Chunk 1291 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0904.fruit-into-baskets\FruitIntoBasketsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class FruitIntoBasketsTest {
    FruitIntoBaskets fruitIntoBaskets = new FruitIntoBaskets();

    @Test
    void Example1() {
        int[] fruits = {1, 2, 1};

        Assertions.assertEquals(3, fruitIntoBaskets.totalFruit(fruits));
    }

    @Test
    void Example2() {
        int[] fruits = {0, 1, 2, 2};

        Assertions.assertEquals(3, fruitIntoBaskets.totalFruit(fruits));
    }

    @Test
    void Example3() {
        int[] fruits = {1, 2, 3, 2, 2};

        Assertions.assertEquals(4, fruitIntoBaskets.totalFruit(fruits));
    }
}

=== Chunk 1292 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0907.sum-of-subarray-minimums\SumOfSubarrayMinimums.java

import java.util.Stack;

=== Chunk 1293 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0907.sum-of-subarray-minimums\SumOfSubarrayMinimums.java

class SumOfSubarrayMinimums {
    private final int modulo = (int) (Math.pow(10, 9) + 7);

    public int sumSubarrayMins(int[] arr) {
        Stack<Integer> stack = new Stack<>();
        long sumOfMinimums = 0;

        for (int i = 0; i <= arr.length; i++) {
            while (!stack.empty() && (i == arr.length || arr[stack.peek()] >= arr[i])) {
                int mid = stack.pop();
                int leftBoundary = stack.empty() ? -1 : stack.peek();
                int rightBoundary = i;

                long count = (long) (mid - leftBoundary) * (rightBoundary - mid) % modulo;
                sumOfMinimums += (count * arr[mid]) % modulo;
                sumOfMinimums %= modulo;
            }
            stack.push(i);
        }

=== Chunk 1294 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0907.sum-of-subarray-minimums\SumOfSubarrayMinimums.java

stack.push(i);
        }

        return (int) sumOfMinimums;
    }
}

=== Chunk 1295 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0907.sum-of-subarray-minimums\SumOfSubarrayMinimumsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SumOfSubarrayMinimumsTest {
    SumOfSubarrayMinimums sumOfSubarrayMinimums = new SumOfSubarrayMinimums();

    @Test
    void Example1() {
        int[] arr = {3, 1, 2, 4};
        int results = sumOfSubarrayMinimums.sumSubarrayMins(arr);

        Assertions.assertEquals(17, results);
    }

    @Test
    void Example2() {
        int[] arr = {11, 81, 94, 43, 3};
        int results = sumOfSubarrayMinimums.sumSubarrayMins(arr);

        Assertions.assertEquals(444, results);
    }
}

=== Chunk 1296 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0912.sort-an-array\SortAnArray.java

class SortAnArray {
    int[] tmp;

    public int[] sortArray(int[] nums) {
        tmp = new int[nums.length];
        mergeSort(nums, 0, nums.length - 1);
        return nums;
    }

    private void mergeSort(int[] nums, int l, int r) {
        if (l >= r) {
            return;
        }
        int mid = l + (r - l) / 2;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
        int i = l, j = mid + 1;
        int cnt = 0;
        while (i <= mid && j <= r) {
            if (nums[i] <= nums[j]) {
                tmp[cnt++] = nums[i++];
            } else {
                tmp[cnt++] = nums[j++];
            }
        }
        while (i <= mid) {
            tmp[cnt++] = nums[i++];
        }
        while (j <= r) {

=== Chunk 1297 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0912.sort-an-array\SortAnArray.java

}
        while (j <= r) {
            tmp[cnt++] = nums[j++];
        }
        for (int k = 0; k < r - l + 1; k++) {
            nums[k + l] = tmp[k];
        }
    }
}

=== Chunk 1298 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0912.sort-an-array\SortAnArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SortAnArrayTest {
    SortAnArray sortAnArray = new SortAnArray();

    @Test
    void Example1() {
        int[] nums = {5, 2, 3, 1};

        Assertions.assertArrayEquals(new int[]{1, 2, 3, 5}, sortAnArray.sortArray(nums));
    }

    @Test
    void Example2() {
        int[] nums = {5, 1, 1, 2, 0, 0};

        Assertions.assertArrayEquals(new int[]{0, 0, 1, 1, 2, 5}, sortAnArray.sortArray(nums));
    }
}

=== Chunk 1299 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0916.word-subsets\WordSubsets.java

import java.util.LinkedList;
import java.util.List;

=== Chunk 1300 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0916.word-subsets\WordSubsets.java

class WordSubsets {
    private int[] count(String s) {
        int[] ans = new int[26];
        for (char c : s.toCharArray()) ans[c - 'a']++;
        return ans;
    }

    public List<String> wordSubsets(String[] words1, String[] words2) {
        int[] word2Max = count("");
        for (String word2 : words2) {
            int[] word2Count = count(word2);
            for (int i = 0; i < 26; i++) word2Max[i] = Math.max(word2Max[i], word2Count[i]);
        }

        List<String> ans = new LinkedList<>();
        search: for (String word1 : words1) {
            int[] word1Count = count(word1);
            for (int i = 0; i < 26; i++) {
                if (word1Count[i] < word2Max[i]) continue search;
            }
            ans.add(word1);
        }

=== Chunk 1301 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0916.word-subsets\WordSubsets.java

ans.add(word1);
        }

        return ans;
    }
}

=== Chunk 1302 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0916.word-subsets\WordSubsetsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

=== Chunk 1303 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0916.word-subsets\WordSubsetsTest.java

public class WordSubsetsTest {
    WordSubsets WordSubsets = new WordSubsets();

    @Test
    void Example1() {
        String[] words1 = {"amazon", "apple", "facebook", "google", "leetcode"},  words2 = {"e", "o"};
        List<String> result = WordSubsets.wordSubsets(words1, words2);
        List<String> expectedResults = Arrays.asList("facebook", "google", "leetcode");

        Assertions.assertEquals(expectedResults, result);
    }

    @Test
    void Example2() {
        String[] words1 = {"amazon", "apple", "facebook", "google", "leetcode"},  words2 = {"l", "e"};
        List<String> result = WordSubsets.wordSubsets(words1, words2);
        List<String> expectedResults = Arrays.asList("apple", "google", "leetcode");

=== Chunk 1304 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0916.word-subsets\WordSubsetsTest.java

Assertions.assertEquals(expectedResults, result);
    }
}

=== Chunk 1305 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0926.flip-string-to-monotone-increasing\FlipStringToMonotoneIncreasing.java

class FlipStringToMonotoneIncreasing {
    public int minFlipsMonoIncr(String s) {
        int n = s.length();
        int dp0 = 0, dp1 = 0;
        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            int dp0New = dp0, dp1New = Math.min(dp0, dp1);
            if (c == '1')
                dp0New++;
            else
                dp1New++;
            dp0 = dp0New;
            dp1 = dp1New;
        }
        return Math.min(dp0, dp1);
    }
}

=== Chunk 1306 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0926.flip-string-to-monotone-increasing\FlipStringToMonotoneIncreasingTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class FlipStringToMonotoneIncreasingTest {
    FlipStringToMonotoneIncreasing flipStringToMonotoneIncreasing = new FlipStringToMonotoneIncreasing();

    @Test
    void Example1() {
        String s = "00110";

        Assertions.assertEquals(1, flipStringToMonotoneIncreasing.minFlipsMonoIncr(s));
    }

    @Test
    void Example2() {
        String s = "010110";

        Assertions.assertEquals(2, flipStringToMonotoneIncreasing.minFlipsMonoIncr(s));
    }

    @Test
    void Example3() {
        String s = "00011000";

        Assertions.assertEquals(2, flipStringToMonotoneIncreasing.minFlipsMonoIncr(s));
    }
}

=== Chunk 1307 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0931.minimum-falling-path-sum\MinimumFallingPathSum.java

class MinimumFallingPathSum {
    public int minFallingPathSum(int[][] matrix) {
        int n = matrix.length;
        for (int r = n - 2; r >= 0; r--) {
            for (int c = 0; c < n; c++) {
                int min = matrix[r + 1][c];
                if (c > 0)
                    min = Math.min(min, matrix[r + 1][c - 1]);
                if (c + 1 < n)
                    min = Math.min(min, matrix[r + 1][c + 1]);
                matrix[r][c] += min;
            }
        }
        int res = Integer.MAX_VALUE;
        for (int num : matrix[0])
            res = Math.min(res, num);
        return res;
    }
}

=== Chunk 1308 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0931.minimum-falling-path-sum\MinimumFallingPathSumTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MinimumFallingPathSumTest {
    MinimumFallingPathSum minimumFallingPathSum = new MinimumFallingPathSum();

    @Test
    void Example1() {
        int[][] matrix = {{2, 1, 3}, {6, 5, 4}, {7, 8, 9}};

        Assertions.assertEquals(13, minimumFallingPathSum.minFallingPathSum(matrix));
    }

    @Test
    void Example2() {
        int[][] matrix = {{-19, 57}, {-40, -5}};

        Assertions.assertEquals(-59, minimumFallingPathSum.minFallingPathSum(matrix));
    }
}

=== Chunk 1309 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0936.stamping-the-sequence\StampingTheSequence.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 1310 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0936.stamping-the-sequence\StampingTheSequence.java

class StampingTheSequence {
    private boolean canReplace(char[] tChars, int pos, char[] sChars) {
        for (int i = 0; i < sChars.length; i++) {
            if (tChars[i + pos] != '?' && tChars[i + pos] != sChars[i]) {
                return false;
            }
        }
        return true;
    }

    private int replace(char[] tChars, int pos, int len, int count) {
        for (int i = 0; i < len; i++) {
            if (tChars[i + pos] != '?') {
                tChars[i + pos] = '?';
                count++;
            }
        }
        return count;
    }

    public int[] movesToStamp(String stamp, String target) {
        char[] sChars = stamp.toCharArray();
        char[] tChars = target.toCharArray();
        int count = 0;

=== Chunk 1311 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0936.stamping-the-sequence\StampingTheSequence.java

int count = 0;
        boolean[] visited = new boolean[tChars.length];
        List<Integer> res = new ArrayList<>();

        while (count != tChars.length) {
            boolean didChange = false;
            for (int i = 0; i <= tChars.length - sChars.length; i++) {
                if (!visited[i] && canReplace(tChars, i, sChars)) {
                    count = replace(tChars, i, sChars.length, count);
                    visited[i] = true;
                    didChange = true;
                    res.add(i);

                    if (count == tChars.length) break;
                }
            }

            if (!didChange) return new int[0];
        }

        int[] result = new int[res.size()];
        int k = 0;

=== Chunk 1312 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0936.stamping-the-sequence\StampingTheSequence.java

int k = 0;
        for (int i = res.size() - 1; i >= 0; i--) {
            result[k++] = res.get(i);
        }

        return result;
    }
}

=== Chunk 1313 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0936.stamping-the-sequence\StampingTheSequenceTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class StampingTheSequenceTest {
    StampingTheSequence StampingTheSequence = new StampingTheSequence();

    @Test
    void Example1() {
        String stamp = "abc", target = "ababc";
        int[] results = StampingTheSequence.movesToStamp(stamp, target);
        int[] expectedResults = {0, 2};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String stamp = "abca", target = "aabcaca";
        int[] results = StampingTheSequence.movesToStamp(stamp, target);
        int[] expectedResults = {0, 3, 1};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 1314 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0938.range-sum-of-bst\RangeSumOfBst.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class RangeSumOfBst {
    public int rangeSumBST(TreeNode root, int low, int high) {
        if (root == null) return 0;
        if (root.val > high)
            return rangeSumBST(root.left, low, high);
        if (root.val < low)
            return rangeSumBST(root.right, low, high);
        return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);
    }
}

=== Chunk 1315 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0938.range-sum-of-bst\RangeSumOfBst2.java

import java.util.LinkedList;
import java.util.Queue;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1316 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0938.range-sum-of-bst\RangeSumOfBst2.java

class RangeSumOfBst2 {
    public int rangeSumBST(TreeNode root, int low, int high) {
        int sum = 0;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        while (!q.isEmpty()) {
            TreeNode node = q.poll();
            if (node == null) {
                continue;
            }
            if (node.val > high)
                q.offer(node.left);
            else if (node.val < low)
                q.offer(node.right);
            else {
                sum += node.val;
                q.offer(node.left);
                q.offer(node.right);
            }
        }
        return sum;
    }
}

=== Chunk 1317 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0938.range-sum-of-bst\RangeSumOfBstTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1318 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0938.range-sum-of-bst\RangeSumOfBstTest.java

public class RangeSumOfBstTest {
    RangeSumOfBst rangeSumOfBst = new RangeSumOfBst();
    RangeSumOfBst2 rangeSumOfBst2 = new RangeSumOfBst2();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(10);
        root.left = new TreeNode(5);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(7);
        root.right = new TreeNode(15);
        root.right.right = new TreeNode(18);

        int results = rangeSumOfBst.rangeSumBST(root, 7, 15);
        int expectedResults = 32;

        Assertions.assertEquals(expectedResults, results);

        results = rangeSumOfBst2.rangeSumBST(root, 7, 15);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {

=== Chunk 1319 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0938.range-sum-of-bst\RangeSumOfBstTest.java

}

    @Test
    void Example2() {
        TreeNode root = new TreeNode(10);
        root.left = new TreeNode(5);
        root.left.left = new TreeNode(3);
        root.left.left.left = new TreeNode(1);
        root.left.right = new TreeNode(7);
        root.left.right.left = new TreeNode(6);
        root.right = new TreeNode(15);
        root.right.left = new TreeNode(13);
        root.right.right = new TreeNode(18);

        int results = rangeSumOfBst.rangeSumBST(root, 6, 10);
        int expectedResults = 23;

        Assertions.assertEquals(expectedResults, results);

        results = rangeSumOfBst2.rangeSumBST(root, 6, 10);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1320 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0944.delete-columns-to-make-sorted\DeleteColumnsToMakeSorted.java

class DeleteColumnsToMakeSorted {
    public int minDeletionSize(String[] strs) {
        int ans = 0, n = strs.length;
        for (int i = 0; i < strs[0].length(); i++) {
            for (int j = 1; j < n; j++) {
                if (strs[j].charAt(i) < strs[j - 1].charAt(i)) {
                    ans++;
                    break;
                }
            }
        }
        return ans;
    }
}

=== Chunk 1321 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0944.delete-columns-to-make-sorted\DeleteColumnsToMakeSortedTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class DeleteColumnsToMakeSortedTest {
    DeleteColumnsToMakeSorted deleteColumnsToMakeSorted = new DeleteColumnsToMakeSorted();

    @Test
    void Example1() {
        String[] strs = {"cba", "daf", "ghi"};

        Assertions.assertEquals(1, deleteColumnsToMakeSorted.minDeletionSize(strs));
    }

    @Test
    void Example2() {
        String[] strs = {"a", "b"};

        Assertions.assertEquals(0, deleteColumnsToMakeSorted.minDeletionSize(strs));
    }

    @Test
    void Example3() {
        String[] strs = {"zyx", "wvu", "tsr"};

        Assertions.assertEquals(3, deleteColumnsToMakeSorted.minDeletionSize(strs));
    }
}

=== Chunk 1322 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0946.validate-stack-sequences\ValidateStackSequences.java

import java.util.Stack;

class ValidateStackSequences {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        Stack<Integer> stack = new Stack<>();
        int pushIndex = 0, popIndex = 0;
        while (popIndex < popped.length) {
            if (stack.isEmpty() && pushIndex < pushed.length) {
                stack.push(pushed[pushIndex++]);
            } else if (stack.peek() == popped[popIndex]) {
                stack.pop();
                popIndex++;
            } else if (pushIndex < pushed.length) {
                stack.push(pushed[pushIndex++]);
            } else {
                return false;
            }
        }

        return true;
    }
}

=== Chunk 1323 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0946.validate-stack-sequences\ValidateStackSequencesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1324 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0946.validate-stack-sequences\ValidateStackSequencesTest.java

public class ValidateStackSequencesTest {
    ValidateStackSequences validateStackSequences = new ValidateStackSequences();

    @Test
    void Example1() {
        int[] pushed = {1, 2, 3, 4, 5}, popped = {4, 5, 3, 2, 1};

        Assertions.assertTrue(validateStackSequences.validateStackSequences(pushed, popped));
    }

    @Test
    void Example2() {
        int[] pushed = {1, 2, 3, 4, 5}, popped = {4, 3, 5, 1, 2};

        Assertions.assertFalse(validateStackSequences.validateStackSequences(pushed, popped));
    }

    @Test
    void Example3() {
        int[] pushed = {4, 0, 1, 2, 3}, popped = {4, 2, 3, 0, 1};

        Assertions.assertFalse(validateStackSequences.validateStackSequences(pushed, popped));
    }
}

=== Chunk 1325 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0947.most-stones-removed-with-same-row-or-column\MostStonesRemovedWithSameRowOrColumn.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 1326 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0947.most-stones-removed-with-same-row-or-column\MostStonesRemovedWithSameRowOrColumn.java

class MostStonesRemovedWithSameRowOrColumn {
    private boolean shareSameRowOrColumn(int[] a, int[] b) {
        return a[0] == b[0] || a[1] == b[1];
    }

    private void dfs(int[][] stones, List<Integer>[] adj, int[] visited, int src) {
        visited[src] = 1;
        for (int adjacent : adj[src]) {
            if (visited[adjacent] == 0) {
                dfs(stones, adj, visited, adjacent);
            }
        }
    }

    public int removeStones(int[][] stones) {
        List<Integer>[] adj = new ArrayList[stones.length];
        for (int i = 0; i < stones.length; i++) {
            adj[i] = new ArrayList<>();
        }

        for (int i = 0; i < stones.length; i++) {
            for (int j = i + 1; j < stones.length; j++) {

=== Chunk 1327 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0947.most-stones-removed-with-same-row-or-column\MostStonesRemovedWithSameRowOrColumn.java

if (shareSameRowOrColumn(stones[i], stones[j])) {
                    adj[i].add(j);
                    adj[j].add(i);
                }
            }
        }

        int[] visited = new int[stones.length];
        int componentCount = 0;
        for (int i = 0; i < stones.length; i++) {
            if (visited[i] == 0) {
                componentCount++;
                dfs(stones, adj, visited, i);
            }
        }
        return stones.length - componentCount;
    }
}

=== Chunk 1328 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0947.most-stones-removed-with-same-row-or-column\MostStonesRemovedWithSameRowOrColumnTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1329 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0947.most-stones-removed-with-same-row-or-column\MostStonesRemovedWithSameRowOrColumnTest.java

public class MostStonesRemovedWithSameRowOrColumnTest {
    MostStonesRemovedWithSameRowOrColumn MostStonesRemovedWithSameRowOrColumn = new MostStonesRemovedWithSameRowOrColumn();

    @Test
    void Example1() {
        int[][] stones = {{0, 0}, {0, 1}, {1, 0}, {1, 2}, {2, 1}, {2, 2}};
        int results = MostStonesRemovedWithSameRowOrColumn.removeStones(stones);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] stones = {{0, 0}, {0, 2}, {1, 1}, {2, 0}, {2, 2}};
        int results = MostStonesRemovedWithSameRowOrColumn.removeStones(stones);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test

=== Chunk 1330 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0947.most-stones-removed-with-same-row-or-column\MostStonesRemovedWithSameRowOrColumnTest.java

}

    @Test
    void Example3() {
        int[][] stones = {{0, 0}};
        int results = MostStonesRemovedWithSameRowOrColumn.removeStones(stones);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1331 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0948.bag-of-tokens\BagOfTokens.java

import java.util.Arrays;

class BagOfTokens {
    public int bagOfTokensScore(int[] tokens, int power) {
        Arrays.sort(tokens);
        int left = 0, right = tokens.length - 1, res = 0;
        while (left <= right) {
            if (tokens[left] <= power) {
                power -= tokens[left];
                res++;
                left++;
            } else {
                if (left != right && res > 0) {
                    power += tokens[right];
                    res--;
                    right--;
                } else {
                    break;
                }
            }
        }
        return res;
    }
}

=== Chunk 1332 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0948.bag-of-tokens\BagOfTokens2.java

import java.util.Arrays;

class BagOfTokens2 {
    public int bagOfTokensScore(int[] tokens, int power) {
        Arrays.sort(tokens);
        int left = 0, right = tokens.length - 1, points = 0, res = 0;
        while (left <= right && (power >= tokens[left] || points > 0)) {
            while (left <= right && power >= tokens[left]) {
                power -= tokens[left++];
                points++;
            }
            res = Math.max(res, points);
            if (left <= right && points > 0) {
                power += tokens[right--];
                points--;
            }
        }
        return res;
    }
}

=== Chunk 1333 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0948.bag-of-tokens\BagOfTokensTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1334 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0948.bag-of-tokens\BagOfTokensTest.java

public class BagOfTokensTest {
    BagOfTokens BagOfTokens = new BagOfTokens();
    BagOfTokens2 BagOfTokens2 = new BagOfTokens2();

    @Test
    void Example1() {
        int[] tokens = {100};
        int power = 50;
        int results = BagOfTokens.bagOfTokensScore(tokens, power);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);

        results = BagOfTokens2.bagOfTokensScore(tokens, power);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] tokens = {100, 200};
        int power = 150;
        int results = BagOfTokens.bagOfTokensScore(tokens, power);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);

=== Chunk 1335 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0948.bag-of-tokens\BagOfTokensTest.java

results = BagOfTokens2.bagOfTokensScore(tokens, power);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] tokens = {100, 200, 300, 400};
        int power = 200;
        int results = BagOfTokens.bagOfTokensScore(tokens, power);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);

        results = BagOfTokens2.bagOfTokensScore(tokens, power);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1336 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0953.verifying-an-alien-dictionary\VerifyingAnAlienDictionary.java

class VerifyingAnAlienDictionary {
    public boolean isAlienSorted(String[] words, String order) {
        int[] index = new int[26];
        for (int i = 0; i < order.length(); i++)
            index[order.charAt(i) - 'a'] = i;
        for (int i = 1; i < words.length; i++) {
            boolean valid = false;
            for (int j = 0; j < words[i - 1].length() && j < words[i].length(); j++) {
                int prev = index[words[i - 1].charAt(j) - 'a'];
                int curr = index[words[i].charAt(j) - 'a'];
                if (prev < curr) {
                    valid = true;
                    break;
                } else if (prev > curr) {
                    return false;
                }
            }
            if (!valid) {

=== Chunk 1337 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0953.verifying-an-alien-dictionary\VerifyingAnAlienDictionary.java

}
            if (!valid) {
                if (words[i - 1].length() > words[i].length())
                    return false;
            }
        }
        return true;
    }
}

=== Chunk 1338 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0953.verifying-an-alien-dictionary\VerifyingAnAlienDictionaryTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1339 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0953.verifying-an-alien-dictionary\VerifyingAnAlienDictionaryTest.java

public class VerifyingAnAlienDictionaryTest {
    VerifyingAnAlienDictionary verifyingAnAlienDictionary = new VerifyingAnAlienDictionary();

    @Test
    void Example1() {
        String[] words = {"hello", "leetcode"};
        String order = "hlabcdefgijkmnopqrstuvwxyz";

        Assertions.assertTrue(verifyingAnAlienDictionary.isAlienSorted(words, order));
    }

    @Test
    void Example2() {
        String[] words = {"word", "world", "row"};
        String order = "worldabcefghijkmnpqstuvxyz";

        Assertions.assertFalse(verifyingAnAlienDictionary.isAlienSorted(words, order));
    }

    @Test
    void Example3() {
        String[] words = {"apple", "app"};
        String order = "abcdefghijklmnopqrstuvwxyz";

=== Chunk 1340 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0953.verifying-an-alien-dictionary\VerifyingAnAlienDictionaryTest.java

Assertions.assertFalse(verifyingAnAlienDictionary.isAlienSorted(words, order));
    }
}

=== Chunk 1341 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0958.check-completeness-of-a-binary-tree\CheckCompletenessOfABinaryTree.java

import java.util.ArrayList;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1342 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0958.check-completeness-of-a-binary-tree\CheckCompletenessOfABinaryTree.java

class CheckCompletenessOfABinaryTree {
    public boolean isCompleteTree(TreeNode root) {
        List<ANode> nodes = new ArrayList<>();
        nodes.add(new ANode(root, 1));
        int i = 0;
        while (i < nodes.size()) {
            ANode anode = nodes.get(i++);
            if (anode.node != null) {
                nodes.add(new ANode(anode.node.left, anode.code * 2));
                nodes.add(new ANode(anode.node.right, anode.code * 2 + 1));
            }
        }

        return nodes.get(i - 1).code == nodes.size();
    }
}

class ANode {
    TreeNode node;
    int code;

    ANode(TreeNode node, int code) {
        this.node = node;
        this.code = code;
    }
}

=== Chunk 1343 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0958.check-completeness-of-a-binary-tree\CheckCompletenessOfABinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1344 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0958.check-completeness-of-a-binary-tree\CheckCompletenessOfABinaryTreeTest.java

public class CheckCompletenessOfABinaryTreeTest {
    CheckCompletenessOfABinaryTree checkCompletenessOfABinaryTree = new CheckCompletenessOfABinaryTree();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);

        Assertions.assertTrue(checkCompletenessOfABinaryTree.isCompleteTree(root));
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);

=== Chunk 1345 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0958.check-completeness-of-a-binary-tree\CheckCompletenessOfABinaryTreeTest.java

root.left.right = new TreeNode(5);
        root.right.right = new TreeNode(7);

        Assertions.assertFalse(checkCompletenessOfABinaryTree.isCompleteTree(root));
    }
}

=== Chunk 1346 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0967.numbers-with-same-consecutive-differences\NumbersWithSameConsecutiveDifferences.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 1347 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0967.numbers-with-same-consecutive-differences\NumbersWithSameConsecutiveDifferences.java

class NumbersWithSameConsecutiveDifferences {
    private void DFS(int n, int num, int k, List<Integer> results) {
        if (n == 0) {
            results.add(num);
            return;
        }
        List<Integer> nextDigits = new ArrayList<>();
        int tailDigit = num % 10;
        nextDigits.add(tailDigit + k);
        if (k != 0) nextDigits.add(tailDigit - k);
        for (Integer nextDigit : nextDigits) {
            if (nextDigit >= 0 && nextDigit < 10) {
                int newNum = num * 10 + nextDigit;
                DFS(n - 1, newNum, k, results);
            }
        }
    }

    public int[] numsSameConsecDiff(int n, int k) {
        if (n == 1) return new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        List<Integer> res = new ArrayList<>();

=== Chunk 1348 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0967.numbers-with-same-consecutive-differences\NumbersWithSameConsecutiveDifferences.java

List<Integer> res = new ArrayList<>();
        for (int num = 1; num < 10; num++) {
            DFS(n - 1, num, k, res);
        }

        return res.stream().mapToInt(i->i).toArray();
    }
}

=== Chunk 1349 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0967.numbers-with-same-consecutive-differences\NumbersWithSameConsecutiveDifferencesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1350 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0967.numbers-with-same-consecutive-differences\NumbersWithSameConsecutiveDifferencesTest.java

public class NumbersWithSameConsecutiveDifferencesTest {
    NumbersWithSameConsecutiveDifferences NumbersWithSameConsecutiveDifferences = new NumbersWithSameConsecutiveDifferences();

    @Test
    void Example1() {
        int n = 3, k = 7;
        int[] results = NumbersWithSameConsecutiveDifferences.numsSameConsecDiff(n, k);
        int[] expectedResults = {181, 292, 707, 818, 929};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 2, k = 1;
        int[] results = NumbersWithSameConsecutiveDifferences.numsSameConsecDiff(n, k);
        int[] expectedResults = {12, 10, 23, 21, 34, 32, 45, 43, 56, 54, 67, 65, 78, 76, 89, 87, 98};

        Assertions.assertArrayEquals(expectedResults, results);

=== Chunk 1351 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0967.numbers-with-same-consecutive-differences\NumbersWithSameConsecutiveDifferencesTest.java

}
}

=== Chunk 1352 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0974.subarray-sums-divisible-by-k\SubarraySumsDivisibleByK.java

import java.util.HashMap;
import java.util.Map;

class SubarraySumsDivisibleByK {
    public int subarraysDivByK(int[] nums, int k) {
        Map<Integer, Integer> counter = new HashMap<>();
        counter.put(0, 1);

        int prefixSum = 0, ans = 0;
        for (int i = 0; i < nums.length; i++) {
            prefixSum += nums[i];
            int remainder = (prefixSum % k + k) % k;
            int getCount = counter.getOrDefault(remainder, 0);
            ans += getCount;
            counter.put(remainder, getCount + 1);
        }
        return ans;
    }
}

=== Chunk 1353 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0974.subarray-sums-divisible-by-k\SubarraySumsDivisibleByKTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SubarraySumsDivisibleByKTest {
    SubarraySumsDivisibleByK subarraySumsDivisibleByK = new SubarraySumsDivisibleByK();

    @Test
    void Example1() {
        int[] nums = {4, 5, 0, -2, -3, 1};
        int k = 5;

        Assertions.assertEquals(7, subarraySumsDivisibleByK.subarraysDivByK(nums, k));
    }

    @Test
    void Example2() {
        int[] nums = {5};
        int k = 9;

        Assertions.assertEquals(0, subarraySumsDivisibleByK.subarraysDivByK(nums, k));
    }
}

=== Chunk 1354 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0976.largest-perimeter-triangle\LargestPerimeterTriangle.java

import java.util.Arrays;

class LargestPerimeterTriangle {
    public int largestPerimeter(int[] nums) {
        Arrays.sort(nums);
        for (int i = nums.length - 3; i >= 0; i--) {
            if (nums[i] + nums[i + 1] > nums[i + 2])
                return nums[i] + nums[i + 1] + nums[i + 2];
        }
        return 0;
    }
}

=== Chunk 1355 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0976.largest-perimeter-triangle\LargestPerimeterTriangleTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class LargestPerimeterTriangleTest {
    LargestPerimeterTriangle LargestPerimeterTriangle = new LargestPerimeterTriangle();

    @Test
    void Example1() {
        int[] nums = {2, 1, 2};
        int results = LargestPerimeterTriangle.largestPerimeter(nums);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 2, 1};
        int results = LargestPerimeterTriangle.largestPerimeter(nums);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1356 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0977.squares-of-a-sorted-array\SquaresOfASortedArray.java

import java.util.Arrays;

class SquaresOfASortedArray {
    public int[] sortedSquares(int[] nums) {
        int[] squares = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            squares[i] = nums[i] * nums[i];
        }
        Arrays.sort(squares);
        return squares;
    }
}

=== Chunk 1357 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0977.squares-of-a-sorted-array\SquaresOfASortedArray2.java

import java.util.Arrays;

class SquaresOfASortedArray2 {
    public int[] sortedSquares(int[] nums) {
        int l = 0, r = nums.length - 1, i = r;
        int[] squares = new int[nums.length];
        while (i >= 0) {
            int leftNum = Math.abs(nums[l]);
            int rightNum = Math.abs(nums[r]);
            if (leftNum > rightNum) {
                squares[i] = leftNum * leftNum;
                l++;
            } else {
                squares[i] = rightNum * rightNum;
                r--;
            }
            i--;
        }
        return squares;
    }
}

=== Chunk 1358 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0977.squares-of-a-sorted-array\SquaresOfASortedArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1359 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0977.squares-of-a-sorted-array\SquaresOfASortedArrayTest.java

public class SquaresOfASortedArrayTest {
    SquaresOfASortedArray SquaresOfASortedArray = new SquaresOfASortedArray();
    SquaresOfASortedArray2 SquaresOfASortedArray2 = new SquaresOfASortedArray2();

    @Test
    void Example1() {
        int[] nums = {-4, -1, 0, 3, 10};
        int[] results = SquaresOfASortedArray.sortedSquares(nums);
        int[] expectedResults = {0, 1, 9, 16, 100};

        Assertions.assertArrayEquals(expectedResults, results);

        results = SquaresOfASortedArray2.sortedSquares(nums);
        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {-7, -3, 2, 3, 11};
        int[] results = SquaresOfASortedArray.sortedSquares(nums);

=== Chunk 1360 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0977.squares-of-a-sorted-array\SquaresOfASortedArrayTest.java

int[] expectedResults = {4, 9, 9, 49, 121};

        Assertions.assertArrayEquals(expectedResults, results);

        results = SquaresOfASortedArray2.sortedSquares(nums);
        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 1361 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0980.unique-paths-iii\UniquePathsIii.java

class UniquePathsIii {
    int ans = 0;
    int[] start;
    int totalSteps = 0;

    public int uniquePathsIII(int[][] grid) {
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1)
                    start = new int[]{i, j};
                else
                    if (grid[i][j] != -1)
                        totalSteps++;
            }
        }
        findPath(start[0], start[1], 0, grid);
        return ans;
    }

    private void findPath(int i, int j, int step, int[][] grid) {
        if (i < 0 || j < 0 || i == grid.length || j == grid[0].length || grid[i][j] == -1)
            return;
        if (grid[i][j] == 2) {
            if (totalSteps == step)

=== Chunk 1362 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0980.unique-paths-iii\UniquePathsIii.java

if (totalSteps == step)
                ans++;
        } else {
            int g = grid[i][j];
            grid[i][j] = -1;
            findPath(i + 1, j, step + 1, grid);
            findPath(i - 1, j, step + 1, grid);
            findPath(i, j + 1, step + 1, grid);
            findPath(i, j - 1, step + 1, grid);
            grid[i][j] = g;
        }
    }
}

=== Chunk 1363 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0980.unique-paths-iii\UniquePathsIiiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class UniquePathsIiiTest {
    UniquePathsIii uniquePathsIii = new UniquePathsIii();

    @Test
    void Example1() {
        int[][] grid = {{1, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 2, -1}};

        Assertions.assertEquals(2, uniquePathsIii.uniquePathsIII(grid));
    }

    @Test
    void Example2() {
        int[][] grid = {{1, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 2}};

        Assertions.assertEquals(4, uniquePathsIii.uniquePathsIII(grid));
    }

    @Test
    void Example3() {
        int[][] grid = {{0, 1}, {2, 0}};

        Assertions.assertEquals(0, uniquePathsIii.uniquePathsIII(grid));
    }
}

=== Chunk 1364 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0981.time-based-key-value-store\TimeBasedKeyValueStore.java

import java.util.HashMap;

=== Chunk 1365 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0981.time-based-key-value-store\TimeBasedKeyValueStore.java

class TimeMap {
    private final HashMap<String, HashMap<Integer, String>> keyTimeMap;

    public TimeMap() {
        keyTimeMap = new HashMap<>();
    }
    
    public void set(String key, String value, int timestamp) {
        if (!keyTimeMap.containsKey(key)) {
            keyTimeMap.put(key, new HashMap<>());
        }
        keyTimeMap.get(key).put(timestamp, value);
    }
    
    public String get(String key, int timestamp) {
        if (!keyTimeMap.containsKey(key)) {
            return "";
        }

        for (int currTime = timestamp; currTime >= 1; currTime--) {
            if (keyTimeMap.get(key).containsKey(currTime)) {
                return keyTimeMap.get(key).get(currTime);
            }
        }

        return "";
    }
}

/**

=== Chunk 1366 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0981.time-based-key-value-store\TimeBasedKeyValueStore.java

}

        return "";
    }
}

/**
 * Your TimeMap object will be instantiated and called as such:
 * TimeMap obj = new TimeMap();
 * obj.set(key,value,timestamp);
 * String param_2 = obj.get(key,timestamp);
 */

=== Chunk 1367 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0981.time-based-key-value-store\TimeBasedKeyValueStoreTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class TimeBasedKeyValueStoreTest {
    @Test
    void Example1() {
        TimeMap timeMap = new TimeMap();
        timeMap.set("foo", "bar", 1);
        Assertions.assertEquals("bar", timeMap.get("foo", 1));
        Assertions.assertEquals("bar", timeMap.get("foo", 3));
        timeMap.set("foo", "bar2", 4);
        Assertions.assertEquals("bar2", timeMap.get("foo", 4));
        Assertions.assertEquals("bar2", timeMap.get("foo", 5));
    }
}

=== Chunk 1368 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0983.minimum-cost-for-tickets\MinimumCostForTickets.java

import java.util.HashSet;
import java.util.Set;

class MinimumCostForTickets {
    int[] costs;
    Integer[] memo;
    Set<Integer> set;

    public int mincostTickets(int[] days, int[] costs) {
        this.costs = costs;
        memo = new Integer[366];
        set = new HashSet<>();
        for (int day : days) {
            set.add(day);
        }
        return dp(1);
    }

    private int dp(int i) {
        if (i > 365) {
            return 0;
        }
        if (memo[i] != null) {
            return memo[i];
        }
        if (set.contains(i)) {
            memo[i] = Math.min(Math.min(dp(i + 1) + costs[0], dp(i + 7) + costs[1]), dp(i + 30) + costs[2]);
        } else {
            memo[i] = dp(i + 1);
        }
        return memo[i];
    }
}

=== Chunk 1369 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0983.minimum-cost-for-tickets\MinimumCostForTicketsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MinimumCostForTicketsTest {
    MinimumCostForTickets minimumCostForTickets = new MinimumCostForTickets();

    @Test
    void Example1() {
        int[] days = {1, 4, 6, 7, 8, 20}, costs = {2, 7, 15};

        Assertions.assertEquals(11, minimumCostForTickets.mincostTickets(days, costs));
    }

    @Test
    void Example2() {
        int[] days = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31}, costs = {2, 7, 15};

        Assertions.assertEquals(17, minimumCostForTickets.mincostTickets(days, costs));
    }
}

=== Chunk 1370 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0985.sum-of-even-numbers-after-queries\SumOfEvenNumbersAfterQueries.java

class SumOfEvenNumbersAfterQueries {
    public int[] sumEvenAfterQueries(int[] nums, int[][] queries) {
        int sum = 0;
        for (int num : nums) {
            if (num % 2 == 0) sum += num;
        }

        int[] res = new int[nums.length];

        for (int i = 0; i < queries.length; i++) {
            int val = queries[i][0];
            int index = queries[i][1];
            if (nums[index] % 2 == 0) sum -= nums[index];
            nums[index] += val;
            if (nums[index] % 2 == 0) sum += nums[index];
            res[i] = sum;
        }
        return res;
    }
}

=== Chunk 1371 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0985.sum-of-even-numbers-after-queries\SumOfEvenNumbersAfterQueriesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1372 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0985.sum-of-even-numbers-after-queries\SumOfEvenNumbersAfterQueriesTest.java

public class SumOfEvenNumbersAfterQueriesTest {
    SumOfEvenNumbersAfterQueries SumOfEvenNumbersAfterQueries = new SumOfEvenNumbersAfterQueries();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3, 4};
        int[][] queries = {{1, 0}, {-3, 1}, {-4, 0}, {2, 3}};
        int[] results = SumOfEvenNumbersAfterQueries.sumEvenAfterQueries(nums, queries);
        int[] expectedResults = {8, 6, 2, 4};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1};
        int[][] queries = {{4, 0}};
        int[] results = SumOfEvenNumbersAfterQueries.sumEvenAfterQueries(nums, queries);
        int[] expectedResults = {0};

        Assertions.assertArrayEquals(expectedResults, results);
    }

=== Chunk 1373 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0985.sum-of-even-numbers-after-queries\SumOfEvenNumbersAfterQueriesTest.java

}
}

=== Chunk 1374 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0986.interval-list-intersections\IntervalListIntersections.java

import java.util.ArrayList;
import java.util.List;

class IntervalListIntersections {
    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
        if (firstList.length == 0 || secondList.length == 0) return new int[][]{};
        List<int[]> res = new ArrayList<>();
        int i = 0, j = 0;
        while (i < firstList.length && j < secondList.length) {
            int low = Math.max(firstList[i][0], secondList[j][0]);
            int high = Math.min(firstList[i][1], secondList[j][1]);
            if (low <= high) res.add(new int[]{low, high});
            if (firstList[i][1] < secondList[j][1]) i++;
            else j++;
        }
        return res.toArray(new int[res.size()][]);
    }
}

=== Chunk 1375 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0986.interval-list-intersections\IntervalListIntersectionsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1376 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0986.interval-list-intersections\IntervalListIntersectionsTest.java

public class IntervalListIntersectionsTest {
    IntervalListIntersections IntervalListIntersections = new IntervalListIntersections();

    @Test
    void Example1() {
        int[][] firstList = {{0, 2}, {5, 10}, {13, 23}, {24, 25}},  secondList = {{1, 5}, {8, 12}, {15, 24}, {25, 26}};
        int[][] results = IntervalListIntersections.intervalIntersection(firstList, secondList);
        int[][] expectedResults = {{1, 2}, {5, 5}, {8, 10}, {15, 23}, {24, 24}, {25, 25}};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] firstList = {{1, 3}, {5, 9}},  secondList = {};
        int[][] results = IntervalListIntersections.intervalIntersection(firstList, secondList);
        int[][] expectedResults = {};

=== Chunk 1377 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0986.interval-list-intersections\IntervalListIntersectionsTest.java

int[][] expectedResults = {};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 1378 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0987.vertical-order-traversal-of-a-binary-tree\VerticalOrderTraversalOfABinaryTree.java

import java.util.*;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1379 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0987.vertical-order-traversal-of-a-binary-tree\VerticalOrderTraversalOfABinaryTree.java

class VerticalOrderTraversalOfABinaryTree {
    Map<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map;

    private void dfs(TreeNode root, int index, int level) {
        if (root == null) return;
        map.putIfAbsent(index, new TreeMap<>());
        map.get(index).putIfAbsent(level, new PriorityQueue<>());
        map.get(index).get(level).add(root.val);
        dfs(root.left, index - 1, level + 1);
        dfs(root.right, index + 1, level + 1);
    }

    public List<List<Integer>> verticalTraversal(TreeNode root) {
        if (root == null) return null;
        map = new TreeMap<>();
        dfs(root, 0, 0);
        List<List<Integer>> res = new LinkedList<>();
        for (int key : map.keySet()) {
            List<Integer> list = new LinkedList<>();

=== Chunk 1380 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0987.vertical-order-traversal-of-a-binary-tree\VerticalOrderTraversalOfABinaryTree.java

TreeMap<Integer, PriorityQueue<Integer>> tm = map.get(key);
            for (int k : tm.keySet()) {
                PriorityQueue<Integer> pq = tm.get(k);
                while (!pq.isEmpty()) list.add(pq.poll());
            }
            res.add(list);
        }
        return res;
    }
}

=== Chunk 1381 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0987.vertical-order-traversal-of-a-binary-tree\VerticalOrderTraversalOfABinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 1382 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0987.vertical-order-traversal-of-a-binary-tree\VerticalOrderTraversalOfABinaryTreeTest.java

public class VerticalOrderTraversalOfABinaryTreeTest {
    VerticalOrderTraversalOfABinaryTree VerticalOrderTraversalOfABinaryTree = new VerticalOrderTraversalOfABinaryTree();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(3);
        root.left= new TreeNode(9);
        root.right = new TreeNode(20);
        root.right.left = new TreeNode(15);
        root.right.right = new TreeNode(7);
        List<List<Integer>> results = VerticalOrderTraversalOfABinaryTree.verticalTraversal(root);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(List.of(9));
        expectedResults.add(Arrays.asList(3, 15));
        expectedResults.add(List.of(20));
        expectedResults.add(List.of(7));

=== Chunk 1383 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0987.vertical-order-traversal-of-a-binary-tree\VerticalOrderTraversalOfABinaryTreeTest.java

expectedResults.add(List.of(7));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(1);
        root.left= new TreeNode(2);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right = new TreeNode(3);
        root.right.left = new TreeNode(6);
        root.right.right = new TreeNode(7);
        List<List<Integer>> results = VerticalOrderTraversalOfABinaryTree.verticalTraversal(root);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(List.of(4));
        expectedResults.add(List.of(2));
        expectedResults.add(Arrays.asList(1, 5, 6));
        expectedResults.add(List.of(3));

=== Chunk 1384 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0987.vertical-order-traversal-of-a-binary-tree\VerticalOrderTraversalOfABinaryTreeTest.java

expectedResults.add(List.of(3));
        expectedResults.add(List.of(7));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        TreeNode root = new TreeNode(1);
        root.left= new TreeNode(2);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(6);
        root.right = new TreeNode(3);
        root.right.left = new TreeNode(5);
        root.right.right = new TreeNode(7);
        List<List<Integer>> results = VerticalOrderTraversalOfABinaryTree.verticalTraversal(root);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(List.of(4));
        expectedResults.add(List.of(2));
        expectedResults.add(Arrays.asList(1, 5, 6));

=== Chunk 1385 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0987.vertical-order-traversal-of-a-binary-tree\VerticalOrderTraversalOfABinaryTreeTest.java

expectedResults.add(List.of(3));
        expectedResults.add(List.of(7));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        TreeNode root = new TreeNode(3);
        root.left= new TreeNode(1);
        root.left.left = new TreeNode(0);
        root.left.right = new TreeNode(2);
        root.right = new TreeNode(4);
        root.right.left = new TreeNode(2);
        List<List<Integer>> results = VerticalOrderTraversalOfABinaryTree.verticalTraversal(root);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(List.of(0));
        expectedResults.add(List.of(1));
        expectedResults.add(Arrays.asList(3, 2, 2));
        expectedResults.add(List.of(4));

=== Chunk 1386 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0987.vertical-order-traversal-of-a-binary-tree\VerticalOrderTraversalOfABinaryTreeTest.java

expectedResults.add(List.of(4));

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1387 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0989.add-to-array-form-of-integer\AddToArrayFormOfInteger.java

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class AddToArrayFormOfInteger {
    public List<Integer> addToArrayForm(int[] num, int k) {
        List<Integer> ans = new ArrayList<>();
        for (int i = num.length - 1; i >= 0 || k > 0; i--, k /= 10) {
            if (i >= 0)
                k += num[i];
            ans.add(k % 10);
        }
        Collections.reverse(ans);
        return ans;
    }
}

=== Chunk 1388 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0989.add-to-array-form-of-integer\AddToArrayFormOfIntegerTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;

=== Chunk 1389 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0989.add-to-array-form-of-integer\AddToArrayFormOfIntegerTest.java

public class AddToArrayFormOfIntegerTest {
    AddToArrayFormOfInteger addToArrayFormOfInteger = new AddToArrayFormOfInteger();

    @Test
    void Example1() {
        int[] num = {1, 2, 0, 0};
        int k = 34;

        Assertions.assertEquals(Arrays.asList(1, 2, 3, 4), addToArrayFormOfInteger.addToArrayForm(num, k));
    }

    @Test
    void Example2() {
        int[] num = {2, 7, 4};
        int k = 181;

        Assertions.assertEquals(Arrays.asList(4, 5, 5), addToArrayFormOfInteger.addToArrayForm(num, k));
    }

    @Test
    void Example3() {
        int[] num = {2, 1, 5};
        int k = 806;

        Assertions.assertEquals(Arrays.asList(1, 0, 2, 1), addToArrayFormOfInteger.addToArrayForm(num, k));
    }

    @Test
    void Example4() {

=== Chunk 1390 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0989.add-to-array-form-of-integer\AddToArrayFormOfIntegerTest.java

}

    @Test
    void Example4() {
        int[] num = {9, 9, 9, 9, 9, 9, 9, 9, 9, 9};
        int k = 1;

        Assertions.assertEquals(Arrays.asList(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), addToArrayFormOfInteger.addToArrayForm(num, k));
    }

    @Test
    void Example5() {
        int[] num = {1, 2, 6, 3, 0, 7, 1, 7, 1, 9, 7, 5, 6, 6, 4, 4, 0, 0, 6, 3};
        int k = 1;

        Assertions.assertEquals(Arrays.asList(1, 2, 6, 3, 0, 7, 1, 7, 1, 9, 7, 5, 6, 6, 4, 4, 0, 5, 7, 9), addToArrayFormOfInteger.addToArrayForm(num, k));
    }
}

=== Chunk 1391 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0990.satisfiability-of-equality-equations\SatisfiabilityOfEqualityEquations.java

class SatisfiabilityOfEqualityEquations {
    int[] parent = new int[26];

    private int find(int x) {
        if (parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    }

    public boolean equationsPossible(String[] equations) {
        for (int i = 0; i < 26; i++) parent[i] = i;
        for (String e : equations) {
            if (e.charAt(1) == '=') {
                parent[find(e.charAt(0)- 'a')] = find(e.charAt(3) - 'a');
            }
        }
        for (String e : equations) {
            if (e.charAt(1) == '!' && find(e.charAt(0) - 'a') == find(e.charAt(3) - 'a')) {
                return false;
            }
        }
        return true;
    }
}

=== Chunk 1392 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0990.satisfiability-of-equality-equations\SatisfiabilityOfEqualityEquationsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1393 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0990.satisfiability-of-equality-equations\SatisfiabilityOfEqualityEquationsTest.java

public class SatisfiabilityOfEqualityEquationsTest {
    SatisfiabilityOfEqualityEquations SatisfiabilityOfEqualityEquations = new SatisfiabilityOfEqualityEquations();

    @Test
    void Example1() {
        String[] equations = {"a==b", "b!=a"};
        boolean results = SatisfiabilityOfEqualityEquations.equationsPossible(equations);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String[] equations = {"b==a", "a==b"};
        boolean results = SatisfiabilityOfEqualityEquations.equationsPossible(equations);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 1394 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0990.satisfiability-of-equality-equations\SatisfiabilityOfEqualityEquationsTest.java

}

    @Test
    void Example3() {
        String[] equations = {"c==c", "b==d", "x!=z"};
        boolean results = SatisfiabilityOfEqualityEquations.equationsPossible(equations);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1395 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0994.rotting-oranges\RottingOranges.java

class RottingOranges {
    private void rotAdjacent(int[][] grid, int i, int j, int minutes) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0 || (1 < grid[i][j] && grid[i][j] < minutes)) return;
        else {
            grid[i][j] = minutes;
            rotAdjacent(grid, i - 1, j, minutes + 1);
            rotAdjacent(grid, i + 1, j, minutes + 1);
            rotAdjacent(grid, i, j - 1, minutes + 1);
            rotAdjacent(grid, i, j + 1, minutes + 1);
        }
    }

    public int orangesRotting(int[][] grid) {
        if (grid == null || grid.length == 0) return -1;

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {

=== Chunk 1396 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0994.rotting-oranges\RottingOranges.java

if (grid[i][j] == 2) rotAdjacent(grid, i, j, 2);
            }
        }

        int minutes = 2;
        for (int[] row : grid) {
            for (int cell : row) {
                if (cell == 1) return -1;
                minutes = Math.max(minutes, cell);
            }
        }

        return minutes - 2;
    }
}

=== Chunk 1397 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0994.rotting-oranges\RottingOrangesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1398 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0994.rotting-oranges\RottingOrangesTest.java

public class RottingOrangesTest {
    RottingOranges RottingOranges = new RottingOranges();

    @Test
    void Example1() {
        int[][] grid = {{2, 1, 1}, {1, 1, 0}, {0, 1, 1}};
        int results = RottingOranges.orangesRotting(grid);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] grid = {{2, 1, 1}, {0, 1, 1}, {1, 0, 1}};
        int results = RottingOranges.orangesRotting(grid);
        int expectedResults = -1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[][] grid = {{0, 2}};
        int results = RottingOranges.orangesRotting(grid);
        int expectedResults = 0;

=== Chunk 1399 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0994.rotting-oranges\RottingOrangesTest.java

int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1400 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0997.find-the-town-judge\FindTheTownJudge.java

class FindTheTownJudge {
    public int findJudge(int n, int[][] trust) {
        int[] isTrusted = new int[n + 1];
        int[] trustOthers = new int[n + 1];
        for (int[] edge : trust) {
            trustOthers[edge[0]]++;
            isTrusted[edge[1]]++;
        }
        for (int i = 1; i <= n; i++) {
            if (isTrusted[i] == n - 1 && trustOthers[i] == 0)
                return i;
        }
        return -1;
    }
}

=== Chunk 1401 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\0997.find-the-town-judge\FindTheTownJudgeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class FindTheTownJudgeTest {
    FindTheTownJudge findTheTownJudge = new FindTheTownJudge();

    @Test
    void Example1() {
        int n = 2;
        int[][] trust = {{1 ,2}};

        Assertions.assertEquals(2, findTheTownJudge.findJudge(n, trust));
    }

    @Test
    void Example2() {
        int n = 3;
        int[][] trust = {{1 ,3}, {2, 3}};

        Assertions.assertEquals(3, findTheTownJudge.findJudge(n, trust));
    }

    @Test
    void Example3() {
        int n = 3;
        int[][] trust = {{1 ,3}, {2, 3}, {3, 1}};

        Assertions.assertEquals(-1, findTheTownJudge.findJudge(n, trust));
    }
}

=== Chunk 1402 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1011.capacity-to-ship-packages-within-d-days\CapacityToShipPackagesWithinDDays.java

import java.util.Arrays;

class CapacityToShipPackagesWithinDDays {
    public int shipWithinDays(int[] weights, int days) {
        int left = Arrays.stream(weights).max().getAsInt();
        int right = Arrays.stream(weights).sum();
        while (left < right) {
            int mid = (left + right) / 2;
            int need = 1, curr = 0;
            for (int weight : weights) {
                if (curr + weight > mid) {
                    need++;
                    curr = 0;
                }
                curr += weight;
            }
            if (need <= days) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}

=== Chunk 1403 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1011.capacity-to-ship-packages-within-d-days\CapacityToShipPackagesWithinDDaysTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1404 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1011.capacity-to-ship-packages-within-d-days\CapacityToShipPackagesWithinDDaysTest.java

public class CapacityToShipPackagesWithinDDaysTest {
    CapacityToShipPackagesWithinDDays capacityToShipPackagesWithinDDays = new CapacityToShipPackagesWithinDDays();

    @Test
    void Example1() {
        int[] weights = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int days = 5;

        Assertions.assertEquals(15, capacityToShipPackagesWithinDDays.shipWithinDays(weights, days));
    }

    @Test
    void Example2() {
        int[] weights = {3, 2, 2, 4, 1, 4};
        int days = 3;

        Assertions.assertEquals(6, capacityToShipPackagesWithinDDays.shipWithinDays(weights, days));
    }

    @Test
    void Example3() {
        int[] weights = {1, 2, 3, 1, 1};
        int days = 4;

=== Chunk 1405 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1011.capacity-to-ship-packages-within-d-days\CapacityToShipPackagesWithinDDaysTest.java

int days = 4;

        Assertions.assertEquals(3, capacityToShipPackagesWithinDDays.shipWithinDays(weights, days));
    }
}

=== Chunk 1406 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1026.maximum-difference-between-node-and-ancestor\MaximumDifferenceBetweenNodeAndAncestor.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1407 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1026.maximum-difference-between-node-and-ancestor\MaximumDifferenceBetweenNodeAndAncestor.java

class MaximumDifferenceBetweenNodeAndAncestor {
    private int result = 0;

    public int maxAncestorDiff(TreeNode root) {
        if (root == null) return 0;
        dfs(root, root.val, root.val);
        return result;
    }

    private void dfs(TreeNode root, int currMax, int currMin) {
        if (root == null) return;
        int possibleResult = Math.max(Math.abs(currMax - root.val), Math.abs(root.val - currMin));
        result = Math.max(result, possibleResult);
        currMax = Math.max(currMax, root.val);
        currMin = Math.min(currMin, root.val);
        dfs(root.left, currMax, currMin);
        dfs(root.right, currMax, currMin);
    }
}

=== Chunk 1408 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1026.maximum-difference-between-node-and-ancestor\MaximumDifferenceBetweenNodeAndAncestor2.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1409 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1026.maximum-difference-between-node-and-ancestor\MaximumDifferenceBetweenNodeAndAncestor2.java

class MaximumDifferenceBetweenNodeAndAncestor2 {
    public int maxAncestorDiff(TreeNode root) {
        if (root == null) return 0;
        return dfs(root, root.val, root.val);
    }

    private int dfs(TreeNode root, int currMax, int currMin) {
        if (root == null) return currMax - currMin;
        currMax = Math.max(currMax, root.val);
        currMin = Math.min(currMin, root.val);
        int left = dfs(root.left, currMax, currMin);
        int right = dfs(root.right, currMax, currMin);
        return Math.max(left, right);
    }
}

=== Chunk 1410 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1026.maximum-difference-between-node-and-ancestor\MaximumDifferenceBetweenNodeAndAncestorTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1411 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1026.maximum-difference-between-node-and-ancestor\MaximumDifferenceBetweenNodeAndAncestorTest.java

public class MaximumDifferenceBetweenNodeAndAncestorTest {
    MaximumDifferenceBetweenNodeAndAncestor maximumDifferenceBetweenNodeAndAncestor = new MaximumDifferenceBetweenNodeAndAncestor();
    MaximumDifferenceBetweenNodeAndAncestor2 maximumDifferenceBetweenNodeAndAncestor2 = new MaximumDifferenceBetweenNodeAndAncestor2();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(8);
        root.left = new TreeNode(3);
        root.left.left = new TreeNode(1);
        root.left.right = new TreeNode(6);
        root.left.right.left = new TreeNode(4);
        root.left.right.right = new TreeNode(7);
        root.right = new TreeNode(10);
        root.right.right = new TreeNode(14);
        root.right.right.left = new TreeNode(13);

=== Chunk 1412 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1026.maximum-difference-between-node-and-ancestor\MaximumDifferenceBetweenNodeAndAncestorTest.java

Assertions.assertEquals(7, maximumDifferenceBetweenNodeAndAncestor.maxAncestorDiff(root));
        Assertions.assertEquals(7, maximumDifferenceBetweenNodeAndAncestor2.maxAncestorDiff(root));
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(1);
        root.right = new TreeNode(2);
        root.right.right = new TreeNode(0);
        root.right.right.left = new TreeNode(3);

        Assertions.assertEquals(3, maximumDifferenceBetweenNodeAndAncestor.maxAncestorDiff(root));
        Assertions.assertEquals(3, maximumDifferenceBetweenNodeAndAncestor2.maxAncestorDiff(root));
    }
}

=== Chunk 1413 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1035.uncrossed-lines\UncrossedLines.java

class UncrossedLines {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int n = nums1.length, m = nums2.length;
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i++) {
            int num1 = nums1[i - 1];
            for (int j = 1; j <= m; j++) {
                int num2 = nums2[j - 1];
                if (num1 == num2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[n][m];
    }
}

=== Chunk 1414 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1035.uncrossed-lines\UncrossedLinesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class UncrossedLinesTest {
    UncrossedLines uncrossedLines = new UncrossedLines();

    @Test
    void Example1() {
        int[] nums1 = {1, 4, 2}, nums2 = {1, 2, 4};

        Assertions.assertEquals(2, uncrossedLines.maxUncrossedLines(nums1, nums2));
    }

    @Test
    void Example2() {
        int[] nums1 = {2, 5, 1, 2, 5}, nums2 = {10, 5, 2, 1, 5, 2};

        Assertions.assertEquals(3, uncrossedLines.maxUncrossedLines(nums1, nums2));
    }

    @Test
    void Example3() {
        int[] nums1 = {1, 3, 7, 1, 7, 5}, nums2 = {1, 9, 2, 5, 1};

        Assertions.assertEquals(2, uncrossedLines.maxUncrossedLines(nums1, nums2));
    }
}

=== Chunk 1415 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1046.last-stone-weight\LastStoneWeight.java

import java.util.Collections;
import java.util.PriorityQueue;

class LastStoneWeight {
    public int lastStoneWeight(int[] stones) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(stones.length, Collections.reverseOrder());
        for (int stone : stones) {
            pq.add(stone);
        }
        while (!pq.isEmpty() && pq.size() != 1) {
            int first = pq.poll();
            int second = pq.size() >= 1 ? pq.poll() : 0;
            if (first != second) pq.add(first - second);
        }
        return pq.size() == 0 ? 0 : pq.poll();
    }
}

=== Chunk 1416 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1046.last-stone-weight\LastStoneWeightTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class LastStoneWeightTest {
    LastStoneWeight LastStoneWeight = new LastStoneWeight();

    @Test
    void Example1() {
        int[] stones = {2, 7, 4, 1, 8, 1};
        int results = LastStoneWeight.lastStoneWeight(stones);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] stones = {1};
        int results = LastStoneWeight.lastStoneWeight(stones);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1417 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1047.remove-all-adjacent-duplicates-in-string\RemoveAllAdjacentDuplicatesInString.java

import java.util.Stack;

class RemoveAllAdjacentDuplicatesInString {
    public String removeDuplicates(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (!stack.isEmpty() && stack.peek() == c) {
                stack.pop();
            } else {
                stack.push(c);
            }
        }
        StringBuilder res = new StringBuilder();
        for (char c : stack)
            res.append(c);
        return res.toString();
    }
}

=== Chunk 1418 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1047.remove-all-adjacent-duplicates-in-string\RemoveAllAdjacentDuplicatesInStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class RemoveAllAdjacentDuplicatesInStringTest {
    RemoveAllAdjacentDuplicatesInString RemoveAllAdjacentDuplicatesInString = new RemoveAllAdjacentDuplicatesInString();

    @Test
    void Example1() {
        String s = "abbaca";
        String results = RemoveAllAdjacentDuplicatesInString.removeDuplicates(s);
        String expectedResults = "ca";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "azxxzy";
        String results = RemoveAllAdjacentDuplicatesInString.removeDuplicates(s);
        String expectedResults = "ay";

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1419 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1061.lexicographically-smallest-equivalent-string\LexicographicallySmallestEquivalentString.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 1420 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1061.lexicographically-smallest-equivalent-string\LexicographicallySmallestEquivalentString.java

class LexicographicallySmallestEquivalentString {
    int minChar;

    public String smallestEquivalentString(String s1, String s2, String baseStr) {
        int[][] adjMatrix = new int[26][26];
        for (int i = 0; i < s1.length(); i++) {
            adjMatrix[s1.charAt(i) - 'a'][s2.charAt(i) - 'a'] = 1;
            adjMatrix[s2.charAt(i) - 'a'][s1.charAt(i) - 'a'] = 1;
        }

        int[] mappingChar = new int[26];
        for (int i = 0; i < 26; i++)
            mappingChar[i] = i;

        boolean[] visited = new boolean[26];
        for (int c = 0; c < 26; c++) {
            if (!visited[c]) {
                List<Integer> component = new ArrayList<>();
                minChar = 27;
                dfs(c, adjMatrix, visited, component);

=== Chunk 1421 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1061.lexicographically-smallest-equivalent-string\LexicographicallySmallestEquivalentString.java

for (int vertex : component)
                    mappingChar[vertex] = minChar;
            }
        }

        StringBuilder ans = new StringBuilder();
        for (char c : baseStr.toCharArray())
            ans.append((char) (mappingChar[c - 'a'] + 'a'));

        return ans.toString();
    }

    private void dfs(int src, int[][] adjMatrix, boolean[] visited, List<Integer> component) {
        visited[src] = true;
        component.add(src);
        minChar = Math.min(minChar, src);

        for (int i = 0; i < 26; i++) {
            if (adjMatrix[src][i] != 0 && !visited[i])
                dfs(i, adjMatrix, visited, component);
        }
    }
}

=== Chunk 1422 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1061.lexicographically-smallest-equivalent-string\LexicographicallySmallestEquivalentStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1423 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1061.lexicographically-smallest-equivalent-string\LexicographicallySmallestEquivalentStringTest.java

public class LexicographicallySmallestEquivalentStringTest {
    LexicographicallySmallestEquivalentString lexicographicallySmallestEquivalentString = new LexicographicallySmallestEquivalentString();

    @Test
    void Example1() {
        String s1 = "parker", s2 = "morris", baseStr = "parser";

        Assertions.assertEquals("makkek", lexicographicallySmallestEquivalentString.smallestEquivalentString(s1, s2, baseStr));
    }

    @Test
    void Example2() {
        String s1 = "hello", s2 = "world", baseStr = "hold";

        Assertions.assertEquals("hdld", lexicographicallySmallestEquivalentString.smallestEquivalentString(s1, s2, baseStr));
    }

    @Test
    void Example3() {
        String s1 = "leetcode", s2 = "programs", baseStr = "sourcecode";

=== Chunk 1424 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1061.lexicographically-smallest-equivalent-string\LexicographicallySmallestEquivalentStringTest.java

Assertions.assertEquals("aauaaaaada", lexicographicallySmallestEquivalentString.smallestEquivalentString(s1, s2, baseStr));
    }
}

=== Chunk 1425 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1071.greatest-common-divisor-of-strings\GreatestCommonDivisorOfStrings.java

class GreatestCommonDivisorOfStrings {
    public String gcdOfStrings(String str1, String str2) {
        int n1 = str1.length(), n2 = str2.length();
        for (int i = Math.min(n1, n2); i >= 1; i--) {
            String x = str1.substring(0, i);
            if (check(x, str1) && check(x, str2))
                return x;
        }
        return "";
    }

    private boolean check(String t, String s) {
        int n = s.length() / t.length();
        return t.repeat(n).equals(s);
    }
}

=== Chunk 1426 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1071.greatest-common-divisor-of-strings\GreatestCommonDivisorOfStrings2.java

class GreatestCommonDivisorOfStrings2 {
    public String gcdOfStrings(String str1, String str2) {
        if (!str1.concat(str2).equals(str2.concat(str1)))
            return "";
        return str1.substring(0, gcd(str1.length(), str2.length()));
    }

    private int gcd(int a, int b) {
        int remainder = a % b;
        while (remainder != 0) {
            a = b;
            b = remainder;
            remainder = a % b;
        }
        return b;
    }
}

=== Chunk 1427 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1071.greatest-common-divisor-of-strings\GreatestCommonDivisorOfStringsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1428 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1071.greatest-common-divisor-of-strings\GreatestCommonDivisorOfStringsTest.java

public class GreatestCommonDivisorOfStringsTest {
    GreatestCommonDivisorOfStrings greatestCommonDivisorOfStrings = new GreatestCommonDivisorOfStrings();
    GreatestCommonDivisorOfStrings2 greatestCommonDivisorOfStrings2 = new GreatestCommonDivisorOfStrings2();

    @Test
    void Example1() {
        String str1 = "ABCABC", str2 = "ABC";

        Assertions.assertEquals("ABC", greatestCommonDivisorOfStrings.gcdOfStrings(str1, str2));
        Assertions.assertEquals("ABC", greatestCommonDivisorOfStrings2.gcdOfStrings(str1, str2));
    }

    @Test
    void Example2() {
        String str1 = "ABABAB", str2 = "ABAB";

        Assertions.assertEquals("AB", greatestCommonDivisorOfStrings.gcdOfStrings(str1, str2));

=== Chunk 1429 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1071.greatest-common-divisor-of-strings\GreatestCommonDivisorOfStringsTest.java

Assertions.assertEquals("AB", greatestCommonDivisorOfStrings2.gcdOfStrings(str1, str2));
    }

    @Test
    void Example3() {
        String str1 = "LEET", str2 = "CODE";

        Assertions.assertEquals("", greatestCommonDivisorOfStrings.gcdOfStrings(str1, str2));
        Assertions.assertEquals("", greatestCommonDivisorOfStrings2.gcdOfStrings(str1, str2));
    }
}

=== Chunk 1430 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1074.number-of-submatrices-that-sum-to-target\NumberOfSubmatricesThatSumToTarget.java

import java.util.HashMap;
import java.util.Map;

=== Chunk 1431 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1074.number-of-submatrices-that-sum-to-target\NumberOfSubmatricesThatSumToTarget.java

class NumberOfSubmatricesThatSumToTarget {
    public int numSubmatrixSumTarget(int[][] matrix, int target) {
        int row = matrix.length, col = matrix[0].length;

        for (int i = 0; i < row; i++) {
            for (int j = 1; j < col; j++) {
                matrix[i][j] += matrix[i][j - 1];
            }
        }

        int count = 0;

        for (int c1 = 0; c1 < col; c1++) {
            for (int c2 = c1; c2 < col; c2++) {
                Map<Integer, Integer> map = new HashMap<>();
                map.put(0, 1);
                int sum = 0;

                for (int[] ints : matrix) {
                    sum += ints[c2] - (c1 > 0 ? ints[c1 - 1] : 0);
                    count += map.getOrDefault(sum - target, 0);

=== Chunk 1432 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1074.number-of-submatrices-that-sum-to-target\NumberOfSubmatricesThatSumToTarget.java

map.put(sum, map.getOrDefault(sum, 0) + 1);
                }
            }
        }

        return count;
    }
}

=== Chunk 1433 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1074.number-of-submatrices-that-sum-to-target\NumberOfSubmatricesThatSumToTargetTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1434 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1074.number-of-submatrices-that-sum-to-target\NumberOfSubmatricesThatSumToTargetTest.java

public class NumberOfSubmatricesThatSumToTargetTest {
    NumberOfSubmatricesThatSumToTarget NumberOfSubmatricesThatSumToTarget = new NumberOfSubmatricesThatSumToTarget();

    @Test
    void Example1() {
        int[][] matrix = {{0, 1, 0}, {1, 1, 1}, {0, 1, 0}};
        int target = 0;
        int results = NumberOfSubmatricesThatSumToTarget.numSubmatrixSumTarget(matrix, target);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] matrix = {{1,-1},{-1,1}};
        int target = 0;
        int results = NumberOfSubmatricesThatSumToTarget.numSubmatrixSumTarget(matrix, target);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);
    }

=== Chunk 1435 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1074.number-of-submatrices-that-sum-to-target\NumberOfSubmatricesThatSumToTargetTest.java

}

    @Test
    void Example3() {
        int[][] matrix = {{904}};
        int target = 0;
        int results = NumberOfSubmatricesThatSumToTarget.numSubmatrixSumTarget(matrix, target);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1436 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1091.shortest-path-in-binary-matrix\ShortestPathInBinaryMatrix.java

import java.util.LinkedList;
import java.util.Queue;

=== Chunk 1437 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1091.shortest-path-in-binary-matrix\ShortestPathInBinaryMatrix.java

class ShortestPathInBinaryMatrix {
    public int shortestPathBinaryMatrix(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) return -1;
        int res = 0;

        int row = grid.length;
        int col = grid[0].length;

        if (grid[0][0] == 1 || grid[row - 1][col - 1] == 1) return -1;
        int[][] directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
        boolean[][] visited = new boolean[row][col];
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{0, 0});
        visited[0][0] = true;

        while (!queue.isEmpty()) {
            int size = queue.size();
            res++;

            for (int i = 0; i < size; i++) {

=== Chunk 1438 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1091.shortest-path-in-binary-matrix\ShortestPathInBinaryMatrix.java

for (int i = 0; i < size; i++) {
                int[] curPos = queue.poll();
                if (curPos[0] == row - 1 && curPos[1] == col - 1) return res;
                for (int[] dir : directions) {
                    int nextX = curPos[0] + dir[0];
                    int nextY = curPos[1] + dir[1];
                    if (nextX < 0 || nextX >= row || nextY < 0 || nextY >= col || visited[nextX][nextY] || grid[nextX][nextY] == 1) continue;
                    visited[nextX][nextY] = true;
                    queue.offer(new int[]{nextX, nextY});
                }
            }
        }

        return -1;
    }
}

=== Chunk 1439 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1091.shortest-path-in-binary-matrix\ShortestPathInBinaryMatrixTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1440 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1091.shortest-path-in-binary-matrix\ShortestPathInBinaryMatrixTest.java

public class ShortestPathInBinaryMatrixTest {
    ShortestPathInBinaryMatrix ShortestPathInBinaryMatrix = new ShortestPathInBinaryMatrix();

    @Test
    void Example1() {
        int[][] grid = {{0, 1}, {1, 0}};
        int results = ShortestPathInBinaryMatrix.shortestPathBinaryMatrix(grid);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] grid = {{0, 0, 0}, {1, 1, 0}, {1, 1, 0}};
        int results = ShortestPathInBinaryMatrix.shortestPathBinaryMatrix(grid);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[][] grid = {{1, 0, 0}, {1, 1, 0}, {1, 1, 0}};

=== Chunk 1441 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1091.shortest-path-in-binary-matrix\ShortestPathInBinaryMatrixTest.java

int results = ShortestPathInBinaryMatrix.shortestPathBinaryMatrix(grid);
        int expectedResults = -1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1442 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1137.n-th-tribonacci-number\NThTribonacciNumber.java

class NThTribonacciNumber {
    public int tribonacci(int n) {
        if (n == 0) return 0;
        if (n <= 2) return 1;
        int first = 0, second = 1, third = 1;
        for (int i = 3; i <= n; i++) {
            int temp = first + second + third;
            first = second;
            second = third;
            third = temp;
        }
        return third;
    }
}

=== Chunk 1443 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1137.n-th-tribonacci-number\NThTribonacciNumberTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class NThTribonacciNumberTest {
    NThTribonacciNumber nThTribonacciNumber = new NThTribonacciNumber();

    @Test
    void Example1() {
        int n = 4;

        Assertions.assertEquals(4, nThTribonacciNumber.tribonacci(n));
    }

    @Test
    void Example2() {
        int n = 25;

        Assertions.assertEquals(1389537, nThTribonacciNumber.tribonacci(n));
    }
}

=== Chunk 1444 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1143.longest-common-subsequence\LongestCommonSubsequence.java

class LongestCommonSubsequence {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            char c1 = text1.charAt(i - 1);
            for (int j = 1; j <= n; j++) {
                char c2 = text2.charAt(j - 1);
                if (c1 == c2)
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[m][n];
    }
}

=== Chunk 1445 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1143.longest-common-subsequence\LongestCommonSubsequenceTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class LongestCommonSubsequenceTest {
    LongestCommonSubsequence longestCommonSubsequence = new LongestCommonSubsequence();

    @Test
    void Example1() {
        String text1 = "abcde", text2 = "ace";

        Assertions.assertEquals(3, longestCommonSubsequence.longestCommonSubsequence(text1, text2));
    }

    @Test
    void Example2() {
        String text1 = "abc", text2 = "abc";

        Assertions.assertEquals(3, longestCommonSubsequence.longestCommonSubsequence(text1, text2));
    }

    @Test
    void Example3() {
        String text1 = "abc", text2 = "def";

        Assertions.assertEquals(0, longestCommonSubsequence.longestCommonSubsequence(text1, text2));
    }
}

=== Chunk 1446 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1155.number-of-dice-rolls-with-target-sum\NumberOfDiceRollsWithTargetSum.java

class NumberOfDiceRollsWithTargetSum {
    private final int modulo = (int) (Math.pow(10, 9) + 7);

    public int numRollsToTarget(int n, int k, int target) {
        int[][] dp = new int[n + 1][target + 1];
        dp[0][0] = 1;

        for (int dice = 1; dice <= n; dice++) {
            for (int targetVal = 0; targetVal <= target; targetVal++) {
                for (int faceVal = 1; faceVal <= k; faceVal++) {
                    if (targetVal >= faceVal) {
                        dp[dice][targetVal] = (dp[dice][targetVal] + dp[dice - 1][targetVal - faceVal]) % modulo;
                    }
                }
            }
        }
        return dp[n][target];
    }
}

=== Chunk 1447 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1155.number-of-dice-rolls-with-target-sum\NumberOfDiceRollsWithTargetSumTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1448 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1155.number-of-dice-rolls-with-target-sum\NumberOfDiceRollsWithTargetSumTest.java

public class NumberOfDiceRollsWithTargetSumTest {
    NumberOfDiceRollsWithTargetSum NumberOfDiceRollsWithTargetSum = new NumberOfDiceRollsWithTargetSum();

    @Test
    void Example1() {
        int n = 1, k = 6, target = 3;
        int results = NumberOfDiceRollsWithTargetSum.numRollsToTarget(n, k, target);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 2, k = 6, target = 7;
        int results = NumberOfDiceRollsWithTargetSum.numRollsToTarget(n, k, target);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int n = 30, k = 30, target = 500;

=== Chunk 1449 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1155.number-of-dice-rolls-with-target-sum\NumberOfDiceRollsWithTargetSumTest.java

int n = 30, k = 30, target = 500;
        int results = NumberOfDiceRollsWithTargetSum.numRollsToTarget(n, k, target);
        int expectedResults = 222616187;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1450 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1207.unique-number-of-occurrences\UniqueNumberOfOccurrences.java

import java.util.Arrays;

class UniqueNumberOfOccurrences {
    public boolean uniqueOccurrences(int[] arr) {
        int[] freq = new int[2001];
        for (int i = 0; i < arr.length; i++) {
            freq[arr[i] + 1000]++;
        }
        Arrays.sort(freq);

        for (int i = 0; i < 2000; i++) {
            if (freq[i] != 0 && freq[i] == freq[i + 1])
                return false;
        }
        return true;
    }
}

=== Chunk 1451 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1207.unique-number-of-occurrences\UniqueNumberOfOccurrencesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1452 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1207.unique-number-of-occurrences\UniqueNumberOfOccurrencesTest.java

public class UniqueNumberOfOccurrencesTest {
    UniqueNumberOfOccurrences uniqueNumberOfOccurrences = new UniqueNumberOfOccurrences();

    @Test
    void Example1() {
        int[] arr = {1, 2, 2, 1, 1, 3};
        boolean results = uniqueNumberOfOccurrences.uniqueOccurrences(arr);

        Assertions.assertTrue(results);
    }

    @Test
    void Example2() {
        int[] arr = {1, 2};
        boolean results = uniqueNumberOfOccurrences.uniqueOccurrences(arr);

        Assertions.assertFalse(results);
    }

    @Test
    void Example3() {
        int[] arr = {-3, 0, 1, -3, 1, 1, 1, -3, 10, 0};
        boolean results = uniqueNumberOfOccurrences.uniqueOccurrences(arr);

        Assertions.assertTrue(results);
    }
}

=== Chunk 1453 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1220.count-vowels-permutation\CountVowelsPermutation.java

import java.util.Arrays;

class CountVowelsPermutation {
    private final int mod = (int) (Math.pow(10, 9) + 7);

    public int countVowelPermutation(int n) {
        long[][] dp = new long[n+1][5];
        Arrays.fill(dp[1], 1);

        // a = 0, e = 1, i = 2, o = 3, u = 4
        for (int i = 2; i < n + 1; i++) {
            Arrays.fill(dp[i], 0);
            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % mod;
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % mod;
            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % mod;
            dp[i][3] = dp[i - 1][2];
            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % mod;
        }

        return (int) (Arrays.stream(dp[n]).sum() % mod);
    }
}

=== Chunk 1454 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1220.count-vowels-permutation\CountVowelsPermutationTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1455 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1220.count-vowels-permutation\CountVowelsPermutationTest.java

public class CountVowelsPermutationTest {
    CountVowelsPermutation CountVowelsPermutation = new CountVowelsPermutation();

    @Test
    void Example1() {
        int n = 1;
        int results = CountVowelsPermutation.countVowelPermutation(n);
        int expectedResults = 5;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 2;
        int results = CountVowelsPermutation.countVowelPermutation(n);
        int expectedResults = 10;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int n = 5;
        int results = CountVowelsPermutation.countVowelPermutation(n);
        int expectedResults = 68;

=== Chunk 1456 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1220.count-vowels-permutation\CountVowelsPermutationTest.java

int expectedResults = 68;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        int n = 144;
        int results = CountVowelsPermutation.countVowelPermutation(n);
        int expectedResults = 18208803;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1457 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1235.maximum-profit-in-job-scheduling\MaximumProfitInJobScheduling.java

import java.util.Arrays;

=== Chunk 1458 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1235.maximum-profit-in-job-scheduling\MaximumProfitInJobScheduling.java

class MaximumProfitInJobScheduling {
    private int binarySearch(int[][] jobs, int right, int target) {
        int left = 0;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (jobs[mid][1] > target) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {
        int n = startTime.length;
        int[][] jobs = new int[n][];
        for (int i = 0; i < n; i++)
            jobs[i] = new int[]{startTime[i], endTime[i], profit[i]};
        Arrays.sort(jobs, (a, b) -> a[1] - b[1]);
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {

=== Chunk 1459 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1235.maximum-profit-in-job-scheduling\MaximumProfitInJobScheduling.java

for (int i = 1; i <= n; i++) {
            int k = binarySearch(jobs, i - 1, jobs[i - 1][0]);
            dp[i] = Math.max(dp[i - 1], dp[k] + jobs[i - 1][2]);
        }
        return dp[n];
    }
}

=== Chunk 1460 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1235.maximum-profit-in-job-scheduling\MaximumProfitInJobSchedulingTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1461 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1235.maximum-profit-in-job-scheduling\MaximumProfitInJobSchedulingTest.java

public class MaximumProfitInJobSchedulingTest {
    MaximumProfitInJobScheduling maximumProfitInJobScheduling = new MaximumProfitInJobScheduling();

    @Test
    void Example1() {
        int[] startTime = {1, 2, 3, 3},  endTime = {3, 4, 5, 6},  profit = {50, 10, 40, 70};
        int results = maximumProfitInJobScheduling.jobScheduling(startTime, endTime, profit);

        Assertions.assertEquals(120, results);
    }

    @Test
    void Example2() {
        int[] startTime = {1, 2, 3, 4, 6},  endTime = {3, 5, 10, 6, 9},  profit = {20, 20, 100, 70, 60};
        int results = maximumProfitInJobScheduling.jobScheduling(startTime, endTime, profit);

        Assertions.assertEquals(150, results);
    }

    @Test
    void Example3() {

=== Chunk 1462 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1235.maximum-profit-in-job-scheduling\MaximumProfitInJobSchedulingTest.java

}

    @Test
    void Example3() {
        int[] startTime = {1, 1, 1},  endTime = {2, 3, 4},  profit = {5, 6, 4};
        int results = maximumProfitInJobScheduling.jobScheduling(startTime, endTime, profit);

        Assertions.assertEquals(6, results);
    }
}

=== Chunk 1463 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1239.maximum-length-of-a-concatenated-string-with-unique-characters\MaximumLengthOfAConcatenatedStringWithUniqueCharacters.java

import java.util.List;

=== Chunk 1464 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1239.maximum-length-of-a-concatenated-string-with-unique-characters\MaximumLengthOfAConcatenatedStringWithUniqueCharacters.java

class MaximumLengthOfAConcatenatedStringWithUniqueCharacters {
    private int max = 0;

    private boolean isValid(String currentStr, String newStr) {
        int[] array = new int[26];
        for (int i = 0; i < newStr.length(); i++) {
            if (++array[newStr.charAt(i) - 'a'] == 2) return false;
            if (currentStr.contains(newStr.charAt(i) + ""))
                return false;
        }
        return true;
    }

    private void backtrack(List<String> arr, String current, int start) {
        if (max < current.length())
            max = current.length();
        for (int i = start; i < arr.size(); i++) {
            if (!isValid(current, arr.get(i))) continue;
            backtrack(arr, current + arr.get(i), i + 1);
        }
    }

=== Chunk 1465 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1239.maximum-length-of-a-concatenated-string-with-unique-characters\MaximumLengthOfAConcatenatedStringWithUniqueCharacters.java

}
    }

    public int maxLength(List<String> arr) {
        backtrack(arr, "", 0);
        return max;
    }
}

=== Chunk 1466 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1239.maximum-length-of-a-concatenated-string-with-unique-characters\MaximumLengthOfAConcatenatedStringWithUniqueCharactersTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

=== Chunk 1467 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1239.maximum-length-of-a-concatenated-string-with-unique-characters\MaximumLengthOfAConcatenatedStringWithUniqueCharactersTest.java

public class MaximumLengthOfAConcatenatedStringWithUniqueCharactersTest {
    MaximumLengthOfAConcatenatedStringWithUniqueCharacters MaximumLengthOfAConcatenatedStringWithUniqueCharacters = new MaximumLengthOfAConcatenatedStringWithUniqueCharacters();

    @Test
    void Example1() {
        List<String> arr = Arrays.asList("un", "iq", "ue");
        int results = MaximumLengthOfAConcatenatedStringWithUniqueCharacters.maxLength(arr);
        int expectResults = 4;

        Assertions.assertEquals(expectResults, results);
    }

    @Test
    void Example2() {
        List<String> arr = Arrays.asList("cha", "r", "act", "ers");
        int results = MaximumLengthOfAConcatenatedStringWithUniqueCharacters.maxLength(arr);
        int expectResults = 6;

=== Chunk 1468 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1239.maximum-length-of-a-concatenated-string-with-unique-characters\MaximumLengthOfAConcatenatedStringWithUniqueCharactersTest.java

int expectResults = 6;

        Assertions.assertEquals(expectResults, results);
    }

    @Test
    void Example3() {
        List<String> arr = List.of("abcdefghijklmnopqrstuvwxyz");
        int results = MaximumLengthOfAConcatenatedStringWithUniqueCharacters.maxLength(arr);
        int expectResults = 26;

        Assertions.assertEquals(expectResults, results);
    }
}

=== Chunk 1469 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1254.number-of-closed-islands\NumberOfClosedIslands.java

class NumberOfClosedIslands {
    private int m, n;
    private int res = 0;
    private final int[] dx = {-1, 0, 1, 0};
    private final int[] dy = {0, 1, 0, -1};

    public int closedIsland(int[][] grid) {
        m = grid.length;
        n = grid[0].length;
        if (m <= 2 || n <= 2) return 0;
        for (int i = 1; i < m - 1; i++) {
            for (int j = 1; j < n - 1; j++) {
                if (grid[i][j] == 0)
                    if (dfs(grid, i, j)) res++;
            }
        }

        return res;
    }

    private boolean dfs(int[][] grid, int x, int y) {
        if ((x == 0 || x == m - 1 || y == 0 || y == n - 1) && grid[x][y] == 0) {
            return false;
        }
        boolean f = true;
        grid[x][y] = 1;

=== Chunk 1470 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1254.number-of-closed-islands\NumberOfClosedIslands.java

grid[x][y] = 1;
        for (int i = 0; i < 4; i++) {
            int x1 = x + dx[i], y1 = y + dy[i];
            if (x1 < 0 || x1 >= m || y1 < 0 || y1 >= n || grid[x1][y1] == 1) continue;
            f = f & dfs(grid, x1, y1);
        }
        return f;
    }
}

=== Chunk 1471 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1254.number-of-closed-islands\NumberOfClosedIslandsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1472 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1254.number-of-closed-islands\NumberOfClosedIslandsTest.java

public class NumberOfClosedIslandsTest {
    NumberOfClosedIslands numberOfClosedIslands = new NumberOfClosedIslands();

    @Test
    void Example1() {
        int[][] grid = {{1, 1, 1, 1, 1, 1, 1, 0}, {1, 0, 0, 0, 0, 1, 1, 0}, {1, 0, 1, 0, 1, 1, 1, 0}, {1, 0, 0, 0, 0, 1, 0, 1}, {1, 1, 1, 1, 1, 1, 1, 0}};

        Assertions.assertEquals(2, numberOfClosedIslands.closedIsland(grid));
    }

    @Test
    void Example2() {
        int[][] grid = {{0, 0, 1, 0, 0}, {0, 1, 0, 1, 0}, {0, 1, 1, 1, 0}};

        Assertions.assertEquals(1, numberOfClosedIslands.closedIsland(grid));
    }

    @Test
    void Example3() {

=== Chunk 1473 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1254.number-of-closed-islands\NumberOfClosedIslandsTest.java

}

    @Test
    void Example3() {
        int[][] grid = {{1, 1, 1, 1, 1, 1, 1}, {1, 0, 0, 0, 0, 0, 1}, {1, 0, 1, 1, 1, 0, 1}, {1, 0, 1, 0, 1, 0, 1}, {1, 0, 1, 1, 1, 0, 1}, {1, 0, 0, 0, 0, 0, 1}, {1, 1, 1, 1, 1, 1, 1}};

        Assertions.assertEquals(2, numberOfClosedIslands.closedIsland(grid));
    }
}

=== Chunk 1474 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1293.shortest-path-in-a-grid-with-obstacles-elimination\ShortestPathInAGridWithObstaclesElimination.java

import java.util.LinkedList;
import java.util.Queue;

=== Chunk 1475 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1293.shortest-path-in-a-grid-with-obstacles-elimination\ShortestPathInAGridWithObstaclesElimination.java

class ShortestPathInAGridWithObstaclesElimination {
    private static final int[][] directions = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};

    public int shortestPath(int[][] grid, int k) {
        int m = grid.length, n = grid[0].length;
        boolean[][][] visited = new boolean[m][n][k + 1];

        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{0, 0, k});

        int dist = 0;

        while (!queue.isEmpty()) {
            int size = queue.size();

            while (size-- > 0) {
                int[] curr = queue.remove();
                int x = curr[0];
                int y = curr[1];
                int obs = curr[2];
                if (x == m - 1 && y == n - 1 && obs >= 0) return dist;

=== Chunk 1476 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1293.shortest-path-in-a-grid-with-obstacles-elimination\ShortestPathInAGridWithObstaclesElimination.java

if (obs < 0 || visited[x][y][obs]) continue;
                visited[x][y][obs] = true;
                if (x - 1 >= 0) queue.add(new int[]{x - 1, y, obs - grid[x - 1][y]});
                if (x + 1 < m) queue.add(new int[]{x + 1, y, obs - grid[x + 1][y]});
                if (y - 1 >= 0) queue.add(new int[]{x, y - 1, obs - grid[x][y - 1]});
                if (y + 1 < n) queue.add(new int[]{x, y + 1, obs - grid[x][y + 1]});
            }
            dist++;
        }
        return -1;
    }
}

=== Chunk 1477 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1293.shortest-path-in-a-grid-with-obstacles-elimination\ShortestPathInAGridWithObstaclesEliminationTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1478 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1293.shortest-path-in-a-grid-with-obstacles-elimination\ShortestPathInAGridWithObstaclesEliminationTest.java

public class ShortestPathInAGridWithObstaclesEliminationTest {
    ShortestPathInAGridWithObstaclesElimination ShortestPathInAGridWithObstaclesElimination = new ShortestPathInAGridWithObstaclesElimination();

    @Test
    void Example1() {
        int[][] grid = {{0, 0, 0}, {1, 1, 0}, {0, 0, 0}, {0, 1, 1}, {0, 0, 0}};
        int k = 1;
        int results = ShortestPathInAGridWithObstaclesElimination.shortestPath(grid, k);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] grid = {{0, 1, 1}, {1, 1, 1}, {1, 0, 0}};
        int k = 1;
        int results = ShortestPathInAGridWithObstaclesElimination.shortestPath(grid, k);
        int expectedResults = -1;

=== Chunk 1479 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1293.shortest-path-in-a-grid-with-obstacles-elimination\ShortestPathInAGridWithObstaclesEliminationTest.java

int expectedResults = -1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1480 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1319.number-of-operations-to-make-network-connected\NumberOfOperationsToMakeNetworkConnected.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 1481 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1319.number-of-operations-to-make-network-connected\NumberOfOperationsToMakeNetworkConnected.java

class NumberOfOperationsToMakeNetworkConnected {
    List<Integer>[] edges;
    boolean[] visited;

    public int makeConnected(int n, int[][] connections) {
        if (connections.length < n - 1) {
            return -1;
        }

        edges = new List[n];
        for (int i = 0; i < n; i++) {
            edges[i] = new ArrayList<>();
        }
        for (int[] connection : connections) {
            edges[connection[0]].add(connection[1]);
            edges[connection[1]].add(connection[0]);
        }

        visited = new boolean[n];
        int res = 0;
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(i);
                res++;
            }
        }

        return res - 1;
    }

=== Chunk 1482 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1319.number-of-operations-to-make-network-connected\NumberOfOperationsToMakeNetworkConnected.java

}

        return res - 1;
    }

    private void dfs(int n) {
        visited[n] = true;
        for (int v : edges[n]) {
            if (!visited[v]) {
                dfs(v);
            }
        }
    }
}

=== Chunk 1483 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1319.number-of-operations-to-make-network-connected\NumberOfOperationsToMakeNetworkConnectedTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1484 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1319.number-of-operations-to-make-network-connected\NumberOfOperationsToMakeNetworkConnectedTest.java

public class NumberOfOperationsToMakeNetworkConnectedTest {
    NumberOfOperationsToMakeNetworkConnected numberOfOperationsToMakeNetworkConnected = new NumberOfOperationsToMakeNetworkConnected();

    @Test
    void Example1() {
        int n = 4;
        int[][] connections = {{0, 1}, {0, 2}, {1, 2}};

        Assertions.assertEquals(1,  numberOfOperationsToMakeNetworkConnected.makeConnected(n,  connections));
    }

    @Test
    void Example2() {
        int n = 6;
        int[][] connections = {{0, 1}, {0, 2}, {0, 3}, {1, 2}, {1, 3}};

        Assertions.assertEquals(2,  numberOfOperationsToMakeNetworkConnected.makeConnected(n,  connections));
    }

    @Test
    void Example3() {
        int n = 6;

=== Chunk 1485 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1319.number-of-operations-to-make-network-connected\NumberOfOperationsToMakeNetworkConnectedTest.java

void Example3() {
        int n = 6;
        int[][] connections = {{0, 1}, {0, 2}, {0, 3}, {1, 2}};

        Assertions.assertEquals(-1,  numberOfOperationsToMakeNetworkConnected.makeConnected(n,  connections));
    }
}

=== Chunk 1486 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1323.maximum-69-number\Maximum69Number.java

class Maximum69Number {
    public int maximum69Number (int num) {
        int numCopy = num;
        int indexSix = -1;
        int currDigit = 0;

        while (numCopy > 0) {
            if (numCopy % 10 == 6)
                indexSix = currDigit;
            numCopy /= 10;
            currDigit++;
        }

        return indexSix == -1 ? num : num + 3 * (int) Math.pow(10, indexSix);
    }
}

=== Chunk 1487 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1323.maximum-69-number\Maximum69NumberTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1488 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1323.maximum-69-number\Maximum69NumberTest.java

public class Maximum69NumberTest {
    Maximum69Number Maximum69Number = new Maximum69Number();

    @Test
    void Example1() {
        int num = 9669;
        int results = Maximum69Number.maximum69Number(num);
        int expectedResults = 9969;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int num = 9996;
        int results = Maximum69Number.maximum69Number(num);
        int expectedResults = 9999;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int num = 9999;
        int results = Maximum69Number.maximum69Number(num);
        int expectedResults = 9999;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1489 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1328.break-a-palindrome\BreakAPalindrome.java

class BreakAPalindrome {
    public String breakPalindrome(String palindrome) {
        if (palindrome.length() <= 1) return "";
        char[] chars = palindrome.toCharArray();
        int len = palindrome.length();
        for (int i = 0; i < len; i++) {
            if (i == len - 1) {
                chars[i] = 'b';
            }
            if (palindrome.charAt(i) != 'a' && i != (len / 2)) {
                chars[i] = 'a';
                break;
            }
        }
        return String.valueOf(chars);
    }
}

=== Chunk 1490 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1328.break-a-palindrome\BreakAPalindromeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1491 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1328.break-a-palindrome\BreakAPalindromeTest.java

public class BreakAPalindromeTest {
    BreakAPalindrome BreakAPalindrome = new BreakAPalindrome();

    @Test
    void Example1() {
        String palindrome = "abccba";
        String results = BreakAPalindrome.breakPalindrome(palindrome);
        String expectedResults = "aaccba";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String palindrome = "a";
        String results = BreakAPalindrome.breakPalindrome(palindrome);
        String expectedResults = "";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String palindrome = "aba";
        String results = BreakAPalindrome.breakPalindrome(palindrome);
        String expectedResults = "abb";

=== Chunk 1492 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1328.break-a-palindrome\BreakAPalindromeTest.java

String expectedResults = "abb";

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1493 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1329.sort-the-matrix-diagonally\SortTheMatrixDiagonally.java

class SortTheMatrixDiagonally {
    private void pass(int[][] a, int row, int col, int n, int m) {
        int[] arr = new int[101];
        int i = row, j = col;
        while (row < n && col < m) {
            arr[a[row++][col++]]++;
        }
        for (int k = 0; k < 101; k++) {
            if (arr[k] > 0) {
                while (arr[k] != 0) {
                    a[i++][j++] = k;
                    arr[k]--;
                }
            }
        }
    }

    public int[][] diagonalSort(int[][] mat) {
        int row = mat.length;
        int col = mat[0].length;
        int count = 0, i = 0, k = 0;
        while (count < row + col) {
            if (i == row - 1 && k < col) k++;
            if (i != row - 1) i++;

=== Chunk 1494 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1329.sort-the-matrix-diagonally\SortTheMatrixDiagonally.java

if (i != row - 1) i++;
            pass(mat, row - 1 - i, k, row, col);
            count++;
        }
        return mat;
    }
}

=== Chunk 1495 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1329.sort-the-matrix-diagonally\SortTheMatrixDiagonallyTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1496 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1329.sort-the-matrix-diagonally\SortTheMatrixDiagonallyTest.java

public class SortTheMatrixDiagonallyTest {
    SortTheMatrixDiagonally SortTheMatrixDiagonally = new SortTheMatrixDiagonally();

    @Test
    void Example1() {
        int[][] mat = {{3, 3, 1, 1}, {2, 2, 1, 2}, {1, 1, 1, 2}};
        int[][] results = SortTheMatrixDiagonally.diagonalSort(mat);
        int[][] expectedResults = {{1, 1, 1, 1}, {1, 2, 2, 2}, {1, 2, 3, 3}};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] mat = {{11, 25, 66, 1, 69, 7}, {23, 55, 17, 45, 15, 52}, {75, 31, 36, 44, 58, 8}, {22, 27, 33, 25, 68, 4}, {84, 28, 14, 11, 5, 50}};
        int[][] results = SortTheMatrixDiagonally.diagonalSort(mat);

=== Chunk 1497 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1329.sort-the-matrix-diagonally\SortTheMatrixDiagonallyTest.java

int[][] expectedResults = {{5, 17, 4, 1, 52, 7}, {11, 11, 25, 45, 8, 69}, {14, 23, 25, 44, 58, 15}, {22, 27, 31, 36, 50, 66}, {84, 28, 75, 33, 55, 68}};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 1498 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1335.minimum-difficulty-of-a-job-schedule\MinimumDifficultyOfAJobSchedule.java

class MinimumDifficultyOfAJobSchedule {
    public int minDifficulty(int[] jobDifficulty, int d) {
        int n = jobDifficulty.length;
        if (d > n) return -1;
        int[][] dp = new int[d + 1][n + 1];
        for (int i = 1; i <= n; i++)
            dp[1][i] = Math.max(dp[1][i - 1], jobDifficulty[i - 1]);
        for (int i = 2; i <= d; i++) {
            for (int j = i; j <= n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
                int currMax = 0;
                for (int k = j; k >= i; k--) {
                    currMax = Math.max(currMax, jobDifficulty[k - 1]);
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][k - 1] + currMax);
                }
            }
        }
        return dp[d][n];
    }
}

=== Chunk 1499 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1335.minimum-difficulty-of-a-job-schedule\MinimumDifficultyOfAJobScheduleTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1500 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1335.minimum-difficulty-of-a-job-schedule\MinimumDifficultyOfAJobScheduleTest.java

public class MinimumDifficultyOfAJobScheduleTest {
    MinimumDifficultyOfAJobSchedule MinimumDifficultyOfAJobSchedule = new MinimumDifficultyOfAJobSchedule();

    @Test
    void Example1() {
        int[] jobDifficulty = {6, 5, 4, 3, 2, 1};
        int d = 2;
        int results = MinimumDifficultyOfAJobSchedule.minDifficulty(jobDifficulty, d);
        int expectedResults = 7;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] jobDifficulty = {9, 9, 9};
        int d = 4;
        int results = MinimumDifficultyOfAJobSchedule.minDifficulty(jobDifficulty, d);
        int expectedResults = -1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 1501 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1335.minimum-difficulty-of-a-job-schedule\MinimumDifficultyOfAJobScheduleTest.java

}

    @Test
    void Example3() {
        int[] jobDifficulty = {1, 1, 1};
        int d = 3;
        int results = MinimumDifficultyOfAJobSchedule.minDifficulty(jobDifficulty, d);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1502 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1338.reduce-array-size-to-the-half\ReduceArraySizeToTheHalf.java

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

class ReduceArraySizeToTheHalf {
    public int minSetSize(int[] arr) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i : arr) {
            map.put(i, map.getOrDefault(i, 0) + 1);
        }
        ArrayList<Integer> arrayList = new ArrayList<>(map.values());
        arrayList.sort(Collections.reverseOrder());

        int currentSize = 0, minimumSet = 0;
        while (currentSize < arr.length / 2) {
            currentSize += arrayList.remove(0);
            minimumSet++;
        }

        return minimumSet;
    }
}

=== Chunk 1503 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1338.reduce-array-size-to-the-half\ReduceArraySizeToTheHalfTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ReduceArraySizeToTheHalfTest {
    ReduceArraySizeToTheHalf ReduceArraySizeToTheHalf = new ReduceArraySizeToTheHalf();

    @Test
    void Example1() {
        int[] arr = {3, 3, 3, 3, 5, 5, 5, 2, 2, 7};
        int results = ReduceArraySizeToTheHalf.minSetSize(arr);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] arr = {7, 7, 7, 7, 7, 7};
        int results = ReduceArraySizeToTheHalf.minSetSize(arr);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1504 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1354.construct-target-array-with-multiple-sums\ConstructTargetArrayWithMultipleSums.java

import java.util.PriorityQueue;

class ConstructTargetArrayWithMultipleSums {
    public boolean isPossible(int[] target) {
        long sum = 0;
        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);
        for (int i = 0; i < target.length; i++) {
            sum += target[i];
            pq.offer(target[i]);
        }

        while (pq.peek() != 1) {
            int value = pq.poll();
            long diff = sum - value;
            if (diff == 1) return true;
            if (diff > value || diff == 0 || value % diff == 0) return false;

            value %= diff;
            sum = diff + value;
            pq.offer(value);
        }

        return true;
    }
}

=== Chunk 1505 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1354.construct-target-array-with-multiple-sums\ConstructTargetArrayWithMultipleSums2.java

class ConstructTargetArrayWithMultipleSums2 {
    public boolean isPossible(int[] target) {
        long sum = 0;
        int max = 0;

        for (int i = 0; i < target.length; i++) {
            sum += target[i];
            if (target[max] < target[i]) {
                max = i;
            }
        }

        long diff = sum - target[max];
        if (target[max] == 1 || diff == 1) return true;
        if (diff > target[max] || diff == 0 || target[max] % diff == 0) return false;

        target[max] %= diff;

        return isPossible(target);
    }
}

=== Chunk 1506 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1354.construct-target-array-with-multiple-sums\ConstructTargetArrayWithMultipleSumsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1507 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1354.construct-target-array-with-multiple-sums\ConstructTargetArrayWithMultipleSumsTest.java

public class ConstructTargetArrayWithMultipleSumsTest {
    ConstructTargetArrayWithMultipleSums ConstructTargetArrayWithMultipleSums = new ConstructTargetArrayWithMultipleSums();
    ConstructTargetArrayWithMultipleSums2 ConstructTargetArrayWithMultipleSums2 = new ConstructTargetArrayWithMultipleSums2();

    @Test
    void Example1() {
        int[] target = {9, 3, 5};
        boolean results = ConstructTargetArrayWithMultipleSums.isPossible(target);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);

        results = ConstructTargetArrayWithMultipleSums2.isPossible(target);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] target = {1, 1, 1, 2};

=== Chunk 1508 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1354.construct-target-array-with-multiple-sums\ConstructTargetArrayWithMultipleSumsTest.java

int[] target = {1, 1, 1, 2};
        boolean results = ConstructTargetArrayWithMultipleSums.isPossible(target);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);

        results = ConstructTargetArrayWithMultipleSums2.isPossible(target);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] target = {8, 5};
        boolean results = ConstructTargetArrayWithMultipleSums.isPossible(target);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);

        results = ConstructTargetArrayWithMultipleSums2.isPossible(target);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1509 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1372.longest-zigzag-path-in-a-binary-tree\LongestZigzagPathInABinaryTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1510 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1372.longest-zigzag-path-in-a-binary-tree\LongestZigzagPathInABinaryTree.java

class LongestZigzagPathInABinaryTree {
    int maxRes;

    public int longestZigZag(TreeNode root) {
        if (root == null) {
            return 0;
        }
        maxRes = 0;
        dfs(root, true, 0);
        return maxRes;
    }

    private void dfs(TreeNode node, boolean dir, int len) {
        maxRes = Math.max(maxRes, len);
        if (!dir) {
            if (node.left != null) {
                dfs(node.left, true, len + 1);
            }
            if (node.right != null) {
                dfs(node.right, false, 1);
            }
        } else {
            if (node.left != null) {
                dfs(node.left, true, 1);
            }
            if (node.right != null) {
                dfs(node.right, false, len + 1);
            }

=== Chunk 1511 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1372.longest-zigzag-path-in-a-binary-tree\LongestZigzagPathInABinaryTree.java

}
        }
    }
}

=== Chunk 1512 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1372.longest-zigzag-path-in-a-binary-tree\LongestZigzagPathInABinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1513 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1372.longest-zigzag-path-in-a-binary-tree\LongestZigzagPathInABinaryTreeTest.java

public class LongestZigzagPathInABinaryTreeTest {
    LongestZigzagPathInABinaryTree longestZigzagPathInABinaryTree = new LongestZigzagPathInABinaryTree();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(1);
        root.right = new TreeNode(1);
        root.right.left = new TreeNode(1);
        root.right.right = new TreeNode(1);
        root.right.right.left = new TreeNode(1);
        root.right.right.right = new TreeNode(1);
        root.right.right.left.right = new TreeNode(1);
        root.right.right.left.right.right = new TreeNode(1);

        Assertions.assertEquals(3, longestZigzagPathInABinaryTree.longestZigZag(root));
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(1);

=== Chunk 1514 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1372.longest-zigzag-path-in-a-binary-tree\LongestZigzagPathInABinaryTreeTest.java

root.left = new TreeNode(1);
        root.right = new TreeNode(1);
        root.left.right = new TreeNode(1);
        root.left.right.left = new TreeNode(1);
        root.left.right.right = new TreeNode(1);
        root.left.right.left.right = new TreeNode(1);

        Assertions.assertEquals(4, longestZigzagPathInABinaryTree.longestZigZag(root));
    }

    @Test
    void Example3() {
        TreeNode root = new TreeNode(1);

        Assertions.assertEquals(0, longestZigzagPathInABinaryTree.longestZigZag(root));
    }
}

=== Chunk 1515 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1383.maximum-performance-of-a-team\MaximumPerformanceOfATeam.java

import java.util.Arrays;
import java.util.PriorityQueue;

=== Chunk 1516 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1383.maximum-performance-of-a-team\MaximumPerformanceOfATeam.java

class MaximumPerformanceOfATeam {
    private final int modulo = (int) (Math.pow(10, 9) + 7);

    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {
        int[][] order = new int[n][2];
        for (int i = 0; i < n; i++) {
            order[i] = new int[]{efficiency[i], speed[i]};
        }
        Arrays.sort(order, (a, b) -> Integer.compare(b[0], a[0]));
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        long totalSpeed = 0, best = 0;
        for (int[] pair : order) {
            int spd = pair[1];
            pq.add(spd);
            if (pq.size() <= k) totalSpeed += spd;
            else totalSpeed += spd - pq.poll();
            best = Math.max(best, totalSpeed * pair[0]);
        }
        return (int) (best % modulo);

=== Chunk 1517 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1383.maximum-performance-of-a-team\MaximumPerformanceOfATeam.java

}
        return (int) (best % modulo);
    }
}

=== Chunk 1518 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1383.maximum-performance-of-a-team\MaximumPerformanceOfATeamTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1519 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1383.maximum-performance-of-a-team\MaximumPerformanceOfATeamTest.java

public class MaximumPerformanceOfATeamTest {
    MaximumPerformanceOfATeam MaximumPerformanceOfATeam = new MaximumPerformanceOfATeam();

    @Test
    void Example1() {
        int n = 6, k = 2;
        int[] speed = {2, 10, 3, 1, 5, 8},  efficiency = {5, 4, 3, 9, 7, 2};
        int results = MaximumPerformanceOfATeam.maxPerformance(n, speed, efficiency, k);
        int expectedResults = 60;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 6, k = 3;
        int[] speed = {2, 10, 3, 1, 5, 8},  efficiency = {5, 4, 3, 9, 7, 2};
        int results = MaximumPerformanceOfATeam.maxPerformance(n, speed, efficiency, k);
        int expectedResults = 68;

=== Chunk 1520 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1383.maximum-performance-of-a-team\MaximumPerformanceOfATeamTest.java

int expectedResults = 68;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int n = 6, k = 4;
        int[] speed = {2, 10, 3, 1, 5, 8},  efficiency = {5, 4, 3, 9, 7, 2};
        int results = MaximumPerformanceOfATeam.maxPerformance(n, speed, efficiency, k);
        int expectedResults = 72;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1521 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1402.reducing-dishes\ReducingDishes.java

import java.util.Arrays;

class ReducingDishes {
    public int maxSatisfaction(int[] satisfaction) {
        Arrays.sort(satisfaction);
        int preSum = 0, res = 0;
        for (int i = satisfaction.length - 1; i >= 0; i--) {
            if (preSum + satisfaction[i] > 0) {
                preSum += satisfaction[i];
                res += preSum;
            } else {
                break;
            }
        }
        return res;
    }
}

=== Chunk 1522 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1402.reducing-dishes\ReducingDishesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class ReducingDishesTest {
    ReducingDishes reducingDishes = new ReducingDishes();

    @Test
    void Example1() {
        int[] satisfaction = {-1, -8, 0, 5, -9};

        Assertions.assertEquals(14, reducingDishes.maxSatisfaction(satisfaction));
    }

    @Test
    void Example2() {
        int[] satisfaction = {4, 3, 2};

        Assertions.assertEquals(20, reducingDishes.maxSatisfaction(satisfaction));
    }

    @Test
    void Example3() {
        int[] satisfaction = {-1, -4, -5};

        Assertions.assertEquals(0, reducingDishes.maxSatisfaction(satisfaction));
    }
}

=== Chunk 1523 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1423.maximum-points-you-can-obtain-from-cards\MaximumPointsYouCanObtainFromCards.java

class MaximumPointsYouCanObtainFromCards {
    public int maxScore(int[] cardPoints, int k) {
        int l = 0, r = cardPoints.length - k;
        int sum = 0;
        for (int i = r; i < cardPoints.length; i++) {
            sum += cardPoints[i];
        }
        if (cardPoints.length == k) {
            return sum;
        }
        int max = sum;
        while (r < cardPoints.length) {
            sum += (cardPoints[l] - cardPoints[r]);
            max = Math.max(max, sum);
            l++;
            r++;
        }
        return max;
    }
}

=== Chunk 1524 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1423.maximum-points-you-can-obtain-from-cards\MaximumPointsYouCanObtainFromCardsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1525 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1423.maximum-points-you-can-obtain-from-cards\MaximumPointsYouCanObtainFromCardsTest.java

public class MaximumPointsYouCanObtainFromCardsTest {
    MaximumPointsYouCanObtainFromCards MaximumPointsYouCanObtainFromCards = new MaximumPointsYouCanObtainFromCards();

    @Test
    void Example1() {
        int[] target = {1, 2, 3, 4, 5, 6, 1};
        int k = 3;
        int results = MaximumPointsYouCanObtainFromCards.maxScore(target, k);
        int expectedResults = 12;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] target = {2, 2, 2};
        int k = 2;
        int results = MaximumPointsYouCanObtainFromCards.maxScore(target, k);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example() {

=== Chunk 1526 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1423.maximum-points-you-can-obtain-from-cards\MaximumPointsYouCanObtainFromCardsTest.java

}

    @Test
    void Example() {
        int[] target = {9, 7, 7, 9, 7, 7, 9};
        int k = 7;
        int results = MaximumPointsYouCanObtainFromCards.maxScore(target, k);
        int expectedResults = 55;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1527 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1431.kids-with-the-greatest-number-of-candies\KidsWithTheGreatestNumberOfCandies.java

import java.util.ArrayList;
import java.util.List;

class KidsWithTheGreatestNumberOfCandies {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        int greatestCandies = 0;
        for (int candy: candies) {
            if (candy > greatestCandies) {
                greatestCandies = candy;
            }
        }
        List<Boolean> res = new ArrayList<>();
        for (int candy: candies) {
            if (candy + extraCandies >= greatestCandies) {
                res.add(true);
            } else {
                res.add(false);
            }
        }
        return res;
    }
}

=== Chunk 1528 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1431.kids-with-the-greatest-number-of-candies\KidsWithTheGreatestNumberOfCandiesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

=== Chunk 1529 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1431.kids-with-the-greatest-number-of-candies\KidsWithTheGreatestNumberOfCandiesTest.java

public class KidsWithTheGreatestNumberOfCandiesTest {
    KidsWithTheGreatestNumberOfCandies kidsWithTheGreatestNumberOfCandies = new KidsWithTheGreatestNumberOfCandies();

    @Test
    void Example1() {
        int[] candies = {2, 3, 5, 1, 3};
        int extraCandies = 3;

        List<Boolean> expectedResults = Arrays.asList(true, true, true, false, true);
        Assertions.assertEquals(expectedResults, kidsWithTheGreatestNumberOfCandies.kidsWithCandies(candies, extraCandies));
    }

    @Test
    void Example2() {
        int[] candies = {4, 2, 1, 1, 2};
        int extraCandies = 1;

        List<Boolean> expectedResults = Arrays.asList(true, false, false, false, false);

=== Chunk 1530 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1431.kids-with-the-greatest-number-of-candies\KidsWithTheGreatestNumberOfCandiesTest.java

Assertions.assertEquals(expectedResults, kidsWithTheGreatestNumberOfCandies.kidsWithCandies(candies, extraCandies));
    }

    @Test
    void Example3() {
        int[] candies = {12, 1, 12};
        int extraCandies = 10;

        List<Boolean> expectedResults = Arrays.asList(true, false, true);
        Assertions.assertEquals(expectedResults, kidsWithTheGreatestNumberOfCandies.kidsWithCandies(candies, extraCandies));
    }
}

=== Chunk 1531 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1444.number-of-ways-of-cutting-a-pizza\NumberOfWaysOfCuttingAPizza.java

class NumberOfWaysOfCuttingAPizza {
    private final int modulo = (int) (Math.pow(10, 9) + 7);

    private int dfs(int m, int n, int k, int r, int c, Integer[][][] dp, int[][] preSum) {
        if (preSum[r][c] == 0) return 0;
        if (k == 0) return 1;
        if (dp[k][r][c] != null) return dp[k][r][c];
        int res = 0;
        for (int nr = r + 1; nr < m; nr++) {
            if (preSum[r][c] - preSum[nr][c] > 0) {
                res = (res + dfs(m, n, k - 1, nr, c, dp, preSum)) % modulo;
            }
        }
        for (int nc = c + 1; nc < n; nc++) {
            if (preSum[r][c] - preSum[r][nc] > 0) {
                res = (res + dfs(m, n, k - 1, r, nc, dp, preSum)) % modulo;
            }
        }
        dp[k][r][c] = res;

=== Chunk 1532 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1444.number-of-ways-of-cutting-a-pizza\NumberOfWaysOfCuttingAPizza.java

}
        dp[k][r][c] = res;
        return dp[k][r][c];
    }

    public int ways(String[] pizza, int k) {
        int m = pizza.length, n = pizza[0].length();
        Integer[][][] dp = new Integer[k][m][n];
        int[][] preSum = new int[m + 1][n + 1];
        for (int r = m - 1; r >= 0; r--) {
            for (int c = n - 1; c >= 0; c--) {
                preSum[r][c] = preSum[r][c + 1] + preSum[r + 1][c] - preSum[r + 1][c + 1] + (pizza[r].charAt(c) == 'A' ? 1 : 0);
            }
        }
        return dfs(m, n, k - 1, 0, 0, dp, preSum);
    }
}

=== Chunk 1533 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1444.number-of-ways-of-cutting-a-pizza\NumberOfWaysOfCuttingAPizzaTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1534 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1444.number-of-ways-of-cutting-a-pizza\NumberOfWaysOfCuttingAPizzaTest.java

public class NumberOfWaysOfCuttingAPizzaTest {
    NumberOfWaysOfCuttingAPizza NumberOfWaysOfCuttingAPizza = new NumberOfWaysOfCuttingAPizza();

    @Test
    void Example1() {
        String[] pizza = {"A..", "AAA", "..."};
        int k = 3;
        int results = NumberOfWaysOfCuttingAPizza.ways(pizza, k);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String[] pizza = {"A..", "AA.", "..."};
        int k = 3;
        int results = NumberOfWaysOfCuttingAPizza.ways(pizza, k);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String[] pizza = {"A..","A..","..."};
        int k = 1;

=== Chunk 1535 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1444.number-of-ways-of-cutting-a-pizza\NumberOfWaysOfCuttingAPizzaTest.java

int k = 1;
        int results = NumberOfWaysOfCuttingAPizza.ways(pizza, k);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1536 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1448.count-good-nodes-in-binary-tree\CountGoodNodesInBinaryTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1537 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1448.count-good-nodes-in-binary-tree\CountGoodNodesInBinaryTree.java

class CountGoodNodesInBinaryTree {
    private int count = 0;

    private void goodNodes(TreeNode root, int maxValue) {
        if (root == null) return;
        if (maxValue <= root.val) {
            count++;
            maxValue = root.val;
        }
        goodNodes(root.left, maxValue);
        goodNodes(root.right, maxValue);
    }

    public int goodNodes(TreeNode root) {
        goodNodes(root, root.val);
        return count;
    }
}

=== Chunk 1538 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1448.count-good-nodes-in-binary-tree\CountGoodNodesInBinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1539 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1448.count-good-nodes-in-binary-tree\CountGoodNodesInBinaryTreeTest.java

public class CountGoodNodesInBinaryTreeTest {
    CountGoodNodesInBinaryTree CountGoodNodesInBinaryTree = new CountGoodNodesInBinaryTree();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(1);
        root.left.left = new TreeNode(3);
        root.right = new TreeNode(4);
        root.right.left = new TreeNode(1);
        root.right.right = new TreeNode(5);

        int results = CountGoodNodesInBinaryTree.goodNodes(root);
        int expectedResult = 4;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(3);
        root.left.left = new TreeNode(4);

=== Chunk 1540 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1448.count-good-nodes-in-binary-tree\CountGoodNodesInBinaryTreeTest.java

root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(2);

        int results = CountGoodNodesInBinaryTree.goodNodes(root);
        int expectedResult = 3;

        Assertions.assertEquals(expectedResult, results);
    }

    @Test
    void Example3() {
        TreeNode root = new TreeNode(1);

        int results = CountGoodNodesInBinaryTree.goodNodes(root);
        int expectedResult = 1;

        Assertions.assertEquals(expectedResult, results);
    }
}

=== Chunk 1541 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1456.maximum-number-of-vowels-in-a-substring-of-given-length\MaximumNumberOfVowelsInASubstringOfGivenLength.java

class MaximumNumberOfVowelsInASubstringOfGivenLength {
    public int maxVowels(String s, int k) {
        int left = 0;
        int maxVowels = 0, currentVowels = 0;
        for (int i = 0; i < k; i++) {
            if (isVowel(s.charAt(i))) {
                currentVowels++;
            }
        }
        maxVowels = Math.max(maxVowels, currentVowels);
        for (int right = k; right < s.length(); right++) {
            if (isVowel(s.charAt(left))) {
                currentVowels--;
            }
            left++;
            if (isVowel(s.charAt(right))) {
                currentVowels++;
            }
            maxVowels = Math.max(maxVowels, currentVowels);
        }
        return maxVowels;
    }

    private boolean isVowel(char c) {

=== Chunk 1542 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1456.maximum-number-of-vowels-in-a-substring-of-given-length\MaximumNumberOfVowelsInASubstringOfGivenLength.java

}

    private boolean isVowel(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
    }
}

=== Chunk 1543 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1456.maximum-number-of-vowels-in-a-substring-of-given-length\MaximumNumberOfVowelsInASubstringOfGivenLengthTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1544 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1456.maximum-number-of-vowels-in-a-substring-of-given-length\MaximumNumberOfVowelsInASubstringOfGivenLengthTest.java

public class MaximumNumberOfVowelsInASubstringOfGivenLengthTest {
    MaximumNumberOfVowelsInASubstringOfGivenLength maximumNumberOfVowelsInASubstringOfGivenLength = new MaximumNumberOfVowelsInASubstringOfGivenLength();

    @Test
    void Example1() {
        String s = "abciiidef";
        int k = 3;

        Assertions.assertEquals(3, maximumNumberOfVowelsInASubstringOfGivenLength.maxVowels(s, k));
    }

    @Test
    void Example2() {
        String s = "aeiou";
        int k = 2;

        Assertions.assertEquals(2, maximumNumberOfVowelsInASubstringOfGivenLength.maxVowels(s, k));
    }

    @Test
    void Example3() {
        String s = "leetcode";
        int k = 3;

=== Chunk 1545 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1456.maximum-number-of-vowels-in-a-substring-of-given-length\MaximumNumberOfVowelsInASubstringOfGivenLengthTest.java

int k = 3;

        Assertions.assertEquals(2, maximumNumberOfVowelsInASubstringOfGivenLength.maxVowels(s, k));
    }

    @Test
    void Example4() {
        String s = "weallloveyou";
        int k = 7;

        Assertions.assertEquals(4, maximumNumberOfVowelsInASubstringOfGivenLength.maxVowels(s, k));
    }

    @Test
    void Example5() {
        String s = "ibpbhixfiouhdljnjfflpapptrxgcomvnb";
        int k = 33;

        Assertions.assertEquals(7, maximumNumberOfVowelsInASubstringOfGivenLength.maxVowels(s, k));
    }
}

=== Chunk 1546 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1457.pseudo-palindromic-paths-in-a-binary-tree\PseudoPalindromicPathsInABinaryTree.java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

=== Chunk 1547 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1457.pseudo-palindromic-paths-in-a-binary-tree\PseudoPalindromicPathsInABinaryTree.java

class PseudoPalindromicPathsInABinaryTree {
    private int count = 0;

    private void preorder(TreeNode node, int path) {
        if (node != null) {
            path = path ^ (1 << node.val);
            if (node.left == null && node.right == null) {
                if ((path & (path - 1)) == 0) {
                    count++;
                }
            }
            preorder(node.left, path);
            preorder(node.right, path);
        }
    }

    public int pseudoPalindromicPaths (TreeNode root) {
        preorder(root, 0);
        return count;
    }
}

=== Chunk 1548 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1457.pseudo-palindromic-paths-in-a-binary-tree\PseudoPalindromicPathsInABinaryTreeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1549 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1457.pseudo-palindromic-paths-in-a-binary-tree\PseudoPalindromicPathsInABinaryTreeTest.java

public class PseudoPalindromicPathsInABinaryTreeTest {
    PseudoPalindromicPathsInABinaryTree PseudoPalindromicPathsInABinaryTree = new PseudoPalindromicPathsInABinaryTree();

    @Test
    void Example1() {
        TreeNode root = new TreeNode(2);
        root.left = new TreeNode(3);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(1);
        root.right = new TreeNode(1);
        root.right.right = new TreeNode(1);
        int results = PseudoPalindromicPathsInABinaryTree.pseudoPalindromicPaths(root);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        TreeNode root = new TreeNode(2);
        root.left = new TreeNode(1);

=== Chunk 1550 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1457.pseudo-palindromic-paths-in-a-binary-tree\PseudoPalindromicPathsInABinaryTreeTest.java

root.left = new TreeNode(1);
        root.left.left = new TreeNode(1);
        root.left.right = new TreeNode(3);
        root.left.right.right = new TreeNode(1);
        root.right = new TreeNode(1);
        int results = PseudoPalindromicPathsInABinaryTree.pseudoPalindromicPaths(root);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1551 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1465.maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts\MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCuts.java

import java.util.Arrays;

=== Chunk 1552 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1465.maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts\MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCuts.java

class MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCuts {
    public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {
        Arrays.sort(horizontalCuts);
        Arrays.sort(verticalCuts);
        int mod = (int) Math.pow(10, 9) + 7;

        int maxH = Math.max(horizontalCuts[0], h - horizontalCuts[horizontalCuts.length - 1]);
        int maxW = Math.max(verticalCuts[0], w - verticalCuts[verticalCuts.length - 1]);

        for (int i = 1; i < horizontalCuts.length; i++) {
            maxH = Math.max(maxH, horizontalCuts[i] - horizontalCuts[i - 1]);
        }

        for (int i = 1; i < verticalCuts.length; i++) {
            maxW = Math.max(maxW, verticalCuts[i] - verticalCuts[i - 1]);
        }

=== Chunk 1553 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1465.maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts\MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCuts.java

}

        return (int) ((long) maxH * maxW % mod);
    }
}

=== Chunk 1554 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1465.maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts\MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCutsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1555 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1465.maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts\MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCutsTest.java

public class MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCutsTest {
    MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCuts MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCuts = new MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCuts();

    @Test
    void Example1() {
        int h = 5, w = 4;
        int[] horizontalCuts = {1, 2, 4}, verticalCuts = {1, 3};
        int results = MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCuts.maxArea(h, w, horizontalCuts, verticalCuts);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int h = 5, w = 4;
        int[] horizontalCuts = {3, 1},  verticalCuts = {1};

=== Chunk 1556 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1465.maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts\MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCutsTest.java

int results = MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCuts.maxArea(h, w, horizontalCuts, verticalCuts);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int h = 5, w = 4;
        int[] horizontalCuts = {3}, verticalCuts = {3};
        int results = MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCuts.maxArea(h, w, horizontalCuts, verticalCuts);
        int expectedResults = 9;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example4() {
        int h = 1000000000, w = 1000000000;
        int[] horizontalCuts = {2}, verticalCuts = {2};

=== Chunk 1557 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1465.maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts\MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCutsTest.java

int results = MaximumAreaOfAPieceOfCakeAfterHorizontalAndVerticalCuts.maxArea(h, w, horizontalCuts, verticalCuts);
        int expectedResults = 81;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1558 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1466.reorder-routes-to-make-all-paths-lead-to-the-city-zero\ReorderRoutesToMakeAllPathsLeadToTheCityZero.java

import java.util.*;

=== Chunk 1559 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1466.reorder-routes-to-make-all-paths-lead-to-the-city-zero\ReorderRoutesToMakeAllPathsLeadToTheCityZero.java

class ReorderRoutesToMakeAllPathsLeadToTheCityZero {
    public int minReorder(int n, int[][] connections) {
        List<Integer>[] adjacentArray = new List[n];
        for (int i = 0; i < n; i++) {
            adjacentArray[i] = new ArrayList<>();
        }
        for (int[] connection : connections) {
            adjacentArray[connection[0]].add(connection[1]);
            adjacentArray[connection[1]].add(connection[0]);
        }
        int[] levels = new int[n];
        Arrays.fill(levels, -1);
        levels[0] = 0;
        Queue<Integer> queue = new ArrayDeque<>();
        queue.offer(0);
        while (!queue.isEmpty()) {
            int city = queue.poll();
            List<Integer> adjacent = adjacentArray[city];
            for (int next : adjacent) {

=== Chunk 1560 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1466.reorder-routes-to-make-all-paths-lead-to-the-city-zero\ReorderRoutesToMakeAllPathsLeadToTheCityZero.java

for (int next : adjacent) {
                if (levels[next] < 0) {
                    levels[next] = levels[city] + 1;
                    queue.offer(next);
                }
            }
        }
        int res = 0;
        for (int[] connection : connections) {
            if (levels[connection[0]] < levels[connection[1]]) {
                res++;
            }
        }
        return res;
    }
}

=== Chunk 1561 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1466.reorder-routes-to-make-all-paths-lead-to-the-city-zero\ReorderRoutesToMakeAllPathsLeadToTheCityZeroTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1562 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1466.reorder-routes-to-make-all-paths-lead-to-the-city-zero\ReorderRoutesToMakeAllPathsLeadToTheCityZeroTest.java

public class ReorderRoutesToMakeAllPathsLeadToTheCityZeroTest {
    ReorderRoutesToMakeAllPathsLeadToTheCityZero reorderRoutesToMakeAllPathsLeadToTheCityZero = new ReorderRoutesToMakeAllPathsLeadToTheCityZero();

    @Test
    void Example1() {
        int n = 6;
        int[][] connections = {{0, 1}, {1, 3}, {2, 3}, {4, 0}, {4, 5}};

        Assertions.assertEquals(3, reorderRoutesToMakeAllPathsLeadToTheCityZero.minReorder(n, connections));
    }

    @Test
    void Example2() {
        int n = 5;
        int[][] connections = {{1, 0}, {1, 2}, {3, 2}, {3, 4}};

        Assertions.assertEquals(2, reorderRoutesToMakeAllPathsLeadToTheCityZero.minReorder(n, connections));
    }

    @Test
    void Example3() {
        int n = 3;

=== Chunk 1563 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1466.reorder-routes-to-make-all-paths-lead-to-the-city-zero\ReorderRoutesToMakeAllPathsLeadToTheCityZeroTest.java

void Example3() {
        int n = 3;
        int[][] connections = {{1, 0}, {2, 0}};

        Assertions.assertEquals(0, reorderRoutesToMakeAllPathsLeadToTheCityZero.minReorder(n, connections));
    }
}

=== Chunk 1564 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1470.shuffle-the-array\ShuffleTheArray.java

class ShuffleTheArray {
    public int[] shuffle(int[] nums, int n) {
        int[] res = new int[2 * n];
        for (int i = 0; i < n; i++) {
            res[2 * i] = nums[i];
            res[2 * i + 1] = nums[i + n];
        }
        return res;
    }
}

=== Chunk 1565 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1470.shuffle-the-array\ShuffleTheArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1566 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1470.shuffle-the-array\ShuffleTheArrayTest.java

public class ShuffleTheArrayTest {
    ShuffleTheArray shuffleTheArray = new ShuffleTheArray();

    @Test
    void Example1() {
        int[] nums = {2, 5, 1, 3, 4, 7};
        int n = 3;

        Assertions.assertArrayEquals(new int[]{2, 3, 5, 4, 1, 7}, shuffleTheArray.shuffle(nums, n));
    }

    @Test
    void Example2() {
        int[] nums = {1, 2, 3, 4, 4, 3, 2, 1};
        int n = 4;

        Assertions.assertArrayEquals(new int[]{1, 4, 2, 3, 3, 2, 4, 1}, shuffleTheArray.shuffle(nums, n));
    }

    @Test
    void Example3() {
        int[] nums = {1,1,2,2};
        int n = 2;

        Assertions.assertArrayEquals(new int[]{1, 2, 1, 2}, shuffleTheArray.shuffle(nums, n));
    }
}

=== Chunk 1567 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1472.design-browser-history\DesignBrowserHistory.java

import java.util.Deque;
import java.util.LinkedList;

=== Chunk 1568 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1472.design-browser-history\DesignBrowserHistory.java

class BrowserHistory {
    Deque<String> s1 = new LinkedList<>();
    Deque<String> s2 = new LinkedList<>();

    public BrowserHistory(String homepage) {
        s1.push(homepage);
    }
    
    public void visit(String url) {
        s1.push(url);
        s2.clear();
    }
    
    public String back(int steps) {
        for (int i = 0; i < steps && s1.size() > 1; i++) {
            s2.push(s1.pop());
        }
        return s1.peek();
    }
    
    public String forward(int steps) {
        for (int i = 0; i < steps && !s2.isEmpty(); i++) {
            s1.push(s2.pop());
        }
        return s1.peek();
    }
}

/**
 * Your BrowserHistory object will be instantiated and called as such:
 * BrowserHistory obj = new BrowserHistory(homepage);

=== Chunk 1569 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1472.design-browser-history\DesignBrowserHistory.java

* obj.visit(url);
 * String param_2 = obj.back(steps);
 * String param_3 = obj.forward(steps);
 */

=== Chunk 1570 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1472.design-browser-history\DesignBrowserHistoryTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1571 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1472.design-browser-history\DesignBrowserHistoryTest.java

public class DesignBrowserHistoryTest {
    @Test
    void Example1() {
        BrowserHistory browserHistory = new BrowserHistory("leetcode.com");
        browserHistory.visit("google.com");
        browserHistory.visit("facebook.com");
        browserHistory.visit("youtube.com");
        Assertions.assertEquals("facebook.com", browserHistory.back(1));
        Assertions.assertEquals("google.com", browserHistory.back(1));
        Assertions.assertEquals("facebook.com", browserHistory.forward(1));
        browserHistory.visit("linkedin.com");
        Assertions.assertEquals("linkedin.com", browserHistory.forward(2));
        Assertions.assertEquals("google.com", browserHistory.back(2));
        Assertions.assertEquals("leetcode.com", browserHistory.back(7));

=== Chunk 1572 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1472.design-browser-history\DesignBrowserHistoryTest.java

browserHistory.back(7);
    }
}

=== Chunk 1573 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1473.paint-house-iii\PaintHouseIii.java

class PaintHouseIii {
    private int help(int i, int t, int l, int[] houses, int[][] cost, int m, int n, int target, int[][][] dp) {
        if (t > target) return Integer.MAX_VALUE / 2;
        if (i == m) return t == target ? 0 : Integer.MAX_VALUE / 2;
        if (dp[i][t][l] != -1) return dp[i][t][l];
        else {
            int ans = Integer.MAX_VALUE / 2;
            if (houses[i] == 0) {
                for (int j = 0; j < n; j++) {
                    ans = Math.min(ans, cost[i][j] + help(i + 1, l == j + 1 ? t : t + 1, j + 1, houses, cost, m, n, target, dp));
                }
            } else {
                ans = Math.min(ans, help(i + 1, l == houses[i] ? t : t + 1, houses[i], houses, cost, m, n, target, dp));
            }

=== Chunk 1574 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1473.paint-house-iii\PaintHouseIii.java

}
            return dp[i][t][l] = ans;
        }
    }

    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {
        int[][][] dp = new int[m][m + 1][n + 1];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= m; j++) {
                for (int k = 0; k <= n; k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        int ans = help(0, 0, 0, houses, cost, m, n, target, dp);
        return (ans == Integer.MAX_VALUE / 2) ? -1 : ans;
    }
}

=== Chunk 1575 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1473.paint-house-iii\PaintHouseIiiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1576 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1473.paint-house-iii\PaintHouseIiiTest.java

public class PaintHouseIiiTest {
    PaintHouseIii PaintHouseIii = new PaintHouseIii();

    @Test
    void Example1() {
        int[] houses = {0, 0, 0, 0, 0};
        int[][] cost = {{1, 10}, {10, 1}, {10, 1}, {1, 10}, {5, 1}};
        int m = 5, n = 2, target = 3;
        int results = PaintHouseIii.minCost(houses, cost, m, n, target);
        int expectedResults = 9;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] houses = {0, 2, 1, 2, 0};
        int[][] cost = {{1, 10}, {10, 1}, {10, 1}, {1, 10}, {5, 1}};
        int m = 5, n = 2, target = 3;
        int results = PaintHouseIii.minCost(houses, cost, m, n, target);
        int expectedResults = 11;

=== Chunk 1577 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1473.paint-house-iii\PaintHouseIiiTest.java

int expectedResults = 11;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] houses = {3, 1, 2, 3};
        int[][] cost = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}};
        int m = 4, n = 3, target = 3;
        int results = PaintHouseIii.minCost(houses, cost, m, n, target);
        int expectedResults = -1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1578 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1480.running-sum-of-1d-array\RunningSumOf1dArray.java

class RunningSumOf1dArray {
    public int[] runningSum(int[] nums) {
        for (int i = 1; i < nums.length; i++) {
            nums[i] = nums[i] + nums[i - 1];
        }
        return nums;
    }
}

=== Chunk 1579 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1480.running-sum-of-1d-array\RunningSumOf1dArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1580 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1480.running-sum-of-1d-array\RunningSumOf1dArrayTest.java

public class RunningSumOf1dArrayTest {
    RunningSumOf1dArray RunningSumOf1dArray = new RunningSumOf1dArray();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3, 4};
        int[] results = RunningSumOf1dArray.runningSum(nums);
        int[] expectedResults = {1, 3, 6, 10};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {1, 1, 1, 1, 1};
        int[] results = RunningSumOf1dArray.runningSum(nums);
        int[] expectedResults = {1, 2, 3, 4, 5};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {3, 1, 2, 10, 1};
        int[] results = RunningSumOf1dArray.runningSum(nums);

=== Chunk 1581 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1480.running-sum-of-1d-array\RunningSumOf1dArrayTest.java

int[] expectedResults = {3, 4, 6, 16, 17};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 1582 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1491.average-salary-excluding-the-minimum-and-maximum-salary\AverageSalaryExcludingTheMinimumAndMaximumSalary.java

class AverageSalaryExcludingTheMinimumAndMaximumSalary {
    public double average(int[] salary) {
        double max = Integer.MIN_VALUE;
        double min = Integer.MAX_VALUE;
        double sum = 0, count = salary.length - 2;
        for (int s: salary) {
            if (s > max) {
                max = s;
            }
            if (s < min) {
                min = s;
            }
            sum += s;
        }
        return (sum - min - max) / count;
    }
}

=== Chunk 1583 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1491.average-salary-excluding-the-minimum-and-maximum-salary\AverageSalaryExcludingTheMinimumAndMaximumSalaryTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class AverageSalaryExcludingTheMinimumAndMaximumSalaryTest {
    AverageSalaryExcludingTheMinimumAndMaximumSalary averageSalaryExcludingTheMinimumAndMaximumSalary = new AverageSalaryExcludingTheMinimumAndMaximumSalary();

    @Test
    void Example1() {
        int[] salary = {4000, 3000, 1000, 2000};

        Assertions.assertEquals(2500.00, averageSalaryExcludingTheMinimumAndMaximumSalary.average(salary));
    }

    @Test
    void Example2() {
        int[] salary = {1000, 2000, 3000};

        Assertions.assertEquals(2000.00, averageSalaryExcludingTheMinimumAndMaximumSalary.average(salary));
    }
}

=== Chunk 1584 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1498.number-of-subsequences-that-satisfy-the-given-sum-condition\NumberOfSubsequencesThatSatisfyTheGivenSumCondition.java

import java.util.Arrays;

class NumberOfSubsequencesThatSatisfyTheGivenSumCondition {
    static final int modulo = (int) Math.pow(10, 9) + 7;

    public int numSubseq(int[] nums, int target) {
        Arrays.sort(nums);
        int[] tmp = new int[nums.length];
        tmp[0] = 1;
        for (int i = 1; i < nums.length; i++) {
            tmp[i] = (tmp[i - 1] * 2) % modulo;
        }
        int res = 0;
        int l = 0, r = nums.length - 1;
        while (l <= r) {
            if (nums[l] + nums[r] > target) {
                r--;
            } else {
                res = (res + tmp[r - l]) % modulo;
                l++;
            }
        }
        return res;
    }
}

=== Chunk 1585 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1498.number-of-subsequences-that-satisfy-the-given-sum-condition\NumberOfSubsequencesThatSatisfyTheGivenSumConditionTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1586 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1498.number-of-subsequences-that-satisfy-the-given-sum-condition\NumberOfSubsequencesThatSatisfyTheGivenSumConditionTest.java

public class NumberOfSubsequencesThatSatisfyTheGivenSumConditionTest {
    NumberOfSubsequencesThatSatisfyTheGivenSumCondition numberOfSubsequencesThatSatisfyTheGivenSumCondition = new NumberOfSubsequencesThatSatisfyTheGivenSumCondition();

    @Test
    void Example1() {
        int[] nums = {3, 5, 6, 7};
        int target = 9;

        Assertions.assertEquals(4, numberOfSubsequencesThatSatisfyTheGivenSumCondition.numSubseq(nums, target));
    }

    @Test
    void Example2() {
        int[] nums = {3, 3, 6, 8};
        int target = 10;

        Assertions.assertEquals(6, numberOfSubsequencesThatSatisfyTheGivenSumCondition.numSubseq(nums, target));
    }

    @Test
    void Example3() {
        int[] nums = {2, 3, 3, 4, 6, 7};
        int target = 12;

=== Chunk 1587 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1498.number-of-subsequences-that-satisfy-the-given-sum-condition\NumberOfSubsequencesThatSatisfyTheGivenSumConditionTest.java

int target = 12;

        Assertions.assertEquals(61, numberOfSubsequencesThatSatisfyTheGivenSumCondition.numSubseq(nums, target));
    }
}

=== Chunk 1588 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1523.count-odd-numbers-in-an-interval-range\CountOddNumbersInAnIntervalRange.java

class CountOddNumbersInAnIntervalRange {
    public int countOdds(int low, int high) {
        if ((low & 1) == 0)
            low++;
        return low > high ? 0 : (high - low) / 2 + 1;
    }
}

=== Chunk 1589 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1523.count-odd-numbers-in-an-interval-range\CountOddNumbersInAnIntervalRangeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class CountOddNumbersInAnIntervalRangeTest {
    CountOddNumbersInAnIntervalRange countOddNumbersInAnIntervalRange = new CountOddNumbersInAnIntervalRange();

    @Test
    void Example1() {
        int low = 3, high = 7;

        Assertions.assertEquals(3, countOddNumbersInAnIntervalRange.countOdds(low, high));
    }

    @Test
    void Example2() {
        int low = 8, high = 10;

        Assertions.assertEquals(1, countOddNumbersInAnIntervalRange.countOdds(low, high));
    }
}

=== Chunk 1590 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1531.string-compression-ii\StringCompressionIi.java

import java.util.Arrays;

=== Chunk 1591 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1531.string-compression-ii\StringCompressionIi.java

class StringCompressionIi {
    public int getLengthOfOptimalCompression(String s, int k) {
        int n = s.length();
        int[][] dp = new int[110][110];
        for (int[] d : dp)
            Arrays.fill(d, 9999);

        dp[0][0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                int cnt = 0, del = 0;
                for (int l = i; l >= 1; l--) {
                    if (s.charAt(l - 1) == s.charAt(i - 1)) cnt++;
                    else del++;
                    if (j - del >= 0) {
                        dp[i][j] = Math.min(dp[i][j], dp[l - 1][j - del] + 1 + (cnt >= 100 ? 3 : cnt >= 10 ? 2 : cnt >= 2 ? 1 : 0));
                    }
                }
                if (j > 0) {

=== Chunk 1592 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1531.string-compression-ii\StringCompressionIi.java

}
                if (j > 0) {
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
                }
            }
        }
        return dp[n][k];
    }
}

=== Chunk 1593 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1531.string-compression-ii\StringCompressionIiTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1594 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1531.string-compression-ii\StringCompressionIiTest.java

public class StringCompressionIiTest {
    StringCompressionIi StringCompressionIi = new StringCompressionIi();

    @Test
    void Example1() {
        String s = "aaabcccd";
        int k = 2;
        int results = StringCompressionIi.getLengthOfOptimalCompression(s, k);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "aabbaa";
        int k = 2;
        int results = StringCompressionIi.getLengthOfOptimalCompression(s, k);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "aaaaaaaaaaa";
        int k = 0;

=== Chunk 1595 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1531.string-compression-ii\StringCompressionIiTest.java

int k = 0;
        int results = StringCompressionIi.getLengthOfOptimalCompression(s, k);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1596 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1539.kth-missing-positive-number\KthMissingPositiveNumber.java

class KthMissingPositiveNumber {
    public int findKthPositive(int[] arr, int k) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] <= k)
                k++;
        }
        return k;
    }
}

=== Chunk 1597 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1539.kth-missing-positive-number\KthMissingPositiveNumberTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class KthMissingPositiveNumberTest {
    KthMissingPositiveNumber kthMissingPositiveNumber = new KthMissingPositiveNumber();

    @Test
    void Example1() {
        int[] arr = {2, 3, 4, 7, 11};
        int k = 5;

        Assertions.assertEquals(9, kthMissingPositiveNumber.findKthPositive(arr, k));
    }

    @Test
    void Example2() {
        int[] arr = {1, 2, 3, 4};
        int k = 2;

        Assertions.assertEquals(6, kthMissingPositiveNumber.findKthPositive(arr, k));
    }
}

=== Chunk 1598 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1544.make-the-string-great\MakeTheStringGreat.java

import java.util.Stack;

class MakeTheStringGreat {
    public String makeGood(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (!stack.isEmpty() && Math.abs(stack.peek() - c) == 32) {
                stack.pop();
            } else {
                stack.push(c);
            }
        }

        StringBuilder ans = new StringBuilder();
        for (char c : stack)
            ans.append(c);
        return ans.toString();
    }
}

=== Chunk 1599 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1544.make-the-string-great\MakeTheStringGreatTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1600 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1544.make-the-string-great\MakeTheStringGreatTest.java

public class MakeTheStringGreatTest {
    MakeTheStringGreat MakeTheStringGreat = new MakeTheStringGreat();

    @Test
    void Example1() {
        String s = "leEeetcode";
        String results = MakeTheStringGreat.makeGood(s);
        String expectedResults = "leetcode";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String s = "abBAcC";
        String results = MakeTheStringGreat.makeGood(s);
        String expectedResults = "";

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        String s = "s";
        String results = MakeTheStringGreat.makeGood(s);
        String expectedResults = "s";

=== Chunk 1601 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1544.make-the-string-great\MakeTheStringGreatTest.java

String expectedResults = "s";

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1602 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1572.matrix-diagonal-sum\MatrixDiagonalSum.java

class MatrixDiagonalSum {
    public int diagonalSum(int[][] mat) {
        int sum = 0;
        int n = mat.length;
        for (int i = 0; i < n; i++) {
            sum += mat[i][i];
        }
        for (int i = n - 1; i >= 0; i--) {
            sum += mat[i][n - 1 - i];
        }
        if (n % 2 == 0) {
            return sum;
        } else {
            int index = n / 2;
            sum -= mat[index][index];
        }
        return sum;
    }
}

=== Chunk 1603 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1572.matrix-diagonal-sum\MatrixDiagonalSumTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1604 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1572.matrix-diagonal-sum\MatrixDiagonalSumTest.java

public class MatrixDiagonalSumTest {
    MatrixDiagonalSum matrixDiagonalSum = new MatrixDiagonalSum();

    @Test
    void Example1() {
        int[][] mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

        Assertions.assertEquals(25, matrixDiagonalSum.diagonalSum(mat));
    }

    @Test
    void Example2() {
        int[][] mat = {{1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}};

        Assertions.assertEquals(8, matrixDiagonalSum.diagonalSum(mat));
    }

    @Test
    void Example3() {
        int[][] mat = {{5}};

        Assertions.assertEquals(5, matrixDiagonalSum.diagonalSum(mat));
    }

    @Test
    void Example4() {
        int[][] mat = {{7, 3, 1, 9}, {3, 4, 6, 9}, {6, 9, 6, 6}, {9, 5, 8, 5}};

=== Chunk 1605 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1572.matrix-diagonal-sum\MatrixDiagonalSumTest.java

Assertions.assertEquals(55, matrixDiagonalSum.diagonalSum(mat));
    }
}

=== Chunk 1606 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1578.minimum-time-to-make-rope-colorful\MinimumTimeToMakeRopeColorful.java

class MinimumTimeToMakeRopeColorful {
    public int minCost(String colors, int[] neededTime) {
        int totalTime = 0;
        int l = 0, r = 0;
        while (l < neededTime.length) {
            int currTotal = 0, currMax = 0;
            while (r < neededTime.length && colors.charAt(l) == colors.charAt(r)) {
                currTotal += neededTime[r];
                currMax = Math.max(currMax, neededTime[r]);
                r++;
            }
            totalTime += currTotal - currMax;
            l = r;
        }
        return totalTime;
    }
}

=== Chunk 1607 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1578.minimum-time-to-make-rope-colorful\MinimumTimeToMakeRopeColorfulTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1608 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1578.minimum-time-to-make-rope-colorful\MinimumTimeToMakeRopeColorfulTest.java

public class MinimumTimeToMakeRopeColorfulTest {
    MinimumTimeToMakeRopeColorful MinimumTimeToMakeRopeColorful = new MinimumTimeToMakeRopeColorful();

    @Test
    void Example1() {
        String colors = "abaac";
        int[] neededTime = {1, 2, 3, 4, 5};
        int results = MinimumTimeToMakeRopeColorful.minCost(colors, neededTime);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String colors = "abc";
        int[] neededTime = {1, 2, 3};
        int results = MinimumTimeToMakeRopeColorful.minCost(colors, neededTime);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 1609 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1578.minimum-time-to-make-rope-colorful\MinimumTimeToMakeRopeColorfulTest.java

}

    @Test
    void Example3() {
        String colors = "aabaa";
        int[] neededTime = {1, 2, 3, 4, 1};
        int results = MinimumTimeToMakeRopeColorful.minCost(colors, neededTime);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1610 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1626.best-team-with-no-conflicts\BestTeamWithNoConflicts.java

import java.util.Arrays;

=== Chunk 1611 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1626.best-team-with-no-conflicts\BestTeamWithNoConflicts.java

class BestTeamWithNoConflicts {
    public int bestTeamScore(int[] scores, int[] ages) {
        int n = scores.length;
        Integer[] order = new Integer[n];
        for (int i = 0; i < n; i++)
            order[i] = i;
        Arrays.sort(order, (a, b) -> ages[a] == ages[b] ? scores[a] - scores[b] : ages[a] - ages[b]);
        int[] dp = new int[n];
        int res = 0;
        for (int i = 0; i < dp.length; i++) {
            int currI = order[i];
            dp[i] = scores[currI];
            for (int j = 0; j < i; j++) {
                int currJ = order[j];
                if (scores[currI] >= scores[currJ])
                    dp[i] = Math.max(dp[i], dp[j] + scores[currI]);
            }
            res = Math.max(res, dp[i]);
        }
        return res;

=== Chunk 1612 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1626.best-team-with-no-conflicts\BestTeamWithNoConflicts.java

}
        return res;
    }
}

=== Chunk 1613 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1626.best-team-with-no-conflicts\BestTeamWithNoConflictsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1614 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1626.best-team-with-no-conflicts\BestTeamWithNoConflictsTest.java

public class BestTeamWithNoConflictsTest {
    BestTeamWithNoConflicts bestTeamWithNoConflicts = new BestTeamWithNoConflicts();

    @Test
    void Example1() {
        int[] scores = {1, 3, 5, 10, 15},  ages = {1, 2, 3, 4, 5};

        Assertions.assertEquals(34, bestTeamWithNoConflicts.bestTeamScore(scores, ages));
    }

    @Test
    void Example2() {
        int[] scores = {4, 5, 6, 5}, ages = {2, 1, 2, 1};

        Assertions.assertEquals(16, bestTeamWithNoConflicts.bestTeamScore(scores, ages));
    }

    @Test
    void Example3() {
        int[] scores = {1, 2, 3, 5}, ages = {8, 9, 10, 1};

        Assertions.assertEquals(6, bestTeamWithNoConflicts.bestTeamScore(scores, ages));
    }
}

=== Chunk 1615 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1642.furthest-building-you-can-reach\FurthestBuildingYouCanReach.java

import java.util.PriorityQueue;

class FurthestBuildingYouCanReach {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int i = 0; i < heights.length - 1; i++) {
            int diff = heights[i + 1] - heights[i];
            if (diff <= 0) continue;
            minHeap.offer(diff);
            if (minHeap.size() > ladders && minHeap.peek() != null) {
                bricks -= minHeap.poll();
            }
            if (bricks < 0) return i;
        }
        return heights.length - 1;
    }
}

=== Chunk 1616 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1642.furthest-building-you-can-reach\FurthestBuildingYouCanReachTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1617 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1642.furthest-building-you-can-reach\FurthestBuildingYouCanReachTest.java

public class FurthestBuildingYouCanReachTest {
    FurthestBuildingYouCanReach FurthestBuildingYouCanReach = new FurthestBuildingYouCanReach();

    @Test
    void Example1() {
        int[] heights = {4, 2, 7, 6, 9, 14, 12};
        int bricks = 5, ladders = 1;
        int results = FurthestBuildingYouCanReach.furthestBuilding(heights, bricks, ladders);
        int expectedResults = 4;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] heights = {4, 12, 2, 7, 3, 18, 20, 3, 19};
        int bricks = 10, ladders = 2;
        int results = FurthestBuildingYouCanReach.furthestBuilding(heights, bricks, ladders);
        int expectedResults = 7;

        Assertions.assertEquals(expectedResults, results);
    }

=== Chunk 1618 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1642.furthest-building-you-can-reach\FurthestBuildingYouCanReachTest.java

}

    @Test
    void Example3() {
        int[] heights = {14, 3, 19, 3};
        int bricks = 17, ladders = 0;
        int results = FurthestBuildingYouCanReach.furthestBuilding(heights, bricks, ladders);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1619 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1647.minimum-deletions-to-make-character-frequencies-unique\MinimumDeletionsToMakeCharacterFrequenciesUnique.java

import java.util.HashSet;
import java.util.Set;

class MinimumDeletionsToMakeCharacterFrequenciesUnique {
    public int minDeletions(String s) {
        int[] freq = new int[26];
        for (char c : s.toCharArray()) {
            freq[c - 'a']++;
        }
        Set<Integer> set = new HashSet<>();
        int deletions = 0;
        for (int f : freq) {
            if (f == 0) {
                continue;
            }
            while (f > 0 && set.contains(f)) {
                f--;
                deletions++;
            }
            set.add(f);
        }

        return deletions;
    }
}

=== Chunk 1620 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1647.minimum-deletions-to-make-character-frequencies-unique\MinimumDeletionsToMakeCharacterFrequenciesUniqueTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1621 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1647.minimum-deletions-to-make-character-frequencies-unique\MinimumDeletionsToMakeCharacterFrequenciesUniqueTest.java

public class MinimumDeletionsToMakeCharacterFrequenciesUniqueTest {
    MinimumDeletionsToMakeCharacterFrequenciesUnique MinimumDeletionsToMakeCharacterFrequenciesUnique = new MinimumDeletionsToMakeCharacterFrequenciesUnique();

    @Test
    void Example1() {
        String n = "aab";
        int results = MinimumDeletionsToMakeCharacterFrequenciesUnique.minDeletions(n);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String n = "aaabbbcc";
        int results = MinimumDeletionsToMakeCharacterFrequenciesUnique.minDeletions(n);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 1622 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1647.minimum-deletions-to-make-character-frequencies-unique\MinimumDeletionsToMakeCharacterFrequenciesUniqueTest.java

}

    @Test
    void Example3() {
        String n = "ceabaacb";
        int results = MinimumDeletionsToMakeCharacterFrequenciesUnique.minDeletions(n);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1623 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1657.determine-if-two-strings-are-close\DetermineIfTwoStringsAreClose.java

import java.util.Arrays;

class DetermineIfTwoStringsAreClose {
    public boolean closeStrings(String word1, String word2) {
        if (word1.length() != word2.length())
            return false;

        int[] arr1 = new int[26];
        int[] arr2 = new int[26];
        for (int i = 0; i < word1.length(); i++) {
            arr1[word1.charAt(i) - 'a']++;
            arr2[word2.charAt(i) - 'a']++;
        }

        for (int i = 0; i < 26; i++) {
            if ((arr1[i] == 0 && arr2[i] != 0) || (arr1[i] != 0 && arr2[i] == 0))
                return false;
        }

        Arrays.sort(arr1);
        Arrays.sort(arr2);
        return Arrays.equals(arr1, arr2);
    }
}

=== Chunk 1624 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1657.determine-if-two-strings-are-close\DetermineIfTwoStringsAreCloseTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1625 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1657.determine-if-two-strings-are-close\DetermineIfTwoStringsAreCloseTest.java

public class DetermineIfTwoStringsAreCloseTest {
    DetermineIfTwoStringsAreClose determineIfTwoStringsAreClose = new DetermineIfTwoStringsAreClose();

    @Test
    void Example1() {
        String word1 = "abc", word2 = "bca";
        boolean results = determineIfTwoStringsAreClose.closeStrings(word1, word2);

        Assertions.assertTrue(results);
    }

    @Test
    void Example2() {
        String word1 = "a", word2 = "aa";
        boolean results = determineIfTwoStringsAreClose.closeStrings(word1, word2);

        Assertions.assertFalse(results);
    }

    @Test
    void Example3() {
        String word1 = "cabbba", word2 = "abbccc";
        boolean results = determineIfTwoStringsAreClose.closeStrings(word1, word2);

=== Chunk 1626 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1657.determine-if-two-strings-are-close\DetermineIfTwoStringsAreCloseTest.java

Assertions.assertTrue(results);
    }
}

=== Chunk 1627 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1662.check-if-two-string-arrays-are-equivalent\CheckIfTwoStringArraysAreEquivalent.java

class CheckIfTwoStringArraysAreEquivalent {
    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {
        return String.join("", word1).equals(String.join("", word2));
    }
}

=== Chunk 1628 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1662.check-if-two-string-arrays-are-equivalent\CheckIfTwoStringArraysAreEquivalentTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1629 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1662.check-if-two-string-arrays-are-equivalent\CheckIfTwoStringArraysAreEquivalentTest.java

public class CheckIfTwoStringArraysAreEquivalentTest {
    CheckIfTwoStringArraysAreEquivalent CheckIfTwoStringArraysAreEquivalent = new CheckIfTwoStringArraysAreEquivalent();

    @Test
    void Example1() {
        String[] word1 = {"ab", "c"}, word2 = {"a", "bc"};
        boolean results = CheckIfTwoStringArraysAreEquivalent.arrayStringsAreEqual(word1, word2);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String[] word1 = {"a", "cb"}, word2 = {"ab", "c"};
        boolean results = CheckIfTwoStringArraysAreEquivalent.arrayStringsAreEqual(word1, word2);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }

=== Chunk 1630 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1662.check-if-two-string-arrays-are-equivalent\CheckIfTwoStringArraysAreEquivalentTest.java

}

    @Test
    void Example3() {
        String[] word1 = {"abc", "d", "defg"}, word2 = {"abcddefg"};
        boolean results = CheckIfTwoStringArraysAreEquivalent.arrayStringsAreEqual(word1, word2);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1631 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1675.minimize-deviation-in-array\MinimizeDeviationInArray.java

import java.util.TreeSet;

class MinimizeDeviationInArray {
    public int minimumDeviation(int[] nums) {
        TreeSet<Integer> set = new TreeSet<>();
        for (int num : nums) {
            set.add(num % 2 == 0 ? num : num * 2);
        }
        int res = set.last() - set.first();
        while (res > 0 && set.last() % 2 == 0) {
            int max = set.last();
            set.remove(max);
            set.add(max / 2);
            res = Math.min(res, set.last() - set.first());
        }
        return res;
    }
}

=== Chunk 1632 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1675.minimize-deviation-in-array\MinimizeDeviationInArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MinimizeDeviationInArrayTest {
    MinimizeDeviationInArray minimizeDeviationInArray = new MinimizeDeviationInArray();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3, 4};

        Assertions.assertEquals(1, minimizeDeviationInArray.minimumDeviation(nums));
    }

    @Test
    void Example2() {
        int[] nums = {4, 1, 5, 20, 3};

        Assertions.assertEquals(3, minimizeDeviationInArray.minimumDeviation(nums));
    }

    @Test
    void Example3() {
        int[] nums = {2, 10, 8};

        Assertions.assertEquals(3, minimizeDeviationInArray.minimumDeviation(nums));
    }
}

=== Chunk 1633 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1680.concatenation-of-consecutive-binary-numbers\ConcatenationOfConsecutiveBinaryNumbers.java

class ConcatenationOfConsecutiveBinaryNumbers {
    private final int modulo = (int) Math.pow(10, 9) + 7;

    public int concatenatedBinary(int n) {
        long res = 0;
        for (int i = 0; i <= n; i++) {
            int temp = i;
            while (temp > 0) {
                temp /= 2;
                res *= 2;
            }
            res = (res + i) % modulo;
        }
        return (int) res;
    }
}

=== Chunk 1634 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1680.concatenation-of-consecutive-binary-numbers\ConcatenationOfConsecutiveBinaryNumbersTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1635 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1680.concatenation-of-consecutive-binary-numbers\ConcatenationOfConsecutiveBinaryNumbersTest.java

public class ConcatenationOfConsecutiveBinaryNumbersTest {
    ConcatenationOfConsecutiveBinaryNumbers ConcatenationOfConsecutiveBinaryNumbers = new ConcatenationOfConsecutiveBinaryNumbers();

    @Test
    void Example1() {
        int n = 1;
        int results = ConcatenationOfConsecutiveBinaryNumbers.concatenatedBinary(n);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int n = 3;
        int results = ConcatenationOfConsecutiveBinaryNumbers.concatenatedBinary(n);
        int expectedResults = 27;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int n = 12;

=== Chunk 1636 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1680.concatenation-of-consecutive-binary-numbers\ConcatenationOfConsecutiveBinaryNumbersTest.java

void Example3() {
        int n = 12;
        int results = ConcatenationOfConsecutiveBinaryNumbers.concatenatedBinary(n);
        int expectedResults = 505379714;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1637 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1689.partitioning-into-minimum-number-of-deci-binary-numbers\PartitioningIntoMinimumNumberOfDeciBinaryNumbers.java

class PartitioningIntoMinimumNumberOfDeciBinaryNumbers {
    public int minPartitions(String n) {
        int m = 0;
        char[] chars = n.toCharArray();
        for (char c : chars) {
            if (c - '0' > m) {
                m = c - '0';
            }
        }
        return m;
    }
}

=== Chunk 1638 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1689.partitioning-into-minimum-number-of-deci-binary-numbers\PartitioningIntoMinimumNumberOfDeciBinaryNumbersTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1639 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1689.partitioning-into-minimum-number-of-deci-binary-numbers\PartitioningIntoMinimumNumberOfDeciBinaryNumbersTest.java

public class PartitioningIntoMinimumNumberOfDeciBinaryNumbersTest {
    PartitioningIntoMinimumNumberOfDeciBinaryNumbers PartitioningIntoMinimumNumberOfDeciBinaryNumbers = new PartitioningIntoMinimumNumberOfDeciBinaryNumbers();

    @Test
    void Example1() {
        String n = "32";
        int results = PartitioningIntoMinimumNumberOfDeciBinaryNumbers.minPartitions(n);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String n = "82734";
        int results = PartitioningIntoMinimumNumberOfDeciBinaryNumbers.minPartitions(n);
        int expectedResults = 8;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 1640 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1689.partitioning-into-minimum-number-of-deci-binary-numbers\PartitioningIntoMinimumNumberOfDeciBinaryNumbersTest.java

}

    @Test
    void Example3() {
        String n = "27346209830709182346";
        int results = PartitioningIntoMinimumNumberOfDeciBinaryNumbers.minPartitions(n);
        int expectedResults = 9;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1641 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1696.jump-game-vi\JumpGameVi.java

import java.util.PriorityQueue;
import java.util.Queue;

class JumpGameVi {
    public int maxResult(int[] nums, int k) {
        if (nums.length == 0) return 0;
        Queue<int[]> pq = new PriorityQueue<>((a, b) -> (b[0] - a[0]));
        pq.offer(new int[]{nums[0], 0});

        int max = nums[0];

        for (int i = 1; i < nums.length; i++) {
            while(pq.peek()[1] < i - k) {
                pq.poll();
            }
            int[] cur = pq.peek();
            max = cur[0] + nums[i];
            pq.offer(new int[]{max, i});
        }
        return max;
    }
}

=== Chunk 1642 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1696.jump-game-vi\JumpGameVi2.java

class JumpGameVi2 {
    public int maxResult(int[] nums, int k) {
        if (nums.length == 1) return nums[0];
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Integer.MIN_VALUE;
        }
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length && j <= i + k; j++) {
                int nextNum = dp[i] + nums[j];
                if (dp[j] < nextNum) dp[j] = nextNum;
                if (dp[j] >= dp[i]) break;
            }
        }
        return dp[nums.length - 1];
    }
}

=== Chunk 1643 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1696.jump-game-vi\JumpGameViTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1644 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1696.jump-game-vi\JumpGameViTest.java

public class JumpGameViTest {
    JumpGameVi JumpGameVi = new JumpGameVi();
    JumpGameVi2 JumpGameVi2 = new JumpGameVi2();

    @Test
    void Example1() {
        int[] nums = {1, -1, -2, 4, -7, 3};
        int k = 2;
        int results = JumpGameVi.maxResult(nums, k);
        int expectedResults = 7;

        Assertions.assertEquals(expectedResults, results);

        results = JumpGameVi2.maxResult(nums, k);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {10, -5, -2, 4, 0, 3};
        int k = 3;
        int results = JumpGameVi.maxResult(nums, k);
        int expectedResults = 17;

        Assertions.assertEquals(expectedResults, results);

=== Chunk 1645 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1696.jump-game-vi\JumpGameViTest.java

results = JumpGameVi2.maxResult(nums, k);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] nums = {1, -5, -20, 4, -1, 3, -6, -3};
        int k = 2;
        int results = JumpGameVi.maxResult(nums, k);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);

        results = JumpGameVi2.maxResult(nums, k);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1646 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1704.determine-if-string-halves-are-alike\DetermineIfStringHalvesAreAlike.java

class DetermineIfStringHalvesAreAlike {
    public boolean halvesAreAlike(String s) {
        String left = s.substring(0, s.length() / 2);
        String right = s.substring(s.length() / 2);
        String v = "aeiouAEIOU";
        int leftSum = 0, rightSum = 0;
        for (int i = 0; i < left.length(); i++)
            if (v.indexOf(left.charAt(i)) >= 0)
                leftSum++;
        for (int i = 0; i < right.length(); i++)
            if (v.indexOf(right.charAt(i)) >= 0)
                rightSum++;
        return leftSum == rightSum;
    }
}

=== Chunk 1647 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1704.determine-if-string-halves-are-alike\DetermineIfStringHalvesAreAlikeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class DetermineIfStringHalvesAreAlikeTest {
    DetermineIfStringHalvesAreAlike determineIfStringHalvesAreAlike = new DetermineIfStringHalvesAreAlike();

    @Test
    void Example1() {
        String s = "book";
        boolean results = determineIfStringHalvesAreAlike.halvesAreAlike(s);

        Assertions.assertTrue(results);
    }

    @Test
    void Example2() {
        String s = "textbook";
        boolean results = determineIfStringHalvesAreAlike.halvesAreAlike(s);

        Assertions.assertFalse(results);
    }
}

=== Chunk 1648 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1706.where-will-the-ball-fall\WhereWillTheBallFall.java

class WhereWillTheBallFall {
    public int[] findBall(int[][] grid) {
        int n = grid[0].length;
        int[] res = new int[n];
        for (int i = 0; i < n; i++) {
            int i1 = i, i2;
            for (int[] ints : grid) {
                i2 = i1 + ints[i1];
                if (i2 < 0 || i2 >= n || ints[i2] != ints[i1]) {
                    i1 = -1;
                    break;
                }
                i1 = i2;
            }
            res[i] = i1;
        }
        return res;
    }
}

=== Chunk 1649 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1706.where-will-the-ball-fall\WhereWillTheBallFallTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1650 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1706.where-will-the-ball-fall\WhereWillTheBallFallTest.java

public class WhereWillTheBallFallTest {
    WhereWillTheBallFall WhereWillTheBallFall = new WhereWillTheBallFall();

    @Test
    void Example1() {
        int[][] grid = {{1, 1, 1, -1, -1}, {1, 1, 1, -1, -1}, {-1, -1, -1, 1, 1}, {1, 1, 1, 1, -1}, {-1, -1, -1, -1, -1}};
        int[] results = WhereWillTheBallFall.findBall(grid);
        int[] expectedResults = {1, -1, -1, -1, -1};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] grid = {{-1}};
        int[] results = WhereWillTheBallFall.findBall(grid);
        int[] expectedResults = {-1};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 1651 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1706.where-will-the-ball-fall\WhereWillTheBallFallTest.java

}

    @Test
    void Example3() {
        int[][] grid = {{1, 1, 1, 1, 1, 1}, {-1, -1, -1, -1, -1, -1}, {1, 1, 1, 1, 1, 1}, {-1, -1, -1, -1, -1, -1}};
        int[] results = WhereWillTheBallFall.findBall(grid);
        int[] expectedResults = {0, 1, 2, 3, 4, -1};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 1652 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1710.maximum-units-on-a-truck\MaximumUnitsOnATruck.java

import java.util.Arrays;

class MaximumUnitsOnATruck {
    public int maximumUnits(int[][] boxTypes, int truckSize) {
        Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]);

        int units = 0;
        for (int[] box : boxTypes) {
            if (box[0] >= truckSize) {
                units += truckSize * box[1];
                break;
            } else {
                units += box[0] * box[1];
                truckSize -= box[0];
            }
        }

        return units;
    }
}

=== Chunk 1653 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1710.maximum-units-on-a-truck\MaximumUnitsOnATruckTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1654 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1710.maximum-units-on-a-truck\MaximumUnitsOnATruckTest.java

public class MaximumUnitsOnATruckTest {
    MaximumUnitsOnATruck MaximumUnitsOnATruck = new MaximumUnitsOnATruck();

    @Test
    void Example1() {
        int[][] boxTypes = {{1, 3}, {2, 2}, {3, 1}};
        int truckSize = 4;
        int results = MaximumUnitsOnATruck.maximumUnits(boxTypes, truckSize);
        int expectedResults = 8;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] boxTypes = {{5, 10}, {2, 5}, {4, 7}, {3, 9}};
        int truckSize = 10;
        int results = MaximumUnitsOnATruck.maximumUnits(boxTypes, truckSize);
        int expectedResults = 91;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1655 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1721.swapping-nodes-in-a-linked-list\SwappingNodesInALinkedList.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

=== Chunk 1656 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1721.swapping-nodes-in-a-linked-list\SwappingNodesInALinkedList.java

class SwappingNodesInALinkedList {
    public ListNode swapNodes(ListNode head, int k) {
        ListNode curr = head, first = head, last = head;
        int count = 1;
        while (curr.next != null) {
            if (count < k) {
                first = first.next;
            } else {
                last = last.next;
            }
            count++;
            curr = curr.next;
        }
        int temp = first.val;
        first.val = last.val;
        last.val = temp;
        return head;
    }
}

=== Chunk 1657 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1721.swapping-nodes-in-a-linked-list\SwappingNodesInALinkedListTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1658 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1721.swapping-nodes-in-a-linked-list\SwappingNodesInALinkedListTest.java

public class SwappingNodesInALinkedListTest {
    SwappingNodesInALinkedList swappingNodesInALinkedList = new SwappingNodesInALinkedList();

    @Test
    void Example1() {
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);

        ListNode results = swappingNodesInALinkedList.swapNodes(head, 2);
        Assertions.assertEquals(1, results.val);
        Assertions.assertEquals(4, results.next.val);
        Assertions.assertEquals(3, results.next.next.val);
        Assertions.assertEquals(2, results.next.next.next.val);
        Assertions.assertEquals(5, results.next.next.next.next.val);
    }

    @Test

=== Chunk 1659 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1721.swapping-nodes-in-a-linked-list\SwappingNodesInALinkedListTest.java

}

    @Test
    void Example2() {
        ListNode head = new ListNode(7);
        head.next = new ListNode(9);
        head.next.next = new ListNode(6);
        head.next.next.next = new ListNode(6);
        head.next.next.next.next = new ListNode(7);
        head.next.next.next.next.next = new ListNode(8);
        head.next.next.next.next.next.next = new ListNode(3);
        head.next.next.next.next.next.next.next = new ListNode(0);
        head.next.next.next.next.next.next.next.next = new ListNode(9);
        head.next.next.next.next.next.next.next.next.next = new ListNode(5);

        ListNode results = swappingNodesInALinkedList.swapNodes(head, 5);
        Assertions.assertEquals(7, results.val);
        Assertions.assertEquals(9, results.next.val);

=== Chunk 1660 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1721.swapping-nodes-in-a-linked-list\SwappingNodesInALinkedListTest.java

Assertions.assertEquals(6, results.next.next.val);
        Assertions.assertEquals(6, results.next.next.next.val);
        Assertions.assertEquals(8, results.next.next.next.next.val);
        Assertions.assertEquals(7, results.next.next.next.next.next.val);
        Assertions.assertEquals(3, results.next.next.next.next.next.next.val);
        Assertions.assertEquals(0, results.next.next.next.next.next.next.next.val);
        Assertions.assertEquals(9, results.next.next.next.next.next.next.next.next.val);
        Assertions.assertEquals(5, results.next.next.next.next.next.next.next.next.next.val);
    }
}

=== Chunk 1661 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1768.merge-strings-alternately\MergeStringsAlternately.java

class MergeStringsAlternately {
    public String mergeAlternately(String word1, String word2) {
        int n = word1.length(), m = word2.length();
        int i = 0, j = 0;
        StringBuilder res = new StringBuilder();
        while (i < n || j < m) {
            if (i < n) {
                res.append(word1.charAt(i++));
            }
            if (j < m) {
                res.append(word2.charAt(j++));
            }
        }

        return res.toString();
    }
}

=== Chunk 1662 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1768.merge-strings-alternately\MergeStringsAlternatelyTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MergeStringsAlternatelyTest {
    MergeStringsAlternately mergeStringsAlternately = new MergeStringsAlternately();

    @Test
    void Example1() {
        String word1 = "abc", word2 = "pqr";

        Assertions.assertEquals("apbqcr", mergeStringsAlternately.mergeAlternately(word1, word2));
    }

    @Test
    void Example2() {
        String word1 = "ab", word2 = "pqrs";

        Assertions.assertEquals("apbqrs", mergeStringsAlternately.mergeAlternately(word1, word2));
    }

    @Test
    void Example3() {
        String word1 = "abcd", word2 = "pq";

        Assertions.assertEquals("apbqcd", mergeStringsAlternately.mergeAlternately(word1, word2));
    }
}

=== Chunk 1663 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1770.maximum-score-from-performing-multiplication-operations\MaximumScoreFromPerformingMultiplicationOperations.java

import java.util.Arrays;

class MaximumScoreFromPerformingMultiplicationOperations {
    public int maximumScore(int[] nums, int[] multipliers) {
        int n = nums.length;
        int m = multipliers.length;
        int[][] dp = new int[m+1][m+1];

        for (int op = m - 1; op >= 0; op--) {
            for (int left = op; left >= 0; left--) {
                dp[op][left] = Math.max(multipliers[op] * nums[left] + dp[op + 1][left + 1], multipliers[op] * nums[n - 1 - (op - left)] + dp[op + 1][left]);
            }
        }

        return dp[0][0];
    }
}

=== Chunk 1664 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1770.maximum-score-from-performing-multiplication-operations\MaximumScoreFromPerformingMultiplicationOperationsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1665 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1770.maximum-score-from-performing-multiplication-operations\MaximumScoreFromPerformingMultiplicationOperationsTest.java

public class MaximumScoreFromPerformingMultiplicationOperationsTest {
    MaximumScoreFromPerformingMultiplicationOperations MaximumScoreFromPerformingMultiplicationOperations = new MaximumScoreFromPerformingMultiplicationOperations();

    @Test
    void Example1() {
        int[] nums = {1, 2, 3}, multipliers = {3, 2, 1};
        int results = MaximumScoreFromPerformingMultiplicationOperations.maximumScore(nums, multipliers);
        int expectedResults = 14;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {-5, -3, -3, -2, 7, 1},  multipliers = {-10, -5, 3, 4, 6};
        int results = MaximumScoreFromPerformingMultiplicationOperations.maximumScore(nums, multipliers);

=== Chunk 1666 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1770.maximum-score-from-performing-multiplication-operations\MaximumScoreFromPerformingMultiplicationOperationsTest.java

int expectedResults = 102;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1667 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1822.sign-of-the-product-of-an-array\SignOfTheProductOfAnArray.java

class SignOfTheProductOfAnArray {
    public int arraySign(int[] nums) {
        int sign = 1;
        for (int num: nums) {
            if (num == 0) {
                return 0;
            }
            if (num < 0) {
                sign *= -1;
            }
        }
        return sign;
    }
}

=== Chunk 1668 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1822.sign-of-the-product-of-an-array\SignOfTheProductOfAnArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SignOfTheProductOfAnArrayTest {
    SignOfTheProductOfAnArray signOfTheProductOfAnArray = new SignOfTheProductOfAnArray();

    @Test
    void Example1() {
        int[] nums = {-1, -2, -3, -4, 3, 2, 1};

        Assertions.assertEquals(1, signOfTheProductOfAnArray.arraySign(nums));
    }

    @Test
    void Example2() {
        int[] nums = {1, 5, 0, 2, -3};

        Assertions.assertEquals(0, signOfTheProductOfAnArray.arraySign(nums));
    }

    @Test
    void Example3() {
        int[] nums = {-1, 1, -1, 1, -1};

        Assertions.assertEquals(-1, signOfTheProductOfAnArray.arraySign(nums));
    }
}

=== Chunk 1669 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1832.check-if-the-sentence-is-pangram\CheckIfTheSentenceIsPangram.java

class CheckIfTheSentenceIsPangram {
    public boolean checkIfPangram(String sentence) {
        boolean[] found = new boolean[26];
        for (char c : sentence.toCharArray())
            found[c - 'a'] = true;
        for (boolean f : found)
            if (!f) return false;

        return true;
    }
}

=== Chunk 1670 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1832.check-if-the-sentence-is-pangram\CheckIfTheSentenceIsPangramTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class CheckIfTheSentenceIsPangramTest {
    CheckIfTheSentenceIsPangram CheckIfTheSentenceIsPangram = new CheckIfTheSentenceIsPangram();

    @Test
    void Example1() {
        String sentence = "thequickbrownfoxjumpsoverthelazydog";
        boolean results = CheckIfTheSentenceIsPangram.checkIfPangram(sentence);
        boolean expectedResults = true;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String sentence = "leetcode";
        boolean results = CheckIfTheSentenceIsPangram.checkIfPangram(sentence);
        boolean expectedResults = false;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1671 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1833.maximum-ice-cream-bars\MaximumIceCreamBars.java

import java.util.Arrays;

class MaximumIceCreamBars {
    public int maxIceCream(int[] costs, int coins) {
        Arrays.sort(costs);
        int n = costs.length;
        for (int i = 0; i < n; i++) {
            if (costs[i] > coins)
                return i;
            coins -= costs[i];
        }
        return n;
    }
}

=== Chunk 1672 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1833.maximum-ice-cream-bars\MaximumIceCreamBars2.java

class MaximumIceCreamBars2 {
    public int maxIceCream(int[] costs, int coins) {
        int[] freq = new int[100001];
        for (int i = 0; i < costs.length; i++)
            freq[costs[i]]++;
        int ans = 0;
        for (int i = 1; i <= 100000; i++) {
            if (coins >= i) {
                int currCount = Math.min(freq[i], coins / i);
                ans += currCount;
                coins -= currCount * i;
            } else
                break;
        }
        return ans;
    }
}

=== Chunk 1673 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1833.maximum-ice-cream-bars\MaximumIceCreamBarsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1674 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1833.maximum-ice-cream-bars\MaximumIceCreamBarsTest.java

public class MaximumIceCreamBarsTest {
    MaximumIceCreamBars maximumIceCreamBars = new MaximumIceCreamBars();
    MaximumIceCreamBars2 maximumIceCreamBars2 = new MaximumIceCreamBars2();

    @Test
    void Example1() {
        int[] costs = {1, 3, 2, 4, 1};
        int coins = 7;

        Assertions.assertEquals(4, maximumIceCreamBars.maxIceCream(costs, coins));
        Assertions.assertEquals(4, maximumIceCreamBars2.maxIceCream(costs, coins));
    }

    @Test
    void Example2() {
        int[] costs = {10, 6, 8, 7, 7, 8};
        int coins = 5;

        Assertions.assertEquals(0, maximumIceCreamBars.maxIceCream(costs, coins));
        Assertions.assertEquals(0, maximumIceCreamBars2.maxIceCream(costs, coins));
    }

    @Test
    void Example3() {

=== Chunk 1675 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1833.maximum-ice-cream-bars\MaximumIceCreamBarsTest.java

}

    @Test
    void Example3() {
        int[] costs = {1, 6, 3, 1, 2, 5};
        int coins = 20;

        Assertions.assertEquals(6, maximumIceCreamBars.maxIceCream(costs, coins));
        Assertions.assertEquals(6, maximumIceCreamBars2.maxIceCream(costs, coins));
    }
}

=== Chunk 1676 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1834.single-threaded-cpu\SingleThreadedCpu.java

import java.util.*;

=== Chunk 1677 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1834.single-threaded-cpu\SingleThreadedCpu.java

class SingleThreadedCpu {
    public int[] getOrder(int[][] tasks) {
        int[][] newTasks = new int[tasks.length][3];
        for (int i = 0; i < tasks.length; i++) {
            newTasks[i][0] = tasks[i][0];
            newTasks[i][1] = tasks[i][1];
            newTasks[i][2] = i;
        }

        Arrays.sort(newTasks, Comparator.comparingInt(a -> a[0]));
        // pq data: new int[]{processingTime, index}
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] != b[0] ? (a[0] - b[0]) : (a[1] - b[1])));
        int[] ans = new int[tasks.length];
        int ansIndex = 0, currTime = 0;
        for (int i = 0; i < newTasks.length; i++) {
            while (currTime < newTasks[i][0] && !pq.isEmpty()) {
                int[] topTask = pq.remove();

=== Chunk 1678 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1834.single-threaded-cpu\SingleThreadedCpu.java

int[] topTask = pq.remove();
                ans[ansIndex++] = topTask[1];
                currTime += topTask[0];
            }
            currTime = Math.max(currTime, newTasks[i][0]);
            pq.add(new int[]{newTasks[i][1], newTasks[i][2]});
        }
        while (!pq.isEmpty()) {
            int[] topTask = pq.remove();
            ans[ansIndex++] = topTask[1];
        }

        return ans;
    }
}

=== Chunk 1679 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1834.single-threaded-cpu\SingleThreadedCpuTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SingleThreadedCpuTest {
    SingleThreadedCpu singleThreadedCpu = new SingleThreadedCpu();

    @Test
    void Example1() {
        int[][] tasks = {{1, 2}, {2, 4}, {3, 2}, {4, 1}};

        Assertions.assertArrayEquals(new int[]{0, 2, 3, 1}, singleThreadedCpu.getOrder(tasks));
    }

    @Test
    void Example2() {
        int[][] tasks = {{7, 10}, {7, 12}, {7, 5}, {7, 4}, {7, 2}};

        Assertions.assertArrayEquals(new int[]{4, 3, 2, 0, 1}, singleThreadedCpu.getOrder(tasks));
    }
}

=== Chunk 1680 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1926.nearest-exit-from-entrance-in-maze\NearestExitFromEntranceInMaze.java

import java.util.LinkedList;
import java.util.Queue;

=== Chunk 1681 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1926.nearest-exit-from-entrance-in-maze\NearestExitFromEntranceInMaze.java

class NearestExitFromEntranceInMaze {
    public int nearestExit(char[][] maze, int[] entrance) {
        int rows = maze.length, cols = maze[0].length;
        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

        int startRow = entrance[0], startCol = entrance[1];
        maze[startRow][startCol] = '+';

        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{startRow, startCol, 0});

        while (!queue.isEmpty()) {
            int[] currentState = queue.poll();
            int currRow = currentState[0], currCol = currentState[1], currDistance = currentState[2];

            for (int[] dir : dirs) {
                int nextRow = currRow + dir[0], nextCol = currCol + dir[1];

=== Chunk 1682 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1926.nearest-exit-from-entrance-in-maze\NearestExitFromEntranceInMaze.java

if (0 <= nextRow && nextRow < rows && 0 <= nextCol && nextCol < cols && maze[nextRow][nextCol] == '.') {
                    if (nextRow == 0 || nextRow == rows - 1 || nextCol == 0 || nextCol == cols - 1)
                        return currDistance + 1;

                    maze[nextRow][nextCol] = '+';
                    queue.offer(new int[]{nextRow, nextCol, currDistance + 1});
                }
            }
        }

        return -1;
    }
}

=== Chunk 1683 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1926.nearest-exit-from-entrance-in-maze\NearestExitFromEntranceInMazeTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1684 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1926.nearest-exit-from-entrance-in-maze\NearestExitFromEntranceInMazeTest.java

public class NearestExitFromEntranceInMazeTest {
    NearestExitFromEntranceInMaze NearestExitFromEntranceInMaze = new NearestExitFromEntranceInMaze();

    @Test
    void Example1() {
        char[][] maze = {{'+', '+', '.', '+'}, {'.', '.', '.', '+'}, {'+', '+', '+', '.'}};
        int[] entrance = {1, 2};
        int results = NearestExitFromEntranceInMaze.nearestExit(maze, entrance);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        char[][] maze = {{'+', '+', '+'}, {'.', '.', '.'}, {'+', '+', '+'}};
        int[] entrance = {1, 0};
        int results = NearestExitFromEntranceInMaze.nearestExit(maze, entrance);
        int expectedResults = 2;

=== Chunk 1685 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1926.nearest-exit-from-entrance-in-maze\NearestExitFromEntranceInMazeTest.java

int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        char[][] maze = {{'.', '+'}};
        int[] entrance = {0, 0};
        int results = NearestExitFromEntranceInMaze.nearestExit(maze, entrance);
        int expectedResults = -1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1686 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1962.remove-stones-to-minimize-the-total\RemoveStonesToMinimizeTheTotal.java

import java.util.PriorityQueue;

class RemoveStonesToMinimizeTheTotal {
    public int minStoneSum(int[] piles, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
        for (int i = 0; i < piles.length; i++)
            pq.add(piles[i]);

        for (int i = 0; i < k; i++) {
            int stone = pq.remove();
            pq.add(stone - (stone / 2));
        }

        int stones = 0;
        for (int stone : pq)
            stones += stone;

        return stones;
    }
}

=== Chunk 1687 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1962.remove-stones-to-minimize-the-total\RemoveStonesToMinimizeTheTotalTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class RemoveStonesToMinimizeTheTotalTest {
    RemoveStonesToMinimizeTheTotal removeStonesToMinimizeTheTotal = new RemoveStonesToMinimizeTheTotal();

    @Test
    void Example1() {
        int[] piles = {5, 4, 9};
        int k = 2;

        Assertions.assertEquals(12, removeStonesToMinimizeTheTotal.minStoneSum(piles, k));
    }

    @Test
    void Example2() {
        int[] piles = {4, 3, 6, 7};
        int k = 3;

        Assertions.assertEquals(12, removeStonesToMinimizeTheTotal.minStoneSum(piles, k));
    }
}

=== Chunk 1688 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1971.find-if-path-exists-in-graph\FindIfPathExistsInGraph.java

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

=== Chunk 1689 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1971.find-if-path-exists-in-graph\FindIfPathExistsInGraph.java

class FindIfPathExistsInGraph {
    public boolean validPath(int n, int[][] edges, int source, int destination) {
        List<Integer>[] adj = new List[n];
        for (int i = 0; i < n; i++)
            adj[i] = new ArrayList<>();
        for (int[] edge : edges) {
            int x = edge[0], y = edge[1];
            adj[x].add(y);
            adj[y].add(x);
        }
        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(source);
        visited[source] = true;
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            if (vertex == destination) break;
            for (int next : adj[vertex]) {
                if (!visited[next]) {
                    queue.offer(next);

=== Chunk 1690 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1971.find-if-path-exists-in-graph\FindIfPathExistsInGraph.java

queue.offer(next);
                    visited[next] = true;
                }
            }
        }
        return visited[destination];
    }
}

=== Chunk 1691 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1971.find-if-path-exists-in-graph\FindIfPathExistsInGraph2.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 1692 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1971.find-if-path-exists-in-graph\FindIfPathExistsInGraph2.java

class FindIfPathExistsInGraph2 {
    public boolean validPath(int n, int[][] edges, int source, int destination) {
        List<Integer>[] adj = new List[n];
        for (int i = 0; i < n; i++)
            adj[i] = new ArrayList<>();
        for (int[] edge : edges) {
            int x = edge[0], y = edge[1];
            adj[x].add(y);
            adj[y].add(x);
        }
        boolean[] visited = new boolean[n];
        return dfs(source, destination, adj, visited);
    }

    private boolean dfs(int source, int destination, List<Integer>[] adj, boolean[] visited) {
        if (source == destination) return true;
        visited[source] = true;
        for (int next : adj[source]) {
            if (!visited[next] && dfs(next, destination, adj, visited))

=== Chunk 1693 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1971.find-if-path-exists-in-graph\FindIfPathExistsInGraph2.java

return true;
        }
        return false;
    }
}

=== Chunk 1694 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1971.find-if-path-exists-in-graph\FindIfPathExistsInGraph3.java

class FindIfPathExistsInGraph3 {
    public boolean validPath(int n, int[][] edges, int source, int destination) {
        if (source == destination) return true;
        UnionFind uf = new UnionFind(n);
        for (int[] edge : edges)
            uf.uni(edge[0], edge[1]);
        return uf.connect(source, destination);
    }
}

=== Chunk 1695 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1971.find-if-path-exists-in-graph\FindIfPathExistsInGraph3.java

class UnionFind {
    private final int[] parent;
    private final int[] rank;

    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    public void uni(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (rank[rootX] > rank[rootY])
                parent[rootY] = rootX;
            else if (rank[rootX] < rank[rootY])
                parent[rootX] = rootY;
            else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }

    public int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);

=== Chunk 1696 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1971.find-if-path-exists-in-graph\FindIfPathExistsInGraph3.java

parent[x] = find(parent[x]);
        return parent[x];
    }

    public boolean connect(int x, int y) {
        return find(x) == find(y);
    }
}

=== Chunk 1697 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1971.find-if-path-exists-in-graph\FindIfPathExistsInGraphTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1698 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1971.find-if-path-exists-in-graph\FindIfPathExistsInGraphTest.java

class FindIfPathExistsInGraphTest {
    FindIfPathExistsInGraph findIfPathExistsInGraph = new FindIfPathExistsInGraph();
    FindIfPathExistsInGraph2 findIfPathExistsInGraph2 = new FindIfPathExistsInGraph2();
    FindIfPathExistsInGraph3 findIfPathExistsInGraph3 = new FindIfPathExistsInGraph3();

    @Test
    void Example1() {
        int n = 3, source = 0, destination = 2;
        int[][] edges = {{0, 1}, {1, 2}, {2, 0}};

        Assertions.assertTrue(findIfPathExistsInGraph.validPath(n, edges, source, destination));
        Assertions.assertTrue(findIfPathExistsInGraph2.validPath(n, edges, source, destination));
        Assertions.assertTrue(findIfPathExistsInGraph3.validPath(n, edges, source, destination));
    }

    @Test
    void Example2() {

=== Chunk 1699 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1971.find-if-path-exists-in-graph\FindIfPathExistsInGraphTest.java

}

    @Test
    void Example2() {
        int n = 6, source = 0, destination = 5;
        int[][] edges = {{0, 1}, {0, 2}, {3, 5}, {5, 4}, {4, 3}};

        Assertions.assertFalse(findIfPathExistsInGraph.validPath(n, edges, source, destination));
        Assertions.assertFalse(findIfPathExistsInGraph2.validPath(n, edges, source, destination));
        Assertions.assertFalse(findIfPathExistsInGraph3.validPath(n, edges, source, destination));
    }
}

=== Chunk 1700 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1996.the-number-of-weak-characters-in-the-game\TheNumberOfWeakCharactersInTheGame.java

import java.util.Arrays;

class TheNumberOfWeakCharactersInTheGame {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (a, b) -> (a[0] == b[0]) ? Integer.compare(b[1], a[1]) : Integer.compare(a[0], b[0]));

        int noOfWeakCharacters = 0;
        int len = properties.length;
        int max = properties[len-1][1];

        for (int i = len - 2; i >= 0; i--) {
            if (properties[i][1] < max) noOfWeakCharacters++;
            else max = properties[i][1];
        }
        return noOfWeakCharacters;
    }
}

=== Chunk 1701 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1996.the-number-of-weak-characters-in-the-game\TheNumberOfWeakCharactersInTheGameTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1702 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1996.the-number-of-weak-characters-in-the-game\TheNumberOfWeakCharactersInTheGameTest.java

public class TheNumberOfWeakCharactersInTheGameTest {
    TheNumberOfWeakCharactersInTheGame TheNumberOfWeakCharactersInTheGame = new TheNumberOfWeakCharactersInTheGame();

    @Test
    void Example1() {
        int[][] properties = {{5, 5}, {6, 3}, {3, 6}};
        int results = TheNumberOfWeakCharactersInTheGame.numberOfWeakCharacters(properties);
        int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] properties = {{2, 2}, {3, 3}};
        int results = TheNumberOfWeakCharactersInTheGame.numberOfWeakCharacters(properties);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 1703 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\1996.the-number-of-weak-characters-in-the-game\TheNumberOfWeakCharactersInTheGameTest.java

}

    @Test
    void Example3() {
        int[][] properties = {{1, 5}, {10, 4}, {4, 3}};
        int results = TheNumberOfWeakCharactersInTheGame.numberOfWeakCharacters(properties);
        int expectedResults = 1;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1704 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2007.find-original-array-from-doubled-array\FindOriginalArrayFromDoubledArray.java

import java.util.Arrays;
import java.util.HashMap;

=== Chunk 1705 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2007.find-original-array-from-doubled-array\FindOriginalArrayFromDoubledArray.java

class FindOriginalArrayFromDoubledArray {
    public int[] findOriginalArray(int[] changed) {
        int[] emptyArr = new int[0];
        int l = changed.length;
        if (l % 2 != 0) return emptyArr;
        HashMap<Integer, Integer> map = new HashMap<>();
        int[] res = new int[l / 2];
        for (int j : changed) {
            map.put(j, map.getOrDefault(j, 0) + 1);
        }
        int temp = 0;
        Arrays.sort(changed);
        for (int num : changed) {
            if (map.get(num) <= 0) continue;
            if (map.getOrDefault(2 * num, 0) <= 0) return emptyArr;
            res[temp++] = num;
            map.put(num, map.get(num) - 1);
            map.put(2 * num, map.get(2 * num) - 1);
        }

        return res;
    }
}

=== Chunk 1706 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2007.find-original-array-from-doubled-array\FindOriginalArrayFromDoubledArrayTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1707 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2007.find-original-array-from-doubled-array\FindOriginalArrayFromDoubledArrayTest.java

public class FindOriginalArrayFromDoubledArrayTest {
    FindOriginalArrayFromDoubledArray FindOriginalArrayFromDoubledArray = new FindOriginalArrayFromDoubledArray();

    @Test
    void Example1() {
        int[] changed = {1, 3, 4, 2, 6, 8};
        int[] results = FindOriginalArrayFromDoubledArray.findOriginalArray(changed);
        int[] expectedResults = {1, 3, 4};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] changed = {6, 3, 0, 1};
        int[] results = FindOriginalArrayFromDoubledArray.findOriginalArray(changed);
        int[] expectedResults = {};

        Assertions.assertArrayEquals(expectedResults, results);
    }

    @Test
    void Example3() {
        int[] changed = {1};

=== Chunk 1708 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2007.find-original-array-from-doubled-array\FindOriginalArrayFromDoubledArrayTest.java

int[] changed = {1};
        int[] results = FindOriginalArrayFromDoubledArray.findOriginalArray(changed);
        int[] expectedResults = {};

        Assertions.assertArrayEquals(expectedResults, results);
    }
}

=== Chunk 1709 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2095.delete-the-middle-node-of-a-linked-list\DeleteTheMiddleNodeOfALinkedList.java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class DeleteTheMiddleNodeOfALinkedList {
    public ListNode deleteMiddle(ListNode head) {
        if (head.next == null) return null;
        int count = 0;
        ListNode countList = head;
        while (countList != null) {
            count++;
            countList = countList.next;
        }
        countList = head;
        for (int i = 0; i < count / 2 - 1; i++) {
            countList = countList.next;
        }
        countList.next = countList.next.next;
        return head;
    }
}

=== Chunk 1710 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2095.delete-the-middle-node-of-a-linked-list\DeleteTheMiddleNodeOfALinkedListTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1711 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2095.delete-the-middle-node-of-a-linked-list\DeleteTheMiddleNodeOfALinkedListTest.java

public class DeleteTheMiddleNodeOfALinkedListTest {
    DeleteTheMiddleNodeOfALinkedList DeleteTheMiddleNodeOfALinkedList = new DeleteTheMiddleNodeOfALinkedList();

    @Test
    void Example1() {
        ListNode head = new ListNode(1);
        head.next = new ListNode(3);
        head.next.next = new ListNode(4);
        head.next.next.next = new ListNode(7);
        head.next.next.next.next = new ListNode(1);
        head.next.next.next.next.next = new ListNode(2);
        head.next.next.next.next.next.next = new ListNode(6);
        ListNode results = DeleteTheMiddleNodeOfALinkedList.deleteMiddle(head);

        Assertions.assertEquals(1, results.next.next.next.val);
    }

    @Test
    void Example2() {
        ListNode head = new ListNode(1);

=== Chunk 1712 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2095.delete-the-middle-node-of-a-linked-list\DeleteTheMiddleNodeOfALinkedListTest.java

ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        ListNode results = DeleteTheMiddleNodeOfALinkedList.deleteMiddle(head);

        Assertions.assertEquals(4, results.next.next.val);
    }

    @Test
    void Example3() {
        ListNode head = new ListNode(2);
        head.next = new ListNode(1);
        ListNode results = DeleteTheMiddleNodeOfALinkedList.deleteMiddle(head);

        Assertions.assertEquals(2, results.val);
    }

    @Test
    void Example4() {
        ListNode head = new ListNode(1);
        ListNode results = DeleteTheMiddleNodeOfALinkedList.deleteMiddle(head);

        Assertions.assertNull(results);
    }
}

=== Chunk 1713 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2131.longest-palindrome-by-concatenating-two-letter-words\LongestPalindromeByConcatenatingTwoLetterWords.java

import java.util.HashMap;
import java.util.Map;

=== Chunk 1714 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2131.longest-palindrome-by-concatenating-two-letter-words\LongestPalindromeByConcatenatingTwoLetterWords.java

class LongestPalindromeByConcatenatingTwoLetterWords {
    public int longestPalindrome(String[] words) {
        Map<String, Integer> map = new HashMap<>();
        int unpaired = 0, res = 0;
        for (String word : words) {
            if (!map.containsKey(word)) map.put(word, 0);
            if (word.charAt(0) == word.charAt(1)) {
                if (map.get(word) > 0) {
                    unpaired--;
                    map.put(word, map.get(word) - 1);
                    res += 4;
                } else {
                    map.put(word, map.get(word) + 1);
                    unpaired++;
                }
            } else {
                String rev = Character.toString(word.charAt(1)) + Character.toString(word.charAt(0));

=== Chunk 1715 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2131.longest-palindrome-by-concatenating-two-letter-words\LongestPalindromeByConcatenatingTwoLetterWords.java

if (map.containsKey(rev) && map.get(rev) > 0) {
                    res += 4;
                    map.put(rev, map.get(rev) - 1);
                } else {
                    map.put(word, map.get(word) + 1);
                }
            }
        }
        if (unpaired > 0) res += 2;
        return res;
    }
}

=== Chunk 1716 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2131.longest-palindrome-by-concatenating-two-letter-words\LongestPalindromeByConcatenatingTwoLetterWordsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1717 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2131.longest-palindrome-by-concatenating-two-letter-words\LongestPalindromeByConcatenatingTwoLetterWordsTest.java

public class LongestPalindromeByConcatenatingTwoLetterWordsTest {
    LongestPalindromeByConcatenatingTwoLetterWords LongestPalindromeByConcatenatingTwoLetterWords = new LongestPalindromeByConcatenatingTwoLetterWords();

    @Test
    void Example1() {
        String[] words = {"lc", "cl", "gg"};
        int results = LongestPalindromeByConcatenatingTwoLetterWords.longestPalindrome(words);
        int expectedResults = 6;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        String[] words = {"ab", "ty", "yt", "lc", "cl", "ab"};
        int results = LongestPalindromeByConcatenatingTwoLetterWords.longestPalindrome(words);
        int expectedResults = 8;

        Assertions.assertEquals(expectedResults, results);

=== Chunk 1718 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2131.longest-palindrome-by-concatenating-two-letter-words\LongestPalindromeByConcatenatingTwoLetterWordsTest.java

}

    @Test
    void Example3() {
        String[] words = {"cc", "ll", "xx"};
        int results = LongestPalindromeByConcatenatingTwoLetterWords.longestPalindrome(words);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1719 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2136.earliest-possible-day-of-full-bloom\EarliestPossibleDayOfFullBloom.java

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

class EarliestPossibleDayOfFullBloom {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
        int n = growTime.length;
        List<Integer> indices = new ArrayList<>();
        for (int i = 0; i < growTime.length; i++) {
            indices.add(i);
        }
        indices.sort(Comparator.comparingInt(i -> -growTime[i]));
        int result = 0;
        for (int i = 0, currPlantTime = 0; i < n; i++) {
            int index = indices.get(i);
            int time = currPlantTime + plantTime[index] + growTime[index];
            result = Math.max(result, time);
            currPlantTime += plantTime[index];
        }
        return result;
    }
}

=== Chunk 1720 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2136.earliest-possible-day-of-full-bloom\EarliestPossibleDayOfFullBloomTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1721 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2136.earliest-possible-day-of-full-bloom\EarliestPossibleDayOfFullBloomTest.java

public class EarliestPossibleDayOfFullBloomTest {
    EarliestPossibleDayOfFullBloom EarliestPossibleDayOfFullBloom = new EarliestPossibleDayOfFullBloom();

    @Test
    void Example1() {
        int[] plantTime = {1, 4, 3},  growTime = {2, 3, 1};
        int results = EarliestPossibleDayOfFullBloom.earliestFullBloom(plantTime, growTime);
        int expectedResults = 9;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] plantTime = {1, 2, 3, 2},  growTime = {2, 1, 2, 1};
        int results = EarliestPossibleDayOfFullBloom.earliestFullBloom(plantTime, growTime);
        int expectedResults = 9;

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example3() {

=== Chunk 1722 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2136.earliest-possible-day-of-full-bloom\EarliestPossibleDayOfFullBloomTest.java

}

    @Test
    void Example3() {
        int[] plantTime = {1},  growTime = {1};
        int results = EarliestPossibleDayOfFullBloom.earliestFullBloom(plantTime, growTime);
        int expectedResults = 2;

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1723 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2140.solving-questions-with-brainpower\SolvingQuestionsWithBrainpower.java

class SolvingQuestionsWithBrainpower {
    public long mostPoints(int[][] questions) {
        int n = questions.length;
        long[] dp = new long[n + 1];
        for (int i = n - 1; i >= 0; i--) {
            dp[i] = Math.max(dp[i + 1], questions[i][0] + dp[Math.min(n, i + questions[i][1] + 1)]);
        }
        return dp[0];
    }
}

=== Chunk 1724 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2140.solving-questions-with-brainpower\SolvingQuestionsWithBrainpowerTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SolvingQuestionsWithBrainpowerTest {
    SolvingQuestionsWithBrainpower solvingQuestionsWithBrainpower = new SolvingQuestionsWithBrainpower();

    @Test
    void Example1() {
        int[][] questions = {{3, 2}, {4, 3}, {4, 4}, {2, 5}};

        Assertions.assertEquals(5, solvingQuestionsWithBrainpower.mostPoints(questions));
    }

    @Test
    void Example2() {
        int[][] questions = {{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};

        Assertions.assertEquals(7, solvingQuestionsWithBrainpower.mostPoints(questions));
    }
}

=== Chunk 1725 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTrips.java

import java.util.Arrays;

class MinimumTimeToCompleteTrips {
    public long minimumTime(int[] time, int totalTrips) {
        Arrays.sort(time);
        long l = 1, r = (long) totalTrips * time[0];
        while (l < r) {
            long mid = l + (r - l) / 2;
            if (check(mid, time, totalTrips)) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }

    private boolean check(long currentTime, int[] time, int totalTrips) {
        long cnt = 0;
        for (int period : time) {
            if (period > currentTime) {
                break;
            }
            cnt += currentTime / period;
        }
        return cnt >= totalTrips;
    }
}

=== Chunk 1726 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1727 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

public class MinimumTimeToCompleteTripsTest {
    MinimumTimeToCompleteTrips minimumTimeToCompleteTrips = new MinimumTimeToCompleteTrips();

    @Test
    void Example1() {
        int[] time = {1, 2, 3};
        int totalTrips = 5;

        Assertions.assertEquals(3, minimumTimeToCompleteTrips.minimumTime(time, totalTrips));
    }

    @Test
    void Example2() {
        int[] time = {2};
        int totalTrips = 1;

        Assertions.assertEquals(2, minimumTimeToCompleteTrips.minimumTime(time, totalTrips));
    }

    @Test
    void Example3() {

=== Chunk 1728 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

int[] time = {35526, 68271, 53295, 85312, 98439, 20401, 12567, 75537, 13042, 3015, 17945, 51706, 8379, 9020, 68149, 90591, 69251, 9417, 78418, 35804, 36630, 93100, 14223, 27099, 65124, 38701, 93629, 82300, 78404, 72046, 35760, 11057, 60001, 55960, 96428, 49527, 87398, 89804, 45956, 46031, 48904, 35592, 66810, 2777, 75831, 753, 82438, 19950, 57812, 24402, 51134, 20588, 25909, 80046, 36073, 71308, 94062, 89630, 18090, 93549, 23207, 66416, 54285, 76663, 66441, 79464, 67201, 93574, 61759, 54469, 42206, 15010, 17893, 61618, 27951, 90361, 86666, 82842, 43701, 21837, 56027, 53768, 53220, 56636, 73170, 13353, 22393, 44370, 46178, 39523, 86692, 60228, 37866, 38409, 844, 36175, 62823, 40866, 71862, 19182, 73662, 11399, 26141, 57640, 19902, 40962, 25361, 58833, 51163, 35488, 5561, 54750,

=== Chunk 1729 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

40962, 25361, 58833, 51163, 35488, 5561, 54750, 84308, 64353, 64150, 17552, 69778, 13564, 6011, 79167, 56980, 98308, 83980, 45116, 56028, 88225, 1824, 93699, 89442, 22404, 5868, 18700, 44476, 15869, 1583, 57636, 28371, 6270, 66188, 37726, 76939, 79238, 59320, 89811, 66535, 93128, 21053, 86603, 90383, 17679, 95629, 80276, 62367, 54714, 81017, 88434, 81240, 91915, 14418, 2251, 50001, 57081, 56030, 11941, 83308, 14990, 37527, 25793, 96967, 12902, 36597, 38487, 10090, 23757, 18301, 70951, 76172, 38409, 12228, 20382, 16560, 90106, 43687, 99248, 33738, 48726, 65936, 71531, 66629, 95433, 59822, 230, 13699, 21614, 48847, 3254, 9417, 28867, 38889, 64031, 57498, 83515, 71619, 95748, 86437, 40468, 40175, 1062, 94502, 96956, 240, 14265, 77888, 59298, 27311, 93953, 99919, 41606, 52803, 51401, 64132,

=== Chunk 1730 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

27311, 93953, 99919, 41606, 52803, 51401, 64132, 55876, 85391, 97101, 56438, 21074, 79997, 56815, 92097, 14090, 85007, 83914, 19222, 30752, 41580, 81193, 82585, 16509, 86366, 5654, 48942, 22998, 73761, 40595, 73144, 90131, 29770, 40487, 58407, 91217, 86723, 91291, 76943, 87736, 16745, 21252, 71347, 13605, 51863, 67662, 951, 42887, 34961, 71152, 83517, 14521, 63450, 49661, 72650, 31854, 38506, 14508, 1837, 99584, 73991, 19604, 174, 78776, 34463, 96369, 16743, 9341, 27944, 65679, 70077, 33227, 52684, 51832, 91464, 34239, 50175, 48925, 9918, 76944, 22485, 24469, 74612, 90584, 21380, 68789, 65552, 35330, 58725, 30035, 88445, 76097, 90479, 33509, 21790, 69282, 33720, 32661, 92204, 61463, 69033, 18774, 40028, 67322, 63697, 85469, 42726, 35207, 13436, 49118, 27075, 41241, 12212, 54741, 31899,

=== Chunk 1731 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

13436, 49118, 27075, 41241, 12212, 54741, 31899, 38764, 19239, 45927, 79779, 82559, 69922, 97988, 64077, 60899, 19250, 33197, 12227, 55129, 6161, 7679, 90383, 21720, 38419, 59921, 40394, 22248, 84651, 9919, 14769, 50547, 35590, 22054, 98547, 92300, 50533, 24494, 6357, 74340, 16444, 36562, 25519, 70299, 91085, 58473, 48549, 7314, 49789, 50854, 94732, 16473, 22298, 94573, 1177, 16647, 10489, 40756, 11864, 52532, 78056, 72466, 45909, 83358, 36728, 61145, 24085, 19232, 2698, 5866, 21763, 19417, 52766, 70604, 75357, 86363, 23548, 59612, 57256, 72080, 90665, 62130, 17811, 11737, 40209, 76143, 84341, 62105, 9559, 15885, 44428, 65942, 73923, 60174, 94085, 85226, 22423, 11680, 16007, 72223, 92611, 24143, 56415, 99004, 35300, 63534, 91796, 95364, 39871, 39547, 31533, 9820, 19254, 80757, 67351,

=== Chunk 1732 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

39871, 39547, 31533, 9820, 19254, 80757, 67351, 61252, 27802, 9134, 3264, 6660, 43279, 74234, 27708, 92078, 17050, 92833, 33868, 28116, 35816, 23129, 63684, 21393, 445, 6655, 50495, 45718, 86882, 71493, 7397, 16595, 77758, 80091, 780, 3783, 16168, 55390, 30565, 34707, 32019, 85772, 90904, 96641, 85382, 61320, 23459, 6965, 97895, 19435, 36616, 9787, 54886, 90036, 92125, 34729, 38960, 66245, 58496, 96129, 46772, 73733, 65067, 53184, 66181, 58382, 3922, 5387, 65890, 77429, 38183, 84541, 27072, 90736, 94570, 99936, 73272, 60375, 10952, 9332, 97636, 39694, 13399, 51220, 5018, 36268, 85523, 34753, 53991, 56651, 17209, 7006, 45423, 49624, 9709, 18987, 4592, 30361, 88433, 48024, 29942, 91592, 8239, 28732, 35824, 4946, 65484, 16979, 33142, 75656, 3209, 22468, 85755, 39194, 87907, 72594, 43707,

=== Chunk 1733 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

3209, 22468, 85755, 39194, 87907, 72594, 43707, 36876, 81362, 15459, 68075, 19741, 18928, 44027, 63719, 21262, 75445, 30250, 51196, 6219, 34048, 23502, 60665, 1631, 62306, 23264, 67398, 49274, 84972, 16739, 94834, 23334, 82672, 92166, 31032, 78520, 93931, 28044, 61781, 76557, 33376, 46480, 26749, 22509, 64281, 54589, 50426, 44636, 45225, 99895, 71585, 17673, 13409, 95493, 90636, 86268, 16980, 7514, 39203, 9907, 27569, 14822, 61552, 41838, 74638, 87542, 72644, 13042, 1869, 96037, 96075, 126, 74862, 40225, 59462, 42920, 58159, 34863, 72917, 85179, 48285, 19993, 84466, 7840, 5972, 54264, 43475, 92314, 4800, 19150, 69554, 56691, 19948, 27419, 59213, 66373, 44592, 46195, 82009, 78601, 17154, 27595, 95329, 36216, 91618, 71112, 10493, 57289, 30769, 54429, 1855, 13489, 74406, 57880, 3088, 92345,

=== Chunk 1734 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

54429, 1855, 13489, 74406, 57880, 3088, 92345, 10824, 87602, 94317, 95410, 79507, 89423, 60715, 37526, 53564, 98388, 48032, 35013, 60838, 99317, 30389, 69656, 32224, 70212, 53067, 31487, 77619, 32138, 56939, 25282, 66232, 54525, 51762, 86251, 15422, 96128, 59093, 39155, 91664, 95086, 64328, 58154, 16901, 57839, 36992, 59934, 61257, 5557, 15425, 57045, 12889, 69846, 29139, 61557, 83756, 32458, 90919, 52963, 14359, 49874, 80682, 84655, 65452, 55068, 43914, 76328, 45679, 35127, 72774, 62715, 91798, 29872, 81354, 80582, 96103, 28903, 50678, 9125, 45643, 11868, 9791, 46321, 41872, 7001, 92742, 89046, 77778, 58288, 57737, 28006, 38887, 4145, 30995, 23181, 22663, 76976, 12037, 94311, 69665, 47087, 243, 85775, 33414, 14113, 25750, 68464, 27502, 33912, 49055, 86698, 68094, 7608, 70775, 62943,

=== Chunk 1735 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

33912, 49055, 86698, 68094, 7608, 70775, 62943, 42776, 34704, 11471, 4417, 99359, 60717, 71140, 87687, 24846, 22480, 56390, 47598, 28920, 1425, 78664, 65311, 25188, 69310, 46708, 56404, 79811, 22070, 75607, 32708, 1979, 67357, 81800, 28625, 58021, 29588, 49578, 16281, 18081, 74281, 57898, 39302, 18506, 70543, 41031, 35986, 1699, 96223, 41042, 13283, 50709, 61933, 91181, 46030, 61266, 66703, 82807, 89387, 67547, 6497, 55088, 61583, 42425, 91409, 85463, 8301, 78781, 80870, 98576, 55880, 33799, 9806, 31789, 1220, 49041, 40852, 98197, 88459, 80809, 30683, 45742, 53320, 25920, 65231, 56346, 207, 17794, 82843, 50215, 57, 47903, 10075, 62437, 2278, 98786, 98119, 45948, 30820, 29230, 1929, 76287, 79090, 85711, 72527, 92053, 26601, 48647, 76929, 14214, 44902, 76505, 40038, 64918, 60383, 35546,

=== Chunk 1736 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

14214, 44902, 76505, 40038, 64918, 60383, 35546, 2544, 40358, 86056, 60688, 18499, 88770, 22849, 63307, 51149, 60424, 47592, 43259, 26180, 16534, 49804, 23756, 9616, 13388, 64930, 99325, 39424, 70127, 92799, 91793, 28812, 71828, 14453, 91106, 666, 62810, 11290, 9647, 22966, 16230, 35343, 84054, 34513, 2255, 89433, 26782, 46009, 53791, 44813, 68657, 49581, 41018, 86354, 2203, 96565, 76773, 2292, 20466, 91806, 21150, 4547, 34076, 35288, 17350, 37117, 89318, 5010, 41980, 98619, 34277, 56047, 96091, 14986, 47946, 557, 12310, 45083, 33215, 41672, 76247, 22120, 98394, 52505, 32913, 13669, 79991, 50390, 84603, 96700, 45380, 83969, 62960, 922, 77322, 89247, 22082, 77155, 58180, 85090, 34045, 78015, 83134, 65175, 12575, 29973, 33374, 66596, 9773, 3090, 5978, 51347, 10092, 21711, 12959, 59636,

=== Chunk 1737 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

3090, 5978, 51347, 10092, 21711, 12959, 59636, 66040, 79673, 11149, 3982, 70175, 26604, 19115, 27400, 34364, 82326, 23104, 1413, 72067, 46839, 39644, 24885, 60701, 72571, 46163, 83030, 62798, 48657, 10336, 45398, 31463, 35149, 93705, 89614, 55496, 94724, 47644, 67168, 252, 67317, 90167, 73396, 79355, 42813, 69604, 60195, 31448, 38177, 8685, 3453, 27967, 34365, 20916, 31161, 32697, 13569, 56538, 97312, 43741, 20268, 62417, 8800, 58889, 887, 59083, 37770, 54497, 3483, 13208, 78264, 63926, 51702, 57788, 62339, 34878, 25061, 9272, 33436, 11559, 24844, 55273, 15700, 86056, 24847, 59543, 88362, 88930, 99160, 76001, 3727, 24347, 62899, 15058, 36773, 22921, 46114, 25650, 24349, 54426, 88951, 56929, 34112, 35932, 96915, 20056, 5065, 11710, 85022, 4786, 58819, 86765, 42917, 16629, 75041, 9382,

=== Chunk 1738 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

4786, 58819, 86765, 42917, 16629, 75041, 9382, 15583, 19171, 72488, 45448, 12527, 50008, 93346, 80955, 45643, 28915, 73390, 67806, 29676, 21950, 45132, 98400, 54683, 46952, 36276, 47913, 48498, 1003, 77209, 65162, 29328, 77900, 23452, 46557, 11635, 60276, 59815, 55051, 47365, 40098, 9110, 42438, 89515, 29366, 57827, 77546, 87805, 52271, 13786, 13027, 80350, 11753, 39876, 30041, 90876, 79402, 47918, 8267, 44250, 20405, 2429, 47678, 66426, 74651, 60939, 19540, 75226, 69460, 30180, 2743, 70832, 70474, 56895, 35632, 7563, 40387, 84892, 72994, 86326, 76410, 12579, 85154, 21588, 97138, 35456, 10816, 66345, 77797, 68559, 33827, 77916, 36264, 33517, 73029, 83578, 19096, 40231, 15099, 56610, 75386, 1213, 72113, 89289, 50868, 23025, 47995, 10864, 37206, 21100, 77996, 15471, 34319, 91648, 20577,

=== Chunk 1739 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

37206, 21100, 77996, 15471, 34319, 91648, 20577, 67231, 99970, 74615, 67606, 25690, 35923, 8601, 25104, 31088, 79805, 51973, 51920, 84434, 80312, 25120, 69047, 95483, 50715, 29121, 89649, 46749, 15222, 93612, 88422, 86352, 65066, 62750, 34466, 64722, 74346, 74135, 11801, 17645, 3812, 92193, 47185, 34855, 70969, 43411, 70828, 3418, 30992, 16477, 82597, 55609, 44222, 41623, 7218, 28642, 22624, 12312, 10349, 65818, 2864, 88496, 75385, 1598, 56445, 37344, 25697, 2769, 68254, 46395, 69019, 20250, 35393, 16111, 71962, 44468, 34732, 99529, 92395, 1285, 41002, 50225, 97701, 69150, 6999, 14127, 2882, 34898, 19302, 44052, 8041, 47837, 65291, 432, 46098, 8936, 28920, 67179, 54431, 81597, 56203, 18857, 65644, 66000, 87428, 47819, 22412, 99383, 69228, 86157, 14117, 95023, 86969, 74639, 58154, 4275,

=== Chunk 1740 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

86157, 14117, 95023, 86969, 74639, 58154, 4275, 52890, 5310, 70266, 52189, 37070, 90901, 25435, 60438, 67789, 21700, 82598, 95286, 97387, 79924, 44033, 5780, 47403, 72271, 65250, 39131, 22041, 98251, 60309, 57013, 1582, 84467, 1141, 21623, 85870, 21842, 59956, 31760, 89107, 68510, 15402, 49597, 57244, 51077, 73507, 92790, 33644, 79234, 31355, 91673, 35535, 86931, 62187, 13454, 66936, 57556, 90153, 7256, 19272, 36508, 16036, 44137, 87064, 47269, 91970, 20794, 3900, 55674, 49311, 39261, 84557, 75459, 97774, 16230, 91469, 37598, 17275, 62318, 1287, 88218, 69983, 56343, 52444, 6720, 58269, 36530, 79221, 14821, 35676, 19580, 97810, 13112, 60622, 94837, 44378, 3430, 61281, 81910, 42891, 51976, 76436, 57016, 11020, 4864, 8852, 31660, 17645, 46208, 82855, 56127, 72673, 46038, 12074, 80563, 36165,

=== Chunk 1741 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

82855, 56127, 72673, 46038, 12074, 80563, 36165, 52039, 74661, 97768, 52559, 49274, 82208, 28035, 37180, 23005, 19487, 57510, 5296, 92608, 41737, 83942, 8223, 24798, 83768, 25029, 88857, 34888, 52171, 63133, 16939, 95122, 31264, 7006, 56696, 84238, 60986, 25622, 22973, 83335, 3681, 92009, 97206, 67773, 68873, 50397, 51845, 81226, 34, 39384, 19872, 14387, 29151, 9105, 86972, 20259, 22695, 99301, 50232, 29296, 9107, 4977, 49045, 9573, 25400, 3430, 1614, 39028, 51323, 45596, 95033, 96890, 30501, 88688, 66127, 99318, 44462, 92340, 9747, 11523, 12154, 69783, 91358, 57856, 13847, 34876, 82518, 39401, 33473, 71995, 98328, 14358, 23599, 42472, 37601, 3994, 46517, 25420, 68254, 15846, 34201, 31710, 26821, 58743, 36653, 43639, 40035, 24876, 87497, 77685, 53880, 3974, 70156, 56738, 54862, 57692,

=== Chunk 1742 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

77685, 53880, 3974, 70156, 56738, 54862, 57692, 24496, 78266, 93074, 85729, 90402, 62515, 42192, 71592, 50427, 95841, 47190, 56716, 90355, 48926, 37564, 85781, 98003, 17932, 1316, 47175, 13691, 21194, 59404, 17063, 31943, 57638, 31343, 10416, 32230, 48887, 48681, 57475, 6488, 2456, 43990, 14847, 71078, 90582, 15894, 14900, 607, 97226, 35692, 18656, 5661, 29793, 86919, 9172, 74191, 71616, 98707, 32106, 3270, 1638, 56606, 33251, 47674, 96531, 83026, 15337, 7690, 59357, 76286, 3004, 9482, 66018, 21242, 35495, 13893, 49569, 85876, 55793, 33537, 40872, 44376, 16546, 70122, 32100, 21875, 20678, 99865, 50303, 44668, 44693, 91958, 32585, 72362, 15100, 80982, 84922, 19799, 6281, 71324, 23553, 84000, 11537, 9987, 11989, 78728, 48801, 22431, 29136, 55355, 1210, 8810, 62511, 73092, 19364, 33795,

=== Chunk 1743 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

55355, 1210, 8810, 62511, 73092, 19364, 33795, 72116, 21347, 20963, 65833, 21516, 60259, 35150, 89862, 30110, 12255, 49310, 62911, 84699, 50812, 87484, 51140, 33180, 23721, 43102, 87331, 64485, 38692, 99280, 82267, 46525, 65494, 66608, 8576, 4325, 62705, 1264, 73176, 71662, 60603, 8940, 72042, 59565, 56845, 60963, 84186, 49349, 93269, 52952, 36143, 53723, 71740, 74724, 231, 22097, 38663, 9335, 43925, 2581, 62739, 98742, 42033, 79802, 79244, 90414, 16019, 45066, 39148, 60390, 30395, 97585, 2146, 83533, 33083, 21610, 49350, 52022, 11136, 80338, 37984, 48941, 1418, 15299, 83744, 77547, 23283, 17848, 15580, 96413, 90652, 55304, 80543, 90444, 39736, 25184, 97581, 83751, 2637, 31870, 36141, 56952, 30820, 53485, 39300, 86380, 83260, 5938, 8041, 31166, 81747, 90246, 59005, 17518, 37891, 76974,

=== Chunk 1744 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

31166, 81747, 90246, 59005, 17518, 37891, 76974, 55195, 12518, 76752, 26574, 65172, 91410, 65445, 25579, 92653, 6594, 60094, 9417, 12545, 59743, 62055, 98462, 9600, 29863, 67981, 67879, 46846, 7392, 98745, 70390, 4095, 5956, 36155, 68863, 90195, 95964, 77112, 28063, 90134, 52560, 93874, 49959, 42027, 9440, 34752, 52771, 19849, 87997, 87379, 63548, 59569, 52334, 62692, 5080, 40490, 91007, 48117, 37029, 94759, 77285, 39529, 1649, 76416, 5543, 10795, 92415, 34982, 93706, 21511, 34713, 39388, 93102, 26664, 72093, 91344, 48561, 65561, 15644, 4333, 88512, 69922, 628, 30835, 99378, 48424, 50653, 73012, 1566, 32326, 33500, 19250, 87475, 30050, 19891, 9056, 59796, 34813, 54197, 50608, 20856, 65886, 4488, 76521, 1152, 18755, 61160, 48431, 12204, 97447, 76459, 49690, 97698, 70421, 99048, 44070,

=== Chunk 1745 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

97447, 76459, 49690, 97698, 70421, 99048, 44070, 73817, 68521, 62422, 7982, 16182, 16317, 39559, 71648, 86796, 72009, 38687, 7436, 50020, 98498, 45169, 93147, 22197, 43132, 61129, 88097, 71996, 89492, 78939, 63460, 13205, 47621, 59854, 93737, 13692, 54880, 36641, 91097, 34018, 13116, 85272, 16665, 64136, 54215, 86626, 1344, 43285, 25293, 79496, 65273, 54408, 77274, 39154, 3993, 15335, 51165, 22634, 97282, 29729, 83357, 54438, 2147, 70104, 19345, 33103, 2427, 79886, 134, 25065, 88081, 27753, 35797, 65751, 54901, 20082, 15923, 92378, 43940, 52952, 41531, 80001, 94902, 95656, 36848, 67464, 42468, 9211, 80210, 37793, 15925, 42715, 13213, 79743, 17011, 61664, 43421, 33152, 3001, 8827, 46763, 10915, 28257, 4300, 74589, 89336, 31085, 57587, 24351, 73466, 43982, 5703, 22216, 49434, 67920, 81581,

=== Chunk 1746 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

73466, 43982, 5703, 22216, 49434, 67920, 81581, 8070, 46878, 53676, 89532, 84353, 49629, 5163, 86758, 67050, 77195, 45882, 4109, 57483, 28697, 55679, 5357, 8867, 10287, 62530, 31985, 46750, 84278, 40659, 87414, 98812, 31866, 61325, 37999, 72313, 59255, 73829, 85009, 94233, 86222, 88822, 39680, 51717, 3151, 66283, 17161, 54518, 7700, 7066, 64517, 6455, 38964, 55271, 75958, 28831, 13335, 78981, 74682, 93311, 137, 50773, 19372, 22942, 66193, 7933, 75421, 13298, 10190, 10491, 28390, 2349, 93218, 11645, 64538, 87658, 15518, 75241, 82168, 89629, 86670, 40543, 50129, 72279, 19581, 5069, 97366, 81016, 38763, 17769, 24571, 45101, 97465, 5993, 38154, 99649, 74567, 14153, 21776, 11101, 36717, 87277, 99884, 45629, 47067, 32780, 48605, 38675, 85488, 16652, 56868, 90644, 96598, 70106, 82602, 33629,

=== Chunk 1747 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

16652, 56868, 90644, 96598, 70106, 82602, 33629, 39929, 56605, 87478, 43391, 93309, 22052, 79389, 2886, 11742, 36552, 60021, 54743, 24589, 50454, 53864, 96536, 38350, 69221, 94679, 96750, 26718, 71884, 91060, 12596, 81109, 78873, 92336, 87173, 90842, 23954, 63750, 90190, 55545, 39966, 58230, 94228, 9983, 27601, 73590, 70753, 19505, 94838, 68347, 37238, 94375, 53468, 26863, 57021, 26752, 68456, 45976, 7388, 55056, 13700, 66683, 77694, 18425, 12599, 88877, 6592, 62482, 18514, 82483, 4059, 49734, 36353, 63711, 91839, 29652, 20495, 80155, 57275, 89396, 16259, 97239, 12774, 73692, 41461, 12599, 56618, 4314, 75868, 38425, 59913, 48445, 11992, 54171, 61090, 77076, 22021, 90628, 592, 41149, 59668, 8392, 73326, 70286, 39969, 28559, 90760, 12728, 22485, 38024, 56805, 72248, 62374, 93814, 56603,

=== Chunk 1748 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

22485, 38024, 56805, 72248, 62374, 93814, 56603, 36766, 20483, 29108, 69899, 54716, 92157, 8007, 68409, 99130, 83088, 62064, 144, 57140, 91156, 44663, 74510, 28720, 28887, 95520, 33241, 13690, 51013, 66789, 91294, 39465, 95469, 49585, 50342, 16904, 56808, 53684, 18149, 21524, 32434, 7033, 59557, 18526, 95720, 80121, 53717, 65132, 53858, 3129, 64755, 24806, 70014, 94176, 80436, 71800, 30134, 33173, 46264, 26137, 75713, 28208, 10992, 77348, 72817, 40145, 26088, 21285, 73042, 66484, 15626, 21952, 76775, 42444, 6457, 63242, 11260, 54694, 93444, 51599, 80659, 71495, 59436, 91785, 73158, 67306, 76508, 91721, 78035, 54869, 94827, 4616, 66911, 35121, 79145, 3920, 27705, 6077, 5951, 22868, 95675, 31171, 46438, 16183, 90960, 28559, 12650, 89791, 5334, 56919, 44770, 17565, 53393, 11235, 99655,

=== Chunk 1749 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

5334, 56919, 44770, 17565, 53393, 11235, 99655, 22951, 59332, 78189, 47541, 50688, 7868, 20470, 66262, 81947, 75386, 26269, 8458, 86601, 31819, 74789, 45359, 59133, 16555, 25175, 97976, 4093, 82424, 17599, 8592, 44129, 47207, 98817, 3993, 81424, 72002, 14499, 99665, 27725, 74553, 30765, 80152, 55584, 93326, 96954, 30835, 15545, 8739, 20963, 79883, 3943, 22904, 53927, 20392, 28568, 36203, 24243, 13634, 30241, 74395, 32809, 96123, 64831, 87880, 65959, 20690, 72019, 1078, 1745, 27088, 88529, 48743, 72766, 9200, 20698, 37956, 32501, 21765, 5456, 57915, 85388, 6353, 48909, 12211, 66969, 35961, 271, 66357, 89455, 91880, 48750, 12829, 709, 61938, 25822, 94229, 28856, 93512, 59539, 98099, 17304, 77838, 44476, 53337, 34408, 13134, 52756, 2460, 82552, 3181, 79185, 14560, 53962, 20638, 91608, 16060,

=== Chunk 1750 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

3181, 79185, 14560, 53962, 20638, 91608, 16060, 83763, 80765, 71461, 77105, 1350, 62806, 533, 1827, 91473, 38048, 41104, 59689, 67601, 77280, 90046, 13874, 64463, 22874, 42209, 35901, 52004, 3017, 73522, 37798, 82560, 41431, 70841, 72906, 99966, 74204, 94450, 97093, 55200, 63605, 98097, 28731, 62612, 21753, 98228, 93483, 83959, 47443, 60507, 68952, 41553, 28238, 84748, 87948, 81648, 48497, 29304, 92993, 1250, 62819, 4916, 36340, 6264, 62861, 24981, 72707, 96637, 13477, 94568, 79662, 67125, 13883, 78906, 47303, 6845, 85236, 2548, 36519, 93614, 79204, 50412, 61959, 85700, 4800, 98600, 28456, 25639, 66786, 78043, 41685, 20649, 48024, 61669, 45861, 50920, 81257, 48988, 61927, 75672, 4597, 22160, 52118, 43704, 46602, 39978, 87993, 91268, 59623, 78492, 80452, 73226, 15673, 25000, 91346, 19411,

=== Chunk 1751 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

78492, 80452, 73226, 15673, 25000, 91346, 19411, 31593, 41439, 32458, 76626, 83509, 11734, 15172, 6204, 91101, 53806, 56872, 34644, 86140, 15379, 99041, 38954, 9485, 72746, 35802, 52522, 43861, 55246, 71723, 15138, 73953, 49241, 80268, 72534, 51332, 862, 56139, 29038, 95060, 87762, 3537, 36833, 95134, 43234, 21821, 50372, 19963, 14537, 7743, 99988, 19814, 10409, 46316, 94909, 82056, 34814, 76070, 14431, 19808, 9138, 10107, 72747, 76360, 64969, 72420, 57298, 73337, 1092, 50757, 82779, 82283, 81662, 60064, 44324, 97633, 18546, 86655, 13623, 29278, 18145, 77557, 55193, 97046, 16813, 46822, 17640, 24407, 1648, 27760, 46156, 36317, 9572, 33885, 17241, 31190, 72577, 74632, 34306, 13532, 82934, 17653, 90196, 17569, 1195, 94533, 1785, 14079, 53823, 36039, 38293, 10499, 25996, 17919, 17775, 82137,

=== Chunk 1752 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

36039, 38293, 10499, 25996, 17919, 17775, 82137, 61091, 87037, 54862, 14250, 86348, 66202, 29160, 6857, 82758, 74672, 31383, 66637, 36939, 4434, 78175, 51977, 94507, 49712, 77798, 20749, 12807, 7605, 27805, 35523, 46808, 93285, 18164, 82679, 94642, 54265, 42967, 14329, 60799, 37518, 89214, 24196, 46991, 2246, 10739, 49335, 63458, 21711, 70470, 37318, 10334, 31199, 20092, 25850, 98167, 93952, 19082, 92091, 94719, 62500, 11090, 64723, 56363, 39439, 64377, 70009, 61914, 94347, 98169, 28996, 32103, 22804, 78934, 939, 92408, 66888, 9870, 38777, 87901, 72488, 87911, 24955, 54019, 52939, 14843, 74475, 30004, 48451, 61505, 56924, 38228, 25740, 86307, 33182, 88115, 42208, 14926, 43483, 96176, 94678, 1372, 69037, 4418, 54696, 12865, 18591, 32249, 61284, 99269, 82537, 53923, 75171, 52963, 82016,

=== Chunk 1753 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

61284, 99269, 82537, 53923, 75171, 52963, 82016, 65938, 6070, 74983, 82844, 2031, 13023, 36900, 65176, 15851, 42420, 5611, 34357, 4229, 62968, 90842, 65618, 18943, 72826, 57326, 9398, 55950, 57246, 82142, 69845, 74193, 17392, 39558, 3894, 71351, 17800, 42863, 38226, 49762, 83380, 67348, 98797, 37393, 49419, 99379, 22110, 29993, 18580, 12621, 6540, 60437, 82793, 82963, 70567, 61916, 88170, 99020, 42100, 94015, 71494, 60055, 28177, 42828, 41783, 32945, 7178, 68743, 87574, 71950, 19679, 72667, 8794, 3496, 47204, 44998, 44424, 61927, 12982, 18249, 83032, 31449, 14831, 87554, 60444, 45411, 25603, 79296, 35933, 34591, 48091, 20148, 91927, 39965, 2035, 7913, 66837, 18925, 82814, 77992, 12197, 41227, 18476, 27648, 92569, 11478, 82879, 5618, 3434, 98822, 95399, 84697, 71575, 9661, 97451, 63312,

=== Chunk 1754 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

98822, 95399, 84697, 71575, 9661, 97451, 63312, 54273, 70919, 28565, 25086, 39626, 91069, 22646, 88443, 45339, 66406, 54488, 54367, 45993, 87062, 23033, 1536, 7085, 56507, 15017, 84041, 94867, 39256, 81530, 42457, 18235, 61187, 54792, 42708, 25221, 24433, 39207, 51027, 13787, 40006, 2537, 28987, 86268, 7351};

=== Chunk 1755 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2187.minimum-time-to-complete-trips\MinimumTimeToCompleteTripsTest.java

int totalTrips = 9765277;

        Assertions.assertEquals(34766088, minimumTimeToCompleteTrips.minimumTime(time, totalTrips));
    }
}

=== Chunk 1756 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2215.find-the-difference-of-two-arrays\FindTheDifferenceOfTwoArrays.java

import java.util.*;

=== Chunk 1757 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2215.find-the-difference-of-two-arrays\FindTheDifferenceOfTwoArrays.java

class FindTheDifferenceOfTwoArrays {
    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> set2 = new HashSet<>();
        for (int num: nums1) {
            set1.add(num);
        }
        for (int num: nums2) {
            set2.add(num);
        }
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> answer1 = new ArrayList<>();
        for (int num: set1) {
            if (!set2.contains(num)) {
                answer1.add(num);
            }
        }
        List<Integer> answer2 = new ArrayList<>();
        for (int num: set2) {
            if (!set1.contains(num)) {
                answer2.add(num);
            }
        }
        res.add(answer1);

=== Chunk 1758 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2215.find-the-difference-of-two-arrays\FindTheDifferenceOfTwoArrays.java

}
        res.add(answer1);
        res.add(answer2);
        return res;
    }
}

=== Chunk 1759 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2215.find-the-difference-of-two-arrays\FindTheDifferenceOfTwoArraysTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 1760 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2215.find-the-difference-of-two-arrays\FindTheDifferenceOfTwoArraysTest.java

public class FindTheDifferenceOfTwoArraysTest {
    FindTheDifferenceOfTwoArrays findTheDifferenceOfTwoArrays = new FindTheDifferenceOfTwoArrays();

    @Test
    void Example1() {
        int[] nums1 = {1, 2, 3}, nums2 = {2, 4, 6};

        List<List<Integer>> results = new ArrayList<>();
        results.add(Arrays.asList(1, 3));
        results.add(Arrays.asList(4, 6));
        Assertions.assertEquals(results, findTheDifferenceOfTwoArrays.findDifference(nums1, nums2));
    }

    @Test
    void Example2() {
        int[] nums1 = {1, 2, 3, 3}, nums2 = {1, 1, 2, 2};

        List<List<Integer>> results = new ArrayList<>();
        results.add(List.of(3));
        results.add(new ArrayList<>());

=== Chunk 1761 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2215.find-the-difference-of-two-arrays\FindTheDifferenceOfTwoArraysTest.java

results.add(new ArrayList<>());
        Assertions.assertEquals(results, findTheDifferenceOfTwoArrays.findDifference(nums1, nums2));
    }
}

=== Chunk 1762 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2225.find-players-with-zero-or-one-losses\FindPlayersWithZeroOrOneLosses.java

import java.util.*;

=== Chunk 1763 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2225.find-players-with-zero-or-one-losses\FindPlayersWithZeroOrOneLosses.java

class FindPlayersWithZeroOrOneLosses {
    public List<List<Integer>> findWinners(int[][] matches) {
        Map<Integer, Integer> lossesCnt = new HashMap<>();

        for (int[] match : matches) {
            lossesCnt.put(match[0], lossesCnt.getOrDefault(match[0], 0));
            lossesCnt.put(match[1], lossesCnt.getOrDefault(match[1], 0) + 1);
        }

        List<List<Integer>> ans = Arrays.asList(new ArrayList<>(), new ArrayList<>());
        for (Integer player : lossesCnt.keySet()) {
            if (lossesCnt.get(player) == 0) {
                ans.get(0).add(player);
            } else if (lossesCnt.get(player) == 1) {
                ans.get(1).add(player);
            }
        }

        Collections.sort(ans.get(0));

=== Chunk 1764 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2225.find-players-with-zero-or-one-losses\FindPlayersWithZeroOrOneLosses.java

Collections.sort(ans.get(0));
        Collections.sort(ans.get(1));

        return ans;
    }
}

=== Chunk 1765 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2225.find-players-with-zero-or-one-losses\FindPlayersWithZeroOrOneLossesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

=== Chunk 1766 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2225.find-players-with-zero-or-one-losses\FindPlayersWithZeroOrOneLossesTest.java

public class FindPlayersWithZeroOrOneLossesTest {
    FindPlayersWithZeroOrOneLosses findPlayersWithZeroOrOneLosses = new FindPlayersWithZeroOrOneLosses();

    @Test
    void Example1() {
        int[][] matches = {{1, 3}, {2, 3}, {3, 6}, {5, 6}, {5, 7}, {4, 5}, {4, 8}, {4, 9}, {10, 4}, {10, 9}};
        List<List<Integer>> results = findPlayersWithZeroOrOneLosses.findWinners(matches);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(1, 2, 10));
        expectedResults.add(Arrays.asList(4, 5, 7, 8));

        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[][] matches = {{2, 3}, {1, 3}, {5, 4}, {6, 4}};

=== Chunk 1767 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2225.find-players-with-zero-or-one-losses\FindPlayersWithZeroOrOneLossesTest.java

List<List<Integer>> results = findPlayersWithZeroOrOneLosses.findWinners(matches);
        List<List<Integer>> expectedResults = new ArrayList<>();
        expectedResults.add(Arrays.asList(1, 2, 5, 6));
        expectedResults.add(new ArrayList<>());

        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1768 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2244.minimum-rounds-to-complete-all-tasks\MinimumRoundsToCompleteAllTasks.java

import java.util.HashMap;
import java.util.Map;

class MinimumRoundsToCompleteAllTasks {
    public int minimumRounds(int[] tasks) {
        Map<Integer, Integer> freq = new HashMap<>();
        for (int i = 0; i < tasks.length; i++)
            freq.put(tasks[i], freq.getOrDefault(tasks[i], 0) + 1);

        int ans = 0;
        for (int count : freq.values()) {
            if (count == 1)
                return -1;
            if (count % 3 == 0)
                ans += count / 3;
            else
                ans += count / 3 + 1;
        }

        return ans;
    }
}

=== Chunk 1769 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2244.minimum-rounds-to-complete-all-tasks\MinimumRoundsToCompleteAllTasksTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MinimumRoundsToCompleteAllTasksTest {
    MinimumRoundsToCompleteAllTasks minimumRoundsToCompleteAllTasks = new MinimumRoundsToCompleteAllTasks();

    @Test
    void Example1() {
        int[] tasks = {2, 2, 3, 3, 2, 4, 4, 4, 4, 4};

        Assertions.assertEquals(4, minimumRoundsToCompleteAllTasks.minimumRounds(tasks));
    }

    @Test
    void Example2() {
        int[] tasks = {2, 3, 3};

        Assertions.assertEquals(-1, minimumRoundsToCompleteAllTasks.minimumRounds(tasks));
    }
}

=== Chunk 1770 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2246.longest-path-with-different-adjacent-characters\LongestPathWithDifferentAdjacentCharacters.java

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

=== Chunk 1771 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2246.longest-path-with-different-adjacent-characters\LongestPathWithDifferentAdjacentCharacters.java

class LongestPathWithDifferentAdjacentCharacters {
    private int longestPath = 1;

    public int longestPath(int[] parent, String s) {
        int n = parent.length;
        Map<Integer, List<Integer>> children = new HashMap<>();
        for (int i = 1; i < n; i++)
            children.computeIfAbsent(parent[i], value -> new ArrayList<>()).add(i);
        dfs(0, children, s);

        return longestPath;
    }

    private int dfs(int currentNode, Map<Integer, List<Integer>> children, String s) {
        if (!children.containsKey(currentNode))
            return 1;

        int longestChain = 0, secondLongestChain = 0;
        for (int child : children.get(currentNode)) {
            int longestChainStartingFromChild = dfs(child, children, s);

=== Chunk 1772 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2246.longest-path-with-different-adjacent-characters\LongestPathWithDifferentAdjacentCharacters.java

if (s.charAt(currentNode) == s.charAt(child))
                continue;
            if (longestChainStartingFromChild > longestChain) {
                secondLongestChain = longestChain;
                longestChain = longestChainStartingFromChild;
            } else if (longestChainStartingFromChild > secondLongestChain)
                secondLongestChain = longestChainStartingFromChild;
        }

        longestPath = Math.max(longestPath, longestChain + secondLongestChain + 1);
        return longestChain + 1;
    }
}

=== Chunk 1773 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2246.longest-path-with-different-adjacent-characters\LongestPathWithDifferentAdjacentCharactersTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class LongestPathWithDifferentAdjacentCharactersTest {
    LongestPathWithDifferentAdjacentCharacters longestPathWithDifferentAdjacentCharacters = new LongestPathWithDifferentAdjacentCharacters();

    @Test
    void Example1() {
        int[] parent = {-1, 0, 0, 1, 1, 2};
        String s = "abacbe";

        Assertions.assertEquals(3, longestPathWithDifferentAdjacentCharacters.longestPath(parent, s));
    }

    @Test
    void Example2() {
        int[] parent = {-1, 0, 0, 0};
        String s = "aabc";

        Assertions.assertEquals(3, longestPathWithDifferentAdjacentCharacters.longestPath(parent, s));
    }
}

=== Chunk 1774 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2256.minimum-average-difference\MinimumAverageDifference.java

class MinimumAverageDifference {
    public int minimumAverageDifference(int[] nums) {
        int n = nums.length;
        long[] prefixSum = new long[n + 1];
        long[] suffixSum = new long[n + 1];
        int ans = -1;
        int minDiff = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++)
            prefixSum[i + 1] = prefixSum[i] + nums[i];

        for (int i = n - 1; i >= 0; i--)
            suffixSum[i] = suffixSum[i + 1] + nums[i];

        for (int i = 0; i < n; i++) {
            long leftAverage = prefixSum[i + 1];
            leftAverage /= (i + 1);

            long rightAverage = suffixSum[i + 1];
            if (i != n -1)
                rightAverage /= (n - 1 - i);

=== Chunk 1775 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2256.minimum-average-difference\MinimumAverageDifference.java

rightAverage /= (n - 1 - i);

            int currDifference = (int) Math.abs(leftAverage - rightAverage);
            if (currDifference < minDiff) {
                minDiff = currDifference;
                ans = i;
            }
        }
        return ans;
    }
}

=== Chunk 1776 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2256.minimum-average-difference\MinimumAverageDifference2.java

class MinimumAverageDifference2 {
    public int minimumAverageDifference(int[] nums) {
        int n = nums.length;
        int ans = -1;
        int minDiff = Integer.MAX_VALUE;
        long currPrefixSum = 0;

        long totalSum = 0;
        for (int i = 0; i < n; i++)
            totalSum += nums[i];

        for (int i = 0; i < n; i++) {
            currPrefixSum += nums[i];

            long leftAverage = currPrefixSum;
            leftAverage /= (i + 1);

            long rightAverage = totalSum - currPrefixSum;
            if (i != n - 1)
                rightAverage /= (n - 1 - i);

            int currDifference = (int) Math.abs(leftAverage - rightAverage);
            if (currDifference < minDiff) {
                minDiff = currDifference;

=== Chunk 1777 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2256.minimum-average-difference\MinimumAverageDifference2.java

minDiff = currDifference;
                ans = i;
            }
        }
        return ans;
    }
}

=== Chunk 1778 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2256.minimum-average-difference\MinimumAverageDifferenceTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1779 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2256.minimum-average-difference\MinimumAverageDifferenceTest.java

public class MinimumAverageDifferenceTest {
    MinimumAverageDifference minimumAverageDifference = new MinimumAverageDifference();
    MinimumAverageDifference2 minimumAverageDifference2 = new MinimumAverageDifference2();

    @Test
    void Example1() {
        int[] nums = {2, 5, 3, 9, 5, 3};
        int results = minimumAverageDifference.minimumAverageDifference(nums);
        int expectedResults = 3;

        Assertions.assertEquals(expectedResults, results);

        results = minimumAverageDifference2.minimumAverageDifference(nums);
        Assertions.assertEquals(expectedResults, results);
    }

    @Test
    void Example2() {
        int[] nums = {0};
        int results = minimumAverageDifference.minimumAverageDifference(nums);

=== Chunk 1780 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2256.minimum-average-difference\MinimumAverageDifferenceTest.java

int expectedResults = 0;

        Assertions.assertEquals(expectedResults, results);

        results = minimumAverageDifference2.minimumAverageDifference(nums);
        Assertions.assertEquals(expectedResults, results);
    }
}

=== Chunk 1781 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2279.maximum-bags-with-full-capacity-of-rocks\MaximumBagsWithFullCapacityOfRocks.java

import java.util.Arrays;

class MaximumBagsWithFullCapacityOfRocks {
    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {
        int n = capacity.length;
        for (int i = 0; i < n; i++) {
            capacity[i] -= rocks[i];
        }
        Arrays.sort(capacity);
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (additionalRocks < capacity[i]) return ans;
            additionalRocks -= capacity[i];
            ans++;
        }
        return ans;
    }
}

=== Chunk 1782 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2279.maximum-bags-with-full-capacity-of-rocks\MaximumBagsWithFullCapacityOfRocksTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MaximumBagsWithFullCapacityOfRocksTest {
    MaximumBagsWithFullCapacityOfRocks maximumBagsWithFullCapacityOfRocks = new MaximumBagsWithFullCapacityOfRocks();

    @Test
    void Example1() {
        int[] capacity = {2, 3, 4, 5},  rocks = {1, 2, 4, 4};
        int additionalRocks = 2;

        Assertions.assertEquals(3, maximumBagsWithFullCapacityOfRocks.maximumBags(capacity, rocks, additionalRocks));
    }

    @Test
    void Example2() {
        int[] capacity = {10, 2, 2},  rocks = {2, 2, 0};
        int additionalRocks = 100;

        Assertions.assertEquals(3, maximumBagsWithFullCapacityOfRocks.maximumBags(capacity, rocks, additionalRocks));
    }
}

=== Chunk 1783 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2300.successful-pairs-of-spells-and-potions\SuccessfulPairsOfSpellsAndPotions.java

import java.util.Arrays;

class SuccessfulPairsOfSpellsAndPotions {
    public int[] successfulPairs(int[] spells, int[] potions, long success) {
        int n = spells.length;
        int m = potions.length;
        int[] res = new int[n];
        Arrays.sort(potions);
        for (int i = 0; i < n; i++) {
            int x = spells[i];
            int l = 0, r = m;
            while (l < r) {
                int mid = l + (r - l) / 2;
                if ((long) x * potions[mid] >= success) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            if (l < m) {
                res[i] = m - l;
            }
        }
        return res;
    }
}

=== Chunk 1784 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2300.successful-pairs-of-spells-and-potions\SuccessfulPairsOfSpellsAndPotionsTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class SuccessfulPairsOfSpellsAndPotionsTest {
    SuccessfulPairsOfSpellsAndPotions successfulPairsOfSpellsAndPotions = new SuccessfulPairsOfSpellsAndPotions();

    @Test
    void Example1() {
        int[] spells = {5, 1, 3}, potions = {1, 2, 3, 4, 5};
        int success = 7;

        Assertions.assertArrayEquals(new int[]{4, 0, 3}, successfulPairsOfSpellsAndPotions.successfulPairs(spells, potions, success));
    }

    @Test
    void Example2() {
        int[] spells = {3, 1, 2}, potions = {8, 5, 8};
        int success = 16;

        Assertions.assertArrayEquals(new int[]{2, 0, 2}, successfulPairsOfSpellsAndPotions.successfulPairs(spells, potions, success));
    }
}

=== Chunk 1785 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2316.count-unreachable-pairs-of-nodes-in-an-undirected-graph\CountUnreachablePairsOfNodesInAnUndirectedGraph.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 1786 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2316.count-unreachable-pairs-of-nodes-in-an-undirected-graph\CountUnreachablePairsOfNodesInAnUndirectedGraph.java

class CountUnreachablePairsOfNodesInAnUndirectedGraph {
    List<Integer>[] graph;
    boolean[] visited;
    int count;

    public long countPairs(int n, int[][] edges) {
        graph = new List[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] edge : edges) {
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }
        visited = new boolean[n];
        long res = 0L;
        for (int i = 0, total = 0; i < n; i++) {
            if (!visited[i]) {
                count = 0;
                dfs(i);
                res += (long) count * total;
                total += count;
            }
        }
        return res;
    }

    private void dfs(int x) {

=== Chunk 1787 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2316.count-unreachable-pairs-of-nodes-in-an-undirected-graph\CountUnreachablePairsOfNodesInAnUndirectedGraph.java

}

    private void dfs(int x) {
        visited[x] = true;
        count++;
        for (int y : graph[x]) {
            if (!visited[y]) {
                dfs(y);
            }
        }
    }
}

=== Chunk 1788 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2316.count-unreachable-pairs-of-nodes-in-an-undirected-graph\CountUnreachablePairsOfNodesInAnUndirectedGraphTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class CountUnreachablePairsOfNodesInAnUndirectedGraphTest {
    CountUnreachablePairsOfNodesInAnUndirectedGraph countUnreachablePairsOfNodesInAnUndirectedGraph = new CountUnreachablePairsOfNodesInAnUndirectedGraph();

    @Test
    void Example1() {
        int n = 3;
        int[][] edges = {{0, 1}, {0, 2}, {1, 2}};

        Assertions.assertEquals(0, countUnreachablePairsOfNodesInAnUndirectedGraph.countPairs(n, edges));
    }

    @Test
    void Example2() {
        int n = 7;
        int[][] edges = {{0, 2}, {0, 5}, {2, 4}, {1, 6}, {5, 4}};

        Assertions.assertEquals(14, countUnreachablePairsOfNodesInAnUndirectedGraph.countPairs(n, edges));
    }
}

=== Chunk 1789 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2348.number-of-zero-filled-subarrays\NumberOfZeroFilledSubarrays.java

class NumberOfZeroFilledSubarrays {
    public long zeroFilledSubarray(int[] nums) {
        long res = 0L;
        int c = 0;
        for (int num : nums) {
            if (num != 0) {
                c = 0;
            } else {
                res += ++c;
            }
        }
        return res;
    }
}

=== Chunk 1790 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2348.number-of-zero-filled-subarrays\NumberOfZeroFilledSubarraysTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class NumberOfZeroFilledSubarraysTest {
    NumberOfZeroFilledSubarrays numberOfZeroFilledSubarrays = new NumberOfZeroFilledSubarrays();

    @Test
    void Example1() {
        int[] nums = {1, 3, 0, 0, 2, 0, 0, 4};

        Assertions.assertEquals(6, numberOfZeroFilledSubarrays.zeroFilledSubarray(nums));
    }

    @Test
    void Example2() {
        int[] nums = {0, 0, 0, 2, 0, 0};

        Assertions.assertEquals(9, numberOfZeroFilledSubarrays.zeroFilledSubarray(nums));
    }

    @Test
    void Example3() {
        int[] nums = {2, 10, 2019};

        Assertions.assertEquals(0, numberOfZeroFilledSubarrays.zeroFilledSubarray(nums));
    }
}

=== Chunk 1791 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2359.find-closest-node-to-given-two-nodes\FindClosestNodeToGivenTwoNodes.java

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

=== Chunk 1792 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2359.find-closest-node-to-given-two-nodes\FindClosestNodeToGivenTwoNodes.java

class FindClosestNodeToGivenTwoNodes {
    int n;

    public int closestMeetingNode(int[] edges, int node1, int node2) {
        n = edges.length;
        int[] dist1 = new int[n], dist2 = new int[n];
        Arrays.fill(dist1, Integer.MAX_VALUE);
        Arrays.fill(dist2, Integer.MAX_VALUE);

        bfs(node1, edges, dist1);
        bfs(node2, edges, dist2);

        int minDistNode = -1, minDistTillNow = Integer.MAX_VALUE;
        for (int currNode = 0; currNode < n; currNode++) {
            if (minDistTillNow > Math.max(dist1[currNode], dist2[currNode])) {
                minDistNode = currNode;
                minDistTillNow = Math.max(dist1[currNode], dist2[currNode]);
            }
        }

        return minDistNode;
    }

=== Chunk 1793 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2359.find-closest-node-to-given-two-nodes\FindClosestNodeToGivenTwoNodes.java

return minDistNode;
    }

    private void bfs(int startNode, int[] edges, int[] dist) {
        Queue<Integer> q = new LinkedList<>();
        q.offer(startNode);

        boolean[] visited = new boolean[n];
        Arrays.fill(visited, false);
        dist[startNode] = 0;

        while (!q.isEmpty()) {
            int node = q.poll();
            if (visited[node]) {
                continue;
            }
            visited[node] = true;
            int neighbor = edges[node];
            if (neighbor != -1 && !visited[neighbor]) {
                dist[neighbor] = dist[node] + 1;
                q.offer(neighbor);
            }
        }
    }
}

=== Chunk 1794 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2359.find-closest-node-to-given-two-nodes\FindClosestNodeToGivenTwoNodes2.java

import java.util.Arrays;

=== Chunk 1795 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2359.find-closest-node-to-given-two-nodes\FindClosestNodeToGivenTwoNodes2.java

class FindClosestNodeToGivenTwoNodes2 {
    int n;

    public int closestMeetingNode(int[] edges, int node1, int node2) {
        n = edges.length;
        int[] dist1 = new int[n], dist2 = new int[n];
        Arrays.fill(dist1, Integer.MAX_VALUE);
        Arrays.fill(dist2, Integer.MAX_VALUE);
        dist1[node1] = 0;
        dist2[node2] = 0;

        boolean[] visited1 = new boolean[n], visited2 = new boolean[n];

        dfs(node1, edges, dist1, visited1);
        dfs(node2, edges, dist2, visited2);

        int minDistNode = -1, minDistTillNow = Integer.MAX_VALUE;
        for (int currNode = 0; currNode < n; currNode++) {
            if (minDistTillNow > Math.max(dist1[currNode], dist2[currNode])) {
                minDistNode = currNode;

=== Chunk 1796 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2359.find-closest-node-to-given-two-nodes\FindClosestNodeToGivenTwoNodes2.java

minDistNode = currNode;
                minDistTillNow = Math.max(dist1[currNode], dist2[currNode]);
            }
        }

        return minDistNode;
    }

    private void dfs(int node, int[] edges, int[] dist, boolean[] visited) {
        visited[node] = true;
        int neighbor = edges[node];
        if (neighbor != -1 && !visited[neighbor]) {
            dist[neighbor] = dist[node] + 1;
            dfs(neighbor, edges, dist, visited);
        }
    }
}

=== Chunk 1797 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2359.find-closest-node-to-given-two-nodes\FindClosestNodeToGivenTwoNodesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1798 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2359.find-closest-node-to-given-two-nodes\FindClosestNodeToGivenTwoNodesTest.java

public class FindClosestNodeToGivenTwoNodesTest {
    FindClosestNodeToGivenTwoNodes findClosestNodeToGivenTwoNodes = new FindClosestNodeToGivenTwoNodes();
    FindClosestNodeToGivenTwoNodes2 findClosestNodeToGivenTwoNodes2 = new FindClosestNodeToGivenTwoNodes2();

    @Test
    void Example1() {
        int[] edges = {2, 2, 3, -1};
        int node1 = 0, node2 = 1;

        Assertions.assertEquals(2, findClosestNodeToGivenTwoNodes.closestMeetingNode(edges, node1, node2));
        Assertions.assertEquals(2, findClosestNodeToGivenTwoNodes2.closestMeetingNode(edges, node1, node2));
    }

    @Test
    void Example2() {
        int[] edges = {1, 2, -1};
        int node1 = 0, node2 = 2;

=== Chunk 1799 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2359.find-closest-node-to-given-two-nodes\FindClosestNodeToGivenTwoNodesTest.java

int node1 = 0, node2 = 2;

        Assertions.assertEquals(2, findClosestNodeToGivenTwoNodes.closestMeetingNode(edges, node1, node2));
        Assertions.assertEquals(2, findClosestNodeToGivenTwoNodes2.closestMeetingNode(edges, node1, node2));
    }
}

=== Chunk 1800 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2389.longest-subsequence-with-limited-sum\LongestSubsequenceWithLimitedSum.java

import java.util.Arrays;

class LongestSubsequenceWithLimitedSum {
    public int[] answerQueries(int[] nums, int[] queries) {
        int m = queries.length;
        int[] ans = new int[m];
        Arrays.sort(nums);

        for (int i = 0; i < m; i++) {
            int count = 0, query = queries[i];
            for (int num : nums) {
                if (query >= num) {
                    count++;
                    query -= num;
                } else
                    break;
            }
            ans[i] = count;
        }
        return ans;
    }
}

=== Chunk 1801 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2389.longest-subsequence-with-limited-sum\LongestSubsequenceWithLimitedSum2.java

import java.util.Arrays;

=== Chunk 1802 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2389.longest-subsequence-with-limited-sum\LongestSubsequenceWithLimitedSum2.java

class LongestSubsequenceWithLimitedSum2 {
    public int[] answerQueries(int[] nums, int[] queries) {
        Arrays.sort(nums);
        for (int i = 1; i < nums.length; i++)
            nums[i] += nums[i - 1];

        int m = queries.length;
        int[] ans = new int[m];
        for (int i = 0; i < m; i++) {
            int index = binarySearch(nums, queries[i]);
            ans[i] = index;
        }
        return ans;
    }

    private int binarySearch(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid + 1;
            if (nums[mid] < target)
                left = mid + 1;
            else

=== Chunk 1803 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2389.longest-subsequence-with-limited-sum\LongestSubsequenceWithLimitedSum2.java

else
                right = mid - 1;
        }
        return nums[left] > target ? left : left + 1;
    }
}

=== Chunk 1804 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2389.longest-subsequence-with-limited-sum\LongestSubsequenceWithLimitedSumTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1805 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2389.longest-subsequence-with-limited-sum\LongestSubsequenceWithLimitedSumTest.java

public class LongestSubsequenceWithLimitedSumTest {
    LongestSubsequenceWithLimitedSum longestSubsequenceWithLimitedSum = new LongestSubsequenceWithLimitedSum();
    LongestSubsequenceWithLimitedSum2 longestSubsequenceWithLimitedSum2 = new LongestSubsequenceWithLimitedSum2();

    @Test
    void Example1() {
        int[] nums = {4, 5, 2, 1}, queries = {3, 10, 21};

        Assertions.assertArrayEquals(new int[]{2, 3, 4}, longestSubsequenceWithLimitedSum.answerQueries(nums,queries));
        Assertions.assertArrayEquals(new int[]{2, 3, 4}, longestSubsequenceWithLimitedSum2.answerQueries(nums,queries));
    }

    @Test
    void Example2() {
        int[] nums = {2, 3, 4, 5}, queries = {1};

=== Chunk 1806 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2389.longest-subsequence-with-limited-sum\LongestSubsequenceWithLimitedSumTest.java

Assertions.assertArrayEquals(new int[]{0}, longestSubsequenceWithLimitedSum.answerQueries(nums,queries));
        Assertions.assertArrayEquals(new int[]{0}, longestSubsequenceWithLimitedSum2.answerQueries(nums,queries));
    }
}

=== Chunk 1807 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2390.removing-stars-from-a-string\RemovingStarsFromAString.java

import java.util.Stack;

class RemovingStarsFromAString {
    public String removeStars(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c == '*' && !stack.isEmpty()) {
                stack.pop();
            } else {
                stack.push(c);
            }
        }

        StringBuilder res = new StringBuilder();
        while (!stack.isEmpty()) {
            res.insert(0, stack.pop());
        }

        return res.toString();
    }
}

=== Chunk 1808 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2390.removing-stars-from-a-string\RemovingStarsFromAStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class RemovingStarsFromAStringTest {
    RemovingStarsFromAString removingStarsFromAString = new RemovingStarsFromAString();

    @Test
    void Example1() {
        String s = "leet**cod*e";

        Assertions.assertEquals("lecoe", removingStarsFromAString.removeStars(s));
    }

    @Test
    void Example2() {
        String s = "erase*****";

        Assertions.assertEquals("", removingStarsFromAString.removeStars(s));
    }
}

=== Chunk 1809 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2405.optimal-partition-of-string\OptimalPartitionOfString.java

import java.util.HashMap;
import java.util.Map;

class OptimalPartitionOfString {
    public int partitionString(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int res = 0;
        for (char c : s.toCharArray()) {
            if (map.containsKey(c)) {
                map.clear();
                res++;
            }
            map.put(c, 1);
        }
        res++;
        return res;
    }
}

=== Chunk 1810 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2405.optimal-partition-of-string\OptimalPartitionOfStringTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class OptimalPartitionOfStringTest {
    OptimalPartitionOfString optimalPartitionOfString = new OptimalPartitionOfString();

    @Test
    void Example1() {
        String s = "abacaba";

        Assertions.assertEquals(4, optimalPartitionOfString.partitionString(s));
    }

    @Test
    void Example2() {
        String s = "ssssss";

        Assertions.assertEquals(6, optimalPartitionOfString.partitionString(s));
    }
}

=== Chunk 1811 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2477.minimum-fuel-cost-to-report-to-the-capital\MinimumFuelCostToReportToTheCapital.java

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

=== Chunk 1812 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2477.minimum-fuel-cost-to-report-to-the-capital\MinimumFuelCostToReportToTheCapital.java

class MinimumFuelCostToReportToTheCapital {
    long fuel;

    public long minimumFuelCost(int[][] roads, int seats) {
        Map<Integer, List<Integer>> adj = new HashMap<>();
        for (int[] road : roads) {
            adj.computeIfAbsent(road[0], k -> new ArrayList<>()).add(road[1]);
            adj.computeIfAbsent(road[1], k -> new ArrayList<>()).add(road[0]);
        }
        dfs(0, -1, adj, seats);
        return fuel;
    }

    private long dfs(int node, int parent, Map<Integer, List<Integer>> adj, int seats) {
        int representatives = 1;
        if (!adj.containsKey(node))
            return representatives;
        for (int child : adj.get(node)) {
            if (child != parent)
                representatives += dfs(child, node, adj, seats);

=== Chunk 1813 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2477.minimum-fuel-cost-to-report-to-the-capital\MinimumFuelCostToReportToTheCapital.java

}
        if (node != 0)
            fuel += Math.ceil((double) representatives / seats);
        return representatives;
    }
}

=== Chunk 1814 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2477.minimum-fuel-cost-to-report-to-the-capital\MinimumFuelCostToReportToTheCapitalTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

=== Chunk 1815 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2477.minimum-fuel-cost-to-report-to-the-capital\MinimumFuelCostToReportToTheCapitalTest.java

public class MinimumFuelCostToReportToTheCapitalTest {
    MinimumFuelCostToReportToTheCapital minimumFuelCostToReportToTheCapital = new MinimumFuelCostToReportToTheCapital();

    @Test
    void Example1() {
        int[][] roads = {{0, 1}, {0, 2}, {0, 3}};
        int seats = 5;

        Assertions.assertEquals(3, minimumFuelCostToReportToTheCapital.minimumFuelCost(roads, seats));
    }

    @Test
    void Example2() {
        int[][] roads = {{3, 1}, {3, 2}, {1, 0}, {0, 4}, {0, 5}, {4, 6}};
        int seats = 2;

        Assertions.assertEquals(7, minimumFuelCostToReportToTheCapital.minimumFuelCost(roads, seats));
    }

    @Test
    void Example3() {
        int[][] roads = {};
        int seats = 1;

=== Chunk 1816 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2477.minimum-fuel-cost-to-report-to-the-capital\MinimumFuelCostToReportToTheCapitalTest.java

int seats = 1;

        Assertions.assertEquals(0, minimumFuelCostToReportToTheCapital.minimumFuelCost(roads, seats));
    }
}

=== Chunk 1817 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2492.minimum-score-of-a-path-between-two-cities\MinimumScoreOfAPathBetweenTwoCities.java

import java.util.ArrayList;
import java.util.List;

=== Chunk 1818 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2492.minimum-score-of-a-path-between-two-cities\MinimumScoreOfAPathBetweenTwoCities.java

class MinimumScoreOfAPathBetweenTwoCities {
    int res = Integer.MAX_VALUE;

    public int minScore(int n, int[][] roads) {
        List<List<int[]>> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new ArrayList<>());
        }
        for (int[] road : roads) {
            int s = road[0] - 1;
            int d = road[1] - 1;
            int weight = road[2];
            list.get(s).add(new int[]{d, weight});
            list.get(d).add(new int[]{s, weight});
        }
        boolean[] visited = new boolean[n];
        dfs(list, 0, visited);
        return res;
    }

    private void dfs(List<List<int[]>> list, int start, boolean[] visited) {
        if (visited[start]) {
            return;
        }

=== Chunk 1819 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2492.minimum-score-of-a-path-between-two-cities\MinimumScoreOfAPathBetweenTwoCities.java

return;
        }
        visited[start] = true;
        for (int[] next : list.get(start)) {
            if (res > next[1]) {
                res = next[1];
            }
            dfs(list, next[0], visited);
        }
    }
}

=== Chunk 1820 ===
Source: W:\Users\cayab\dataset-QA-prep\rag\..\data\java-data-good\LeetCode-in-Java\Algorithms\2492.minimum-score-of-a-path-between-two-cities\MinimumScoreOfAPathBetweenTwoCitiesTest.java

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class MinimumScoreOfAPathBetweenTwoCitiesTest {
    MinimumScoreOfAPathBetweenTwoCities minimumScoreOfAPathBetweenTwoCities = new MinimumScoreOfAPathBetweenTwoCities();

    @Test
    void Example1() {
        int n = 4;
        int[][] roads = {{1, 2, 9}, {2, 3, 6}, {2, 4, 5}, {1, 4, 7}};

        Assertions.assertEquals(5,  minimumScoreOfAPathBetweenTwoCities.minScore(n,  roads));
    }

    @Test
    void Example2() {
        int n = 4;
        int[][] roads = {{1, 2, 2}, {1, 3, 4}, {3, 4, 7}};

        Assertions.assertEquals(2,  minimumScoreOfAPathBetweenTwoCities.minScore(n,  roads));
    }
}

